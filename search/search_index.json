{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"<code>arlogi</code> library documentation","text":"<p>This documentation provides comprehensive coverage of the arlogi logging library with a special focus on the unique caller attribution feature that allows developers to trace log calls across function boundaries using the <code>from_</code> parameters.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<ul> <li>Installation and basic usage: Get started with arlogi quickly</li> <li>Caller Attribution Feature: Learn about the unique <code>from_</code> parameters</li> </ul>"},{"location":"#documentation","title":"Documentation","text":""},{"location":"#1-main-developer-guide-developer_guidemd","title":"1. Main Developer Guide (DEVELOPER_GUIDE.md)","text":"<ul> <li>Quick Start: Installation and basic usage</li> <li>Caller Attribution Feature: Comprehensive explanation of <code>from_=0</code>, <code>from_caller=1</code>, and <code>**{\"from\": 2}</code> parameters</li> <li>Global Configuration: <code>setup_logging()</code> and the modern <code>LoggingConfig</code> pattern</li> <li>Logger Types: Standard, JSON-only, and syslog loggers</li> <li>Advanced Usage: Structured logging, exception handling, log levels</li> <li>Testing Integration: Test mode detection and pytest integration</li> <li>Migration Guide: How to migrate from standard logging</li> <li>Common Patterns: Real-world usage patterns</li> </ul>"},{"location":"#2-api-reference-api_referencemd","title":"2. API Reference (API_REFERENCE.md)","text":"<ul> <li>Factory Functions: Complete parameter documentation for <code>get_logger()</code>, <code>get_json_logger()</code>, etc.</li> <li>Logger Methods: All logging methods with caller attribution parameters</li> <li>Caller Attribution Parameters: Detailed explanation of <code>from_</code>, <code>from_caller</code>, and <code>**{\"from\": depth}</code> syntax</li> <li>Depth Values: Complete table explaining what each depth value means</li> <li>Handler Types: All handler classes and their configuration options</li> <li>Type Safety: LoggerProtocol and function signatures</li> <li>Performance Considerations: Optimizations and best practices</li> </ul>"},{"location":"#3-caller-attribution-examples-caller_attribution_examplesmd","title":"3. Caller Attribution Examples (CALLER_ATTRIBUTION_EXAMPLES.md)","text":"<ul> <li>Basic Examples: <code>from_=0</code> (current function) and <code>from_=1</code> (caller function)</li> <li>Parameter Syntaxes: All three ways to specify caller attribution</li> <li>Parameter Precedence: How multiple caller parameters interact</li> <li>Cross-Module Attribution: Same vs different module calling</li> <li>Real-World Examples: Web API handlers, database operations, background jobs</li> <li>Performance Considerations: Efficient usage patterns</li> <li>Testing Examples: Unit tests with caller attribution</li> </ul>"},{"location":"#4-configuration-guide-configuration_guidemd","title":"4. Configuration Guide (CONFIGURATION_GUIDE.md)","text":"<ul> <li>Global Configuration: <code>setup_logging()</code> and <code>LoggingConfig</code> architecture</li> <li>Per-Module Configuration: Module-level log level overrides</li> <li>Handler Configuration: Console, JSON file, and syslog configuration</li> <li>Application Structure: Microservice, web app, and CLI configurations</li> <li>Environment-Specific: Development, testing, staging, production configs</li> <li>Dynamic Configuration: Runtime adjustments and environment variables</li> <li>Advanced Handlers: Multiple JSON files, custom formatters, filtering</li> <li>Performance Optimization: High-performance configurations</li> </ul>"},{"location":"#5-user-guide-user_guidemd","title":"5. User Guide (USER_GUIDE.md)","text":"<ul> <li>Getting Started: Basic usage and setup</li> <li>Advanced Features: Deep dive into arlogi capabilities</li> </ul>"},{"location":"#6-architecture-architecturemd","title":"6. Architecture (ARCHITECTURE.md)","text":"<ul> <li>System Design: High-level architecture and design decisions</li> <li>Component Overview: Detailed breakdown of library components</li> </ul>"},{"location":"#api-reference","title":"API Reference","text":""},{"location":"#core-components","title":"Core Components","text":"<ul> <li>Config: reference/arlogi/config.md</li> <li>Factory: reference/arlogi/factory.md</li> <li>Handler Factory: reference/arlogi/handler_factory.md</li> <li>Handlers: reference/arlogi/handlers.md</li> <li>Levels: reference/arlogi/levels.md</li> <li>Types: reference/arlogi/types.md</li> </ul>"},{"location":"#key-features-documented","title":"Key Features Documented","text":"<p>\u2705 <code>from_=0</code> Parameter: Shows current function name in logs \u2705 <code>from_=1</code> Parameter: Shows immediate caller function \u2705 <code>**{\"from\": depth}</code> Syntax: Alternative syntax with dictionary \u2705 <code>from_caller</code> Parameter: Alternative parameter name \u2705 Parameter Precedence: How multiple caller parameters are resolved \u2705 Stack Frame Analysis: Depth values and cross-module attribution \u2705 Performance Considerations: Minimal overhead patterns \u2705 **Real-World Usage**: Practical application examples</p>"},{"location":"#additional-resources","title":"Additional Resources","text":"<ul> <li>Developer Guide: DEVELOPER_GUIDE.md - For contributors</li> </ul>"},{"location":"API_REFERENCE/","title":"Arlogi API Reference","text":"<p>Complete API reference for the arlogi logging library v0.512.28.</p>"},{"location":"API_REFERENCE/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Modern Configuration</li> <li>Public API Functions</li> <li>Logger Protocol</li> <li>Handler Classes</li> <li>Log Levels</li> <li>Advanced API</li> </ul>"},{"location":"API_REFERENCE/#modern-configuration","title":"Modern Configuration","text":""},{"location":"API_REFERENCE/#loggingconfig","title":"<code>LoggingConfig</code>","text":"<p>The primary way to configure <code>arlogi</code> is using the <code>LoggingConfig</code> dataclass applied via <code>LoggerFactory._apply_configuration()</code>.</p> <pre><code>from arlogi import LoggingConfig, LoggerFactory\n\n# 1. Define configuration\nconfig = LoggingConfig(\n    level=\"INFO\",\n    module_levels={\"app.db\": \"DEBUG\"},\n    json_file_name=\"logs/app.jsonl\"\n)\n\n# 2. Apply configuration\nLoggerFactory._apply_configuration(config)\n</code></pre> <p>Attributes:</p> Attribute Type Default Description <code>level</code> <code>int \\| str</code> <code>logging.INFO</code> Global root log level <code>module_levels</code> <code>Dict[str, str \\| int] \\| None</code> <code>None</code> Per-module overrides <code>json_file_name</code> <code>str \\| None</code> <code>None</code> JSON log file path <code>json_file_only</code> <code>bool</code> <code>False</code> Only JSON output <code>use_syslog</code> <code>bool</code> <code>False</code> Enable syslog <code>syslog_address</code> <code>str \\| tuple</code> <code>\"/dev/log\"</code> Syslog address <code>show_time</code> <code>bool</code> <code>False</code> Show timestamps <code>show_level</code> <code>bool</code> <code>True</code> Show levels <code>show_path</code> <code>bool</code> <code>True</code> Show paths <p>Methods:</p>"},{"location":"API_REFERENCE/#loggingconfigfrom_kwargskwargs","title":"<code>LoggingConfig.from_kwargs(**kwargs)</code>","text":"<p>Create a config from keyword arguments. Useful for dynamic configuration from user inputs or environment filters.</p>"},{"location":"API_REFERENCE/#loggingconfigto_dict","title":"<code>LoggingConfig.to_dict()</code>","text":"<p>Convert configuration to a dictionary for serialization.</p>"},{"location":"API_REFERENCE/#loggingconfigresolve_module_levelname-level","title":"<code>LoggingConfig.resolve_module_level(name, level)</code>","text":"<p>Resolve a module level string to an integer.</p> <pre><code>level_int = config.resolve_module_level(\"app.db\", \"DEBUG\")\n</code></pre> <p>Properties:</p> Property Type Description <code>resolved_level</code> <code>int</code> Global level as integer <code>show_console</code> <code>bool</code> Whether console output is enabled <code>has_json_output</code> <code>bool</code> Whether JSON output is configured"},{"location":"API_REFERENCE/#public-api-functions","title":"Public API Functions","text":""},{"location":"API_REFERENCE/#setup_loggingkwargs-deprecated","title":"<code>setup_logging(**kwargs)</code> (Deprecated)","text":"<p>[!WARNING] This function is considered legacy and is deprecated in favor of the <code>LoggingConfig</code> pattern. It internally creates a <code>LoggingConfig</code> and applies it for you.</p> <p>Configure application-wide logging with arlogi.</p> <pre><code>from arlogi import setup_logging\n\nsetup_logging(\n    level=\"INFO\",\n    module_levels={\"app.db\": \"DEBUG\"},\n    json_file_name=\"logs/app.jsonl\"\n)\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>level</code> <code>int \\| str</code> <code>\"INFO\"</code> Global root log level <code>module_levels</code> <code>Dict[str, str \\| int]</code> <code>None</code> Per-module level overrides <code>json_file_name</code> <code>str \\| None</code> <code>None</code> Path to JSON log file <code>json_file_only</code> <code>bool</code> <code>False</code> Only output JSON (no console) <code>use_syslog</code> <code>bool</code> <code>False</code> Enable syslog output <code>syslog_address</code> <code>str \\| tuple</code> <code>\"/dev/log\"</code> Syslog server address <code>show_time</code> <code>bool</code> <code>False</code> Show timestamps in console <code>show_level</code> <code>bool</code> <code>True</code> Show log levels in console <code>show_path</code> <code>bool</code> <code>True</code> Show file paths in console"},{"location":"API_REFERENCE/#get_loggername-levelnone","title":"<code>get_logger(name, level=None)</code>","text":"<p>Get a logger instance with caller attribution support.</p> <pre><code>from arlogi import get_logger\n\nlogger = get_logger(\"my_app.module\")\nlogger.info(\"Application started\", from_=1)\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>name</code> <code>str</code> required Logger name (typically <code>__name__</code>) <code>level</code> <code>int \\| str \\| None</code> <code>None</code> Optional level override <p>Returns: <code>LoggerProtocol</code> - A logger instance</p>"},{"location":"API_REFERENCE/#get_json_loggername-json_file_namenone","title":"<code>get_json_logger(name, json_file_name=None)</code>","text":"<p>Get a logger that only outputs JSON, bypassing root handlers.</p> <pre><code>from arlogi import get_json_logger\n\naudit_logger = get_json_logger(\"audit\", \"logs/audit.jsonl\")\naudit_logger.info(\"User logged in\", extra={\"user_id\": 123})\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>name</code> <code>str</code> <code>\"json\"</code> Logger name suffix <code>json_file_name</code> <code>str \\| None</code> <code>None</code> Optional file path <p>Returns: <code>LoggerProtocol</code> - A JSON-only logger instance</p>"},{"location":"API_REFERENCE/#get_syslog_loggername-addressdevlog","title":"<code>get_syslog_logger(name, address=\"/dev/log\")</code>","text":"<p>Get a logger that only outputs to Syslog.</p> <pre><code>from arlogi import get_syslog_logger\n\nsyslog_logger = get_syslog_logger(\"security\")\nsyslog_logger.warning(\"Unauthorized access attempt\")\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>name</code> <code>str</code> <code>\"syslog\"</code> Logger name suffix <code>address</code> <code>str \\| tuple</code> <code>\"/dev/log\"</code> Syslog server address <p>Returns: <code>LoggerProtocol</code> - A syslog-only logger instance</p>"},{"location":"API_REFERENCE/#logger-protocol","title":"Logger Protocol","text":""},{"location":"API_REFERENCE/#loggerprotocol","title":"<code>LoggerProtocol</code>","text":"<p>Protocol defining the interface for arlogi loggers.</p> <p>Methods:</p>"},{"location":"API_REFERENCE/#standard-logging-methods","title":"Standard Logging Methods","text":"<p>All methods support caller attribution via <code>from_</code>, <code>from_caller</code>, or <code>**{\"from\": N}</code>.</p> <pre><code>logger.trace(msg, *args, from_=0, **kwargs)\nlogger.debug(msg, *args, from_=0, **kwargs)\nlogger.info(msg, *args, from_=0, **kwargs)\nlogger.warning(msg, *args, from_=0, **kwargs)\nlogger.error(msg, *args, from_=0, **kwargs)\nlogger.critical(msg, *args, from_=0, **kwargs)\nlogger.exception(msg, *args, from_=0, **kwargs)\nlogger.log(level, msg, *args, from_=0, **kwargs)\n</code></pre> <p>Caller Attribution Parameters:</p> Parameter Type Description <code>from_</code> <code>int \\| None</code> Stack depth (0=current, 1=caller, 2+=deeper) <code>from_caller</code> <code>int \\| None</code> Alternative to <code>from_</code> <code>from</code> <code>int</code> Via dict syntax: <code>**{\"from\": 0}</code>"},{"location":"API_REFERENCE/#level-management","title":"Level Management","text":"<pre><code>logger.setLevel(level)      # Set logger level\nlogger.isEnabledFor(level)  # Check if level is enabled\nlogger.getEffectiveLevel()  # Get effective level\n</code></pre>"},{"location":"API_REFERENCE/#properties","title":"Properties","text":"Property Type Description <code>name</code> <code>str</code> Logger name"},{"location":"API_REFERENCE/#handler-classes","title":"Handler Classes","text":""},{"location":"API_REFERENCE/#coloredconsolehandler","title":"<code>ColoredConsoleHandler</code>","text":"<p>Rich-based colored console handler with premium formatting.</p> <pre><code>from arlogi.handlers import ColoredConsoleHandler\n\nhandler = ColoredConsoleHandler(\n    show_time=True,\n    show_level=True,\n    show_path=True,\n    level_styles={\"info\": \"blue\", \"error\": \"red\"}\n)\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>show_time</code> <code>bool</code> <code>False</code> Show timestamps <code>show_level</code> <code>bool</code> <code>True</code> Show log levels <code>show_path</code> <code>bool</code> <code>True</code> Show file paths <code>level_styles</code> <code>Dict[str, str] \\| None</code> <code>None</code> Custom level colors <code>project_root</code> <code>str \\| None</code> <code>auto-detected</code> Project root for paths <p>Level Color Options:</p> Level Default Color Alternative Colors TRACE <code>grey37</code> <code>dim cyan</code>, <code>dim blue</code> DEBUG <code>grey37</code> <code>dim cyan</code>, <code>grey50</code> INFO <code>grey75</code> <code>white</code>, <code>green</code> WARNING <code>yellow</code> <code>orange</code>, <code>bold yellow</code> ERROR <code>red</code> <code>bold red</code>, <code>bright_red</code> CRITICAL <code>bold red</code> <code>red on white</code>, <code>reverse red</code>"},{"location":"API_REFERENCE/#jsonhandler","title":"<code>JSONHandler</code>","text":"<p>Stream handler that outputs JSON to stderr.</p> <pre><code>from arlogi.handlers import JSONHandler\n\nhandler = JSONHandler()\n</code></pre> <p>JSON Output Format:</p> <pre><code>{\n  \"timestamp\": \"2025-12-28T10:30:00.123456\",\n  \"level\": \"INFO\",\n  \"logger_name\": \"my_app\",\n  \"message\": \"User logged in\",\n  \"module\": \"main\",\n  \"function\": \"login\",\n  \"line_number\": 42,\n  \"user_id\": 123,\n  \"ip\": \"192.168.1.1\"\n}\n</code></pre>"},{"location":"API_REFERENCE/#jsonfilehandler","title":"<code>JSONFileHandler</code>","text":"<p>File handler that outputs JSON to a file.</p> <pre><code>from arlogi.handlers import JSONFileHandler\n\nhandler = JSONFileHandler(\n    filename=\"logs/app.jsonl\",\n    mode=\"a\",\n    encoding=\"utf-8\"\n)\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>filename</code> <code>str</code> required Path to log file <code>mode</code> <code>str</code> <code>\"a\"</code> File open mode <code>encoding</code> <code>str \\| None</code> <code>None</code> File encoding <code>delay</code> <code>bool</code> <code>False</code> Delay file opening <p>Note: Parent directories are created automatically.</p>"},{"location":"API_REFERENCE/#arlogisysloghandler","title":"<code>ArlogiSyslogHandler</code>","text":"<p>Syslog handler with automatic fallback support.</p> <pre><code>from arlogi.handlers import ArlogiSyslogHandler\n\nhandler = ArlogiSyslogHandler(\n    address=\"/dev/log\",  # or (\"localhost\", 514)\n    facility=\"user\",\n    socktype=None\n)\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>address</code> <code>str \\| tuple</code> <code>\"/dev/log\"</code> Syslog server address <code>facility</code> <code>int \\| str</code> <code>LOG_USER</code> Syslog facility <code>socktype</code> <code>int \\| None</code> <code>None</code> Socket type <p>Fallback Behavior:</p> <ol> <li>Tries the specified address</li> <li>If <code>/dev/log</code> fails, tries UDP on <code>localhost:514</code></li> <li>If all fail, silently continues (won't crash the app)</li> </ol>"},{"location":"API_REFERENCE/#log-levels","title":"Log Levels","text":""},{"location":"API_REFERENCE/#standard-python-levels","title":"Standard Python Levels","text":"<pre><code>import logging\n\nlogging.DEBUG    # 10\nlogging.INFO     # 20\nlogging.WARNING  # 30\nlogging.ERROR    # 40\nlogging.CRITICAL # 50\n</code></pre>"},{"location":"API_REFERENCE/#custom-arlogi-level","title":"Custom Arlogi Level","text":"<pre><code>from arlogi import TRACE\n\nTRACE  # 5 - Below DEBUG for ultra-detailed logging\n</code></pre>"},{"location":"API_REFERENCE/#level-usage-guidelines","title":"Level Usage Guidelines","text":"Level Value Use Case TRACE 5 Function entry/exit, variable dumps DEBUG 10 Detailed troubleshooting info INFO 20 General application flow WARNING 30 Unexpected but recoverable issues ERROR 40 Errors that don't stop execution CRITICAL 50 Serious failures, possible shutdown"},{"location":"API_REFERENCE/#advanced-api","title":"Advanced API","text":""},{"location":"API_REFERENCE/#loggerfactory","title":"<code>LoggerFactory</code>","text":"<p>Factory for creating and configuring loggers.</p> <pre><code>from arlogi import LoggerFactory\n\n# Direct setup\nLoggerFactory.setup(level=\"INFO\")\n\n# Get logger\nlogger = LoggerFactory.get_logger(\"my_app\")\n\n# Get dedicated loggers\njson_logger = LoggerFactory.get_json_logger(\"audit\")\nsyslog_logger = LoggerFactory.get_syslog_logger(\"security\")\n</code></pre> <p>Class Methods:</p> Method Description <code>setup(**kwargs)</code> Configure logging <code>get_logger(name, level)</code> Get a logger <code>get_json_logger(name, file)</code> Get JSON-only logger <code>get_syslog_logger(name, addr)</code> Get syslog-only logger <code>is_test_mode()</code> Check if in test environment <p>Internal Methods:</p> Method Description <code>_apply_configuration(config)</code> Apply LoggingConfig <code>_initialize_trace_level()</code> Register TRACE level <code>_configure_root_logger(config)</code> Set root logger level <code>_clear_and_add_handlers(config)</code> Configure handlers <code>_configure_module_levels(config)</code> Set module levels"},{"location":"API_REFERENCE/#handlerfactory","title":"<code>HandlerFactory</code>","text":"<p>Factory for creating log handlers.</p> <pre><code>from arlogi import HandlerFactory, LoggingConfig\n\nconfig = LoggingConfig(show_time=True, show_level=True)\n\n# Create individual handlers\nconsole = HandlerFactory.create_console(config)\njson_file = HandlerFactory.create_json_file(config)\nsyslog = HandlerFactory.create_syslog(config)\n\n# Create all handlers at once\nhandlers = HandlerFactory.create_handlers(config)\n</code></pre> <p>Static Methods:</p> Method Returns Description <code>create_console(config)</code> <code>ColoredConsoleHandler</code> Console handler <code>create_json_stream()</code> <code>JSONHandler</code> Stream JSON handler <code>create_json_file(config)</code> <code>JSONFileHandler</code> File JSON handler <code>create_json_handler(config)</code> <code>Handler</code> Appropriate JSON handler <code>create_syslog(config)</code> <code>ArlogiSyslogHandler</code> Syslog handler <code>create_handlers(config)</code> <code>List[Handler]</code> All configured handlers"},{"location":"API_REFERENCE/#utility-functions","title":"Utility Functions","text":""},{"location":"API_REFERENCE/#is_test_mode","title":"<code>is_test_mode()</code>","text":"<p>Detect if running under a test runner.</p> <pre><code>from arlogi import is_test_mode\n\nif is_test_mode():\n    logger.debug(\"Test mode detected\")\n</code></pre> <p>Returns: <code>bool</code> - True if pytest, unittest, or PYTEST_CURRENT_TEST is detected</p>"},{"location":"API_REFERENCE/#get_default_level","title":"<code>get_default_level()</code>","text":"<p>Get the default log level based on environment.</p> <pre><code>from arlogi import get_default_level\n\nlevel = get_default_level()  # DEBUG in tests, INFO otherwise\n</code></pre> <p>Returns: <code>int</code> - <code>logging.DEBUG</code> if in test mode, <code>logging.INFO</code> otherwise</p>"},{"location":"API_REFERENCE/#type-hints","title":"Type Hints","text":""},{"location":"API_REFERENCE/#loggerprotocol_1","title":"LoggerProtocol","text":"<pre><code>from typing import Protocol, Any\n\n@runtime_checkable\nclass LoggerProtocol(Protocol):\n    def trace(self, msg: Any, *args: Any, from_: int | None = None,\n              from_caller: int | None = None, **kwargs: Any) -&gt; None: ...\n    def debug(self, msg: Any, *args: Any, from_: int | None = None,\n              from_caller: int | None = None, **kwargs: Any) -&gt; None: ...\n    def info(self, msg: Any, *args: Any, from_: int | None = None,\n             from_caller: int | None = None, **kwargs: Any) -&gt; None: ...\n    def warning(self, msg: Any, *args: Any, from_: int | None = None,\n                from_caller: int | None = None, **kwargs: Any) -&gt; None: ...\n    def error(self, msg: Any, *args: Any, from_: int | None = None,\n              from_caller: int | None = None, **kwargs: Any) -&gt; None: ...\n    def critical(self, msg: Any, *args: Any, from_: int | None = None,\n                 from_caller: int | None = None, **kwargs: Any) -&gt; None: ...\n    def fatal(self, msg: Any, *args: Any, from_: int | None = None,\n              from_caller: int | None = None, **kwargs: Any) -&gt; None: ...\n    def exception(self, msg: Any, *args: Any, from_: int | None = None,\n                   from_caller: int | None = None, **kwargs: Any) -&gt; None: ...\n    def log(self, level: int, msg: Any, *args: Any, from_: int | None = None,\n            from_caller: int | None = None, **kwargs: Any) -&gt; None: ...\n    def setLevel(self, level: int | str) -&gt; None: ...\n    def isEnabledFor(self, level: int) -&gt; bool: ...\n    def getEffectiveLevel(self) -&gt; int: ...\n    @property\n    def name(self) -&gt; str: ...\n</code></pre>"},{"location":"API_REFERENCE/#examples","title":"Examples","text":""},{"location":"API_REFERENCE/#modern-basic-usage","title":"Modern Basic Usage","text":"<pre><code>from arlogi import LoggingConfig, LoggerFactory, get_logger\n\nconfig = LoggingConfig(level=\"INFO\")\nLoggerFactory._apply_configuration(config)\n\nlogger = get_logger(\"my_app\")\nlogger.info(\"Application started\")\n</code></pre>"},{"location":"API_REFERENCE/#caller-attribution","title":"Caller Attribution","text":"<pre><code>def outer_function():\n    logger.info(\"Processing data\", from_=1)\n\ndef inner_function():\n    logger.debug(\"Step 1\", from_=0)  # Shows inner_function\n    logger.debug(\"Step 2\", from_=1)  # Shows outer_function\n</code></pre>"},{"location":"API_REFERENCE/#advanced-module-configuration","title":"Advanced Module Configuration","text":"<pre><code>from arlogi import LoggingConfig, LoggerFactory\n\nconfig = LoggingConfig(\n    level=\"INFO\",\n    module_levels={\n        \"app.database\": \"DEBUG\",\n        \"app.network\": \"TRACE\",\n        \"app.security\": \"WARNING\"\n    }\n)\nLoggerFactory._apply_configuration(config)\n</code></pre>"},{"location":"API_REFERENCE/#json-logging","title":"JSON Logging","text":"<pre><code># With console + JSON file\nsetup_logging(json_file_name=\"logs/app.jsonl\")\n\n# JSON only to console\nsetup_logging(json_file_only=True)\n\n# Dedicated JSON logger\naudit = get_json_logger(\"audit\", \"logs/audit.jsonl\")\naudit.info(\"User action\", extra={\"user_id\": 123})\n</code></pre>"},{"location":"API_REFERENCE/#syslog","title":"Syslog","text":"<pre><code># Add syslog to root logger\nsetup_logging(use_syslog=True)\n\n# Dedicated syslog logger\nsyslog = get_syslog_logger(\"security\")\nsyslog.warning(\"Security event\")\n</code></pre>"},{"location":"API_REFERENCE/#error-handling","title":"Error Handling","text":"<p>All arlogi functions handle errors gracefully:</p> <ul> <li>Invalid log levels raise <code>ValueError</code> with helpful messages</li> <li>Syslog connection failures fall back automatically</li> <li>JSON file handler creates parent directories automatically</li> <li>Test mode detection prevents double logging in pytest</li> </ul>"},{"location":"API_REFERENCE/#version-history","title":"Version History","text":"Version Changes 0.512.21 Added LoggingConfig, HandlerFactory, reduced complexity 0.512.20 Initial caller attribution support 0.512.0 First stable release"},{"location":"API_REFERENCE/#license","title":"License","text":"<p>MIT License - see LICENSE file for details.</p>"},{"location":"ARCHITECTURE/","title":"Arlogi Architecture Documentation","text":"<p>This document describes the architecture, design patterns, and internal structure of the arlogi logging library.</p>"},{"location":"ARCHITECTURE/#table-of-contents","title":"Table of Contents","text":"<ul> <li>System Overview</li> <li>Architecture Diagrams</li> <li>Design Patterns</li> <li>Component Reference</li> <li>Data Flow</li> <li>Extensibility</li> </ul>"},{"location":"ARCHITECTURE/#system-overview","title":"System Overview","text":"<p>Arlogi is a Python logging library built on top of the standard <code>logging</code> module. It provides:</p> <ul> <li>Custom TRACE level (below DEBUG) for ultra-detailed logging</li> <li>Caller attribution via stack frame inspection</li> <li>Multiple output handlers: Rich console, JSON files, Syslog</li> <li>Type-safe configuration via dataclasses</li> <li>Factory pattern for handler creation</li> </ul>"},{"location":"ARCHITECTURE/#technology-stack","title":"Technology Stack","text":"Component Technology Purpose Core Logging <code>logging</code> module Python standard library foundation Console Output <code>rich</code> Premium colored terminal output Type Safety <code>typing.Protocol</code> Runtime-checkable type hints Configuration <code>dataclasses</code> Immutable configuration objects Structured Logs <code>json</code> Machine-readable log output"},{"location":"ARCHITECTURE/#architecture-diagrams","title":"Architecture Diagrams","text":""},{"location":"ARCHITECTURE/#c4-context-diagram","title":"C4 Context Diagram","text":"<pre><code>graph TB\n    subgraph \"Your Application\"\n        App[Application Code]\n    end\n\n    subgraph \"arlogi\"\n    subgraph \"arlogi\"\n        API[Public API&lt;br/&gt;LoggingConfig, get_logger]\n        Logger[LoggerFactory&lt;br/&gt;TraceLogger]\n        Handlers[Handlers&lt;br/&gt;Console, JSON, Syslog]\n    end\n\n    subgraph \"External Systems\"\n        Console[Terminal]\n        Files[Log Files]\n        Syslog[Syslog Server]\n    end\n\n    App --&gt; API\n    API --&gt; Logger\n    Logger --&gt; Handlers\n    Handlers --&gt; Console\n    Handlers --&gt; Files\n    Handlers --&gt; Syslog</code></pre>"},{"location":"ARCHITECTURE/#c4-container-diagram","title":"C4 Container Diagram","text":"<pre><code>graph TB\n    subgraph \"arlogi Library\"\n        subgraph \"Public API Layer\"\n            Init[__init__.py&lt;br/&gt;Public Exports]\n            Factory[factory.py&lt;br/&gt;LoggerFactory]\n        end\n\n        subgraph \"Configuration Layer\"\n            Config[config.py&lt;br/&gt;LoggingConfig]\n            HF[handler_factory.py&lt;br/&gt;HandlerFactory]\n        end\n\n        subgraph \"Core Layer\"\n            Levels[levels.py&lt;br/&gt;TRACE Registration]\n            Types[types.py&lt;br/&gt;LoggerProtocol]\n            TraceLog[TraceLogger&lt;br/&gt;Caller Attribution]\n        end\n\n        subgraph \"Handlers Layer\"\n            Console[ColoredConsoleHandler&lt;br/&gt;Rich Output]\n            JSON[JSONHandler&lt;br/&gt;Structured Logs]\n            SyslogHandler[ArlogiSyslogHandler&lt;br/&gt;Syslog Output]\n        end\n    end\n\n    Init --&gt; Factory\n    Factory --&gt; Config\n    Factory --&gt; HF\n    Factory --&gt; TraceLog\n    HF --&gt; Console\n    HF --&gt; JSON\n    HF --&gt; SyslogHandler\n    TraceLog --&gt; Types\n    TraceLog --&gt; Levels</code></pre>"},{"location":"ARCHITECTURE/#component-dependency-diagram","title":"Component Dependency Diagram","text":"<pre><code>graph LR\n    subgraph \"Public Module\"\n        Init[__init__.py]\n    end\n\n    subgraph \"Core Modules\"\n        Factory[factory.py]\n        Config[config.py]\n        HandlerFac[handler_factory.py]\n        Handlers[handlers.py]\n        Levels[levels.py]\n        Types[types.py]\n    end\n\n    Init --&gt; Factory\n    Init --&gt; Config\n    Init --&gt; HandlerFac\n    Init --&gt; Levels\n    Init --&gt; Types\n\n    Factory --&gt; Config\n    Factory --&gt; HandlerFac\n    Factory --&gt; Handlers\n    Factory --&gt; Levels\n\n    HandlerFac --&gt; Handlers</code></pre>"},{"location":"ARCHITECTURE/#sequence-diagram-logging-flow","title":"Sequence Diagram: Logging Flow","text":"<pre><code>sequenceDiagram\n    participant App as Application\n    participant Config as LoggingConfig\n    participant Factory as LoggerFactory\n    participant Logger as TraceLogger\n    participant Handler as ColoredConsoleHandler\n    participant Rich as RichHandler\n    participant Console as Terminal\n\n    App-&gt;&gt;Config: LoggingConfig(level=\"INFO\")\n    App-&gt;&gt;Factory: _apply_configuration(config)\n    Factory-&gt;&gt;Logger: Root Logger level set\n    Factory-&gt;&gt;Handler: Handlers created/added\n    App-&gt;&gt;Logger: logger.info(\"msg\", from_=1)\n    Logger-&gt;&gt;Logger: _process_params (attribution)\n    Logger-&gt;&gt;Handler: emit(record)\n    Handler-&gt;&gt;Rich: _log_render(...)\n    Rich-&gt;&gt;Console: Print formatted output</code></pre>"},{"location":"ARCHITECTURE/#class-diagram","title":"Class Diagram","text":"<pre><code>classDiagram\n    class LoggingConfig {\n        &lt;&lt;frozen dataclass&gt;&gt;\n        +int|str level\n        +dict module_levels\n        +str json_file_name\n        +bool json_file_only\n        +bool use_syslog\n        +str|tuple syslog_address\n        +bool show_time\n        +bool show_level\n        +bool show_path\n        +resolved_level() int\n        +show_console() bool\n        +has_json_output() bool\n        +from_kwargs(**kwargs) LoggingConfig\n        +to_dict() dict\n    }\n\n    class HandlerFactory {\n        &lt;&lt;factory&gt;&gt;\n        +create_console(config) ColoredConsoleHandler\n        +create_json_stream() JSONHandler\n        +create_json_file(config) JSONFileHandler\n        +create_json_handler(config) Handler\n        +create_syslog(config) ArlogiSyslogHandler\n        +create_handlers(config) List~Handler~\n    }\n\n    class LoggerFactory {\n        &lt;&lt;factory&gt;&gt;\n        _initialized: bool\n        _global_logger: TraceLogger|None\n        +_apply_configuration(config) None\n        +get_logger(name, level) LoggerProtocol\n        +get_json_logger(name, file) LoggerProtocol\n        +get_syslog_logger(name, addr) LoggerProtocol\n        +is_test_mode() bool\n        +setup(**kwargs) None (Legacy)\n        -_initialize_trace_level() None\n        -_configure_root_logger(config) None\n        -_clear_and_add_handlers(config) None\n        -_configure_module_levels(config) None\n    }\n\n    class TraceLogger {\n        extends Logger\n        +_get_caller_info(depth) tuple\n        +_process_params(msg, kwargs) tuple\n        +trace(msg, *args, **kwargs) None\n        +debug(msg, *args, **kwargs) None\n        +info(msg, *args, **kwargs) None\n        +warning(msg, *args, **kwargs) None\n        +error(msg, *args, **kwargs) None\n        +critical(msg, *args, **kwargs) None\n        +exception(msg, *args, **kwargs) None\n        +log(level, msg, *args, **kwargs) None\n    }\n\n    class LoggerProtocol {\n        &lt;&lt;protocol&gt;&gt;\n        +trace(msg, *args, **kwargs) None\n        +debug(msg, *args, **kwargs) None\n        +info(msg, *args, **kwargs) None\n        +warning(msg, *args, **kwargs) None\n        +error(msg, *args, **kwargs) None\n        +critical(msg, *args, **kwargs) None\n        +exception(msg, *args, **kwargs) None\n        +log(level, msg, *args, **kwargs) None\n        +setLevel(level) None\n        +isEnabledFor(level) bool\n        +getEffectiveLevel() int\n        +name: str\n    }\n\n    class ColoredConsoleHandler {\n        extends RichHandler\n        -level_styles: dict\n        -project_root: str\n        +_find_project_root() str\n        +render(record, traceback, message) Any\n        +get_level_text(record) Any\n        +render_message(record, message) Any\n    }\n\n    class JSONHandler {\n        extends StreamHandler\n    }\n\n    class JSONFileHandler {\n        extends FileHandler\n    }\n\n    class ArlogiSyslogHandler {\n        extends SysLogHandler\n    }\n\n    LoggingConfig ..&gt; HandlerFactory : uses\n    LoggingConfig ..&gt; LoggerFactory : uses\n    LoggerFactory ..&gt; HandlerFactory : uses\n    LoggerFactory ..&gt; TraceLogger : creates\n    TraceLogger ..|&gt; LoggerProtocol : implements\n    HandlerFactory ..&gt; ColoredConsoleHandler : creates\n    HandlerFactory ..&gt; JSONHandler : creates\n    HandlerFactory ..&gt; JSONFileHandler : creates\n    HandlerFactory ..&gt; ArlogiSyslogHandler : creates</code></pre>"},{"location":"ARCHITECTURE/#design-patterns","title":"Design Patterns","text":""},{"location":"ARCHITECTURE/#factory-pattern","title":"Factory Pattern","text":"<p>HandlerFactory encapsulates handler creation logic:</p> <pre><code># Instead of direct instantiation\nhandler = ColoredConsoleHandler(show_time=True)\n\n# Use factory for consistency and testability\nhandler = HandlerFactory.create_console(config)\n</code></pre> <p>Benefits:</p> <ul> <li>Single responsibility per factory method</li> <li>Easy to add new handler types</li> <li>Simplified testing with mock factories</li> </ul>"},{"location":"ARCHITECTURE/#builder-pattern","title":"Builder Pattern","text":"<p>LoggingConfig.from_kwargs() provides flexible configuration:</p> <pre><code># Build configuration from multiple sources\nconfig = LoggingConfig.from_kwargs(\n    level=\"INFO\",\n    module_levels={\"app.db\": \"DEBUG\"}\n)\nLoggerFactory._apply_configuration(config)\n</code></pre>"},{"location":"ARCHITECTURE/#protocol-pattern","title":"Protocol Pattern","text":"<p>LoggerProtocol defines the logger interface:</p> <pre><code>@runtime_checkable\nclass LoggerProtocol(Protocol):\n    def info(self, msg: Any, *args: Any, **kwargs: Any) -&gt; None: ...\n</code></pre> <p>Benefits:</p> <ul> <li>Type safety without inheritance</li> <li>Runtime checking with <code>isinstance()</code></li> <li>Structural subtyping support</li> </ul>"},{"location":"ARCHITECTURE/#strategy-pattern","title":"Strategy Pattern","text":"<p>Different handlers implement different output strategies:</p> <pre><code># Console strategy\nconsole = ColoredConsoleHandler()\n\n# JSON strategy\njson_handler = JSONHandler()\n\n# Syslog strategy\nsyslog = ArlogiSyslogHandler()\n</code></pre>"},{"location":"ARCHITECTURE/#component-reference","title":"Component Reference","text":""},{"location":"ARCHITECTURE/#core-modules","title":"Core Modules","text":"Module Responsibility Lines of Code <code>factory.py</code> Logger creation and configuration ~450 <code>handlers.py</code> Output handler implementations ~340 <code>config.py</code> Configuration dataclass ~195 <code>handler_factory.py</code> Handler factory ~170 <code>levels.py</code> TRACE level registration ~20 <code>types.py</code> Logger protocol definition ~25"},{"location":"ARCHITECTURE/#file-structure","title":"File Structure","text":"<pre><code>src/arlogi/\n\u251c\u2500\u2500 __init__.py              # Public API exports\n\u251c\u2500\u2500 config.py                # LoggingConfig dataclass\n\u251c\u2500\u2500 factory.py               # LoggerFactory, TraceLogger\n\u251c\u2500\u2500 handler_factory.py       # HandlerFactory\n\u251c\u2500\u2500 handlers.py              # All handler classes\n\u251c\u2500\u2500 levels.py                # TRACE level registration\n\u2514\u2500\u2500 types.py                 # LoggerProtocol\n</code></pre>"},{"location":"ARCHITECTURE/#data-flow","title":"Data Flow","text":""},{"location":"ARCHITECTURE/#initialization-flow","title":"Initialization Flow","text":"<p>The system supports two initialization paths: the modern <code>LoggingConfig</code> path (recommended) and the standard <code>setup_logging</code> helper (legacy).</p> <pre><code>graph TD\n    subgraph \"Legacy Helper\"\n        A[setup_logging] --&gt; B[\"LoggingConfig.from_kwargs\"]\n    end\n\n    subgraph \"Modern Path (Recommended)\"\n        Direct[LoggingConfig init]\n    end\n\n    B --&gt; C[\"LoggerFactory._apply_configuration\"]\n    Direct --&gt; C\n\n    C --&gt; D[_initialize_trace_level]\n    C --&gt; E[_configure_root_logger]\n    C --&gt; F[is_test_mode?]\n    F --&gt;|No| G[_clear_and_add_handlers]\n    F --&gt;|Yes| H[Skip - use pytest handlers]\n    G --&gt; I[HandlerFactory.create_handlers]\n    I --&gt; J[Add handlers to root]\n    C --&gt; K[_configure_module_levels]</code></pre>"},{"location":"ARCHITECTURE/#logging-call-flow","title":"Logging Call Flow","text":"<pre><code>graph TD\n    A[logger.info] --&gt; B[_process_params]\n    B --&gt; C{from_ set?}\n    C --&gt;|Yes| D[_get_caller_info]\n    C --&gt;|No| E[Skip attribution]\n    D --&gt; F[Build attribution string]\n    F --&gt; G[Append to message]\n    E --&gt; G\n    G --&gt; H[\"super().info\"]\n    H --&gt; I[Logging.Logger.info]\n    I --&gt; J[Handler.emit]\n    J --&gt; K{Handler Type}\n    K --&gt;|Console| L[ColoredConsoleHandler]\n    K --&gt;|JSON| M[JSONHandler]\n    K --&gt;|Syslog| N[ArlogiSyslogHandler]</code></pre>"},{"location":"ARCHITECTURE/#extensibility","title":"Extensibility","text":""},{"location":"ARCHITECTURE/#adding-custom-handlers","title":"Adding Custom Handlers","text":"<pre><code>from arlogi import HandlerFactory, LoggingConfig\nfrom arlogi.handlers import ColoredConsoleHandler\n\nclass CustomConsoleHandler(ColoredConsoleHandler):\n    \"\"\"Custom handler with additional formatting.\"\"\"\n\n    def emit(self, record):\n        # Custom pre-processing\n        record.custom_field = \"custom_value\"\n        super().emit(record)\n\n# Extend HandlerFactory\nclass ExtendedHandlerFactory(HandlerFactory):\n    @staticmethod\n    def create_custom(config):\n        return CustomConsoleHandler(\n            show_time=config.show_time,\n            show_level=config.show_level\n        )\n</code></pre>"},{"location":"ARCHITECTURE/#adding-custom-log-levels","title":"Adding Custom Log Levels","text":"<pre><code>import logging\nfrom arlogi.levels import TRACE_LEVEL_NUM\n\n# Define a new level\nVERBOSE = 8  # Between TRACE (5) and DEBUG (10)\n\n# Register it\nlogging.addLevelName(VERBOSE, \"VERBOSE\")\nsetattr(logging, \"VERBOSE\", VERBOSE)\n\n# Use it\nlogger.log(VERBOSE, \"Verbose message\")\n</code></pre>"},{"location":"ARCHITECTURE/#custom-configuration-sources","title":"Custom Configuration Sources","text":"<pre><code>from arlogi import LoggingConfig\nimport yaml\n\ndef config_from_yaml(file_path):\n    \"\"\"Load LoggingConfig from YAML file.\"\"\"\n    with open(file_path) as f:\n        data = yaml.safe_load(f)\n    return LoggingConfig(**data)\n\n# Use it\nconfig = config_from_yaml(\"logging_config.yaml\")\n</code></pre>"},{"location":"ARCHITECTURE/#performance-considerations","title":"Performance Considerations","text":""},{"location":"ARCHITECTURE/#caller-attribution-overhead","title":"Caller Attribution Overhead","text":"Operation Time Notes Standard log call ~0.5\u03bcs No attribution Log with <code>from_=</code> ~1.5\u03bcs Stack frame inspection Deep stack (depth=5) ~3\u03bcs Multiple frame walks <p>Optimization Tip: Use <code>from_</code> only in development/debug builds.</p>"},{"location":"ARCHITECTURE/#memory-usage","title":"Memory Usage","text":"Component Memory Notes LoggingConfig ~200 bytes Immutable, shared TraceLogger ~1KB Per logger instance Handler instances ~500 bytes each Varies by handler type"},{"location":"ARCHITECTURE/#error-handling-strategy","title":"Error Handling Strategy","text":""},{"location":"ARCHITECTURE/#graceful-degradation","title":"Graceful Degradation","text":"<pre><code>graph TD\n    A[Logging Call] --&gt; B{Handler Available?}\n    B --&gt;|Yes| C[Emit to Handler]\n    B --&gt;|No| D[Fallback to Stderr]\n    C --&gt; E{Emit Success?}\n    E --&gt;|Yes| F[Continue]\n    E --&gt;|No| D\n    D --&gt; F</code></pre>"},{"location":"ARCHITECTURE/#error-boundaries","title":"Error Boundaries","text":"Component Error Handling LoggingConfig Validates on init, raises ValueError HandlerFactory Raises ValueError for invalid config LoggerFactory Silently falls back on handler errors ColoredConsoleHandler Falls back to basic formatting ArlogiSyslogHandler Falls back to UDP, then silent"},{"location":"ARCHITECTURE/#testing-strategy","title":"Testing Strategy","text":""},{"location":"ARCHITECTURE/#test-mode-detection","title":"Test Mode Detection","text":"<pre><code>def is_test_mode() -&gt; bool:\n    return (\n        \"pytest\" in sys.modules\n        or \"unittest\" in sys.modules\n        or os.environ.get(\"PYTEST_CURRENT_TEST\") is not None\n    )\n</code></pre> <p>In test mode:</p> <ul> <li>Default level is DEBUG (not INFO)</li> <li>Handlers are NOT added to root (prevents double logging)</li> <li>Works seamlessly with <code>caplog</code> fixture</li> </ul>"},{"location":"ARCHITECTURE/#version-compatibility","title":"Version Compatibility","text":"Python arlogi Status 3.13+ 0.512+ Supported 3.12 0.512+ Supported (with uv) 3.11 0.512+ Supported (with uv) &lt;3.11 - Not supported"},{"location":"ARCHITECTURE/#future-enhancements","title":"Future Enhancements","text":""},{"location":"ARCHITECTURE/#planned-features","title":"Planned Features","text":"<ol> <li>Async Handlers - AsyncIO-compatible log handlers</li> <li>Log Rotation - Built-in rotation for JSON files</li> <li>Filter Support - Per-handler log filtering</li> <li>Context Injection - Automatic request/context IDs</li> <li>Metrics Integration - OpenTelemetry integration</li> </ol>"},{"location":"ARCHITECTURE/#extension-points","title":"Extension Points","text":"<ul> <li>Custom formatters via <code>Formatter</code> subclassing</li> <li>Custom filters via <code>Filter</code> subclassing</li> <li>Custom handlers via <code>Handler</code> subclassing</li> <li>Configuration plugins via <code>LoggingConfig</code> inheritance</li> </ul>"},{"location":"ARCHITECTURE/#references","title":"References","text":"<ul> <li>Python Logging Documentation</li> <li>Rich Library</li> <li>C4 Model</li> <li>SOLID Principles</li> </ul>"},{"location":"CALLER_ATTRIBUTION_EXAMPLES/","title":"Caller Attribution Examples","text":"<p>Comprehensive examples demonstrating arlogi's caller attribution feature using <code>from_</code>, <code>from_caller</code>, and <code>**{\"from\": depth}</code> parameters.</p>"},{"location":"CALLER_ATTRIBUTION_EXAMPLES/#basic-caller-attribution","title":"Basic Caller Attribution","text":""},{"location":"CALLER_ATTRIBUTION_EXAMPLES/#using-from_0-current-function","title":"Using <code>from_=0</code> (Current Function)","text":"<p>Shows the function where the log call is made:</p> <pre><code>from arlogi import get_logger\n\nlogger = get_logger(\"example\")\n\ndef process_data(data):\n    # Shows [process_data()] - the current function\n    logger.info(\"Processing data started\", from_=0)\n\n    result = data * 2\n\n    # Shows [process_data()] - still the current function\n    logger.info(\"Processing completed\", from_=0, result=result)\n\n    return result\n\nprocess_data(42)\n</code></pre> <p>Output:</p> <pre><code>INFO    [process_data()]                          Processing data started\nINFO    [process_data()]                          Processing completed, result=84\n</code></pre>"},{"location":"CALLER_ATTRIBUTION_EXAMPLES/#using-from_1-immediate-caller","title":"Using <code>from_=1</code> (Immediate Caller)","text":"<p>Shows the function that called the current function:</p> <pre><code>from arlogi import get_logger\n\nlogger = get_logger(\"example\")\n\ndef helper_function():\n    # Shows [from main_function()] - the function that called helper_function\n    logger.info(\"Helper operation completed\", from_=1)\n    logger.info(\"Helper operation details\", from_=1, operation_type=\"compute\")\n\ndef main_function():\n    logger.info(\"Main started\", from_=0)\n\n    # This call will show main_function as the caller\n    helper_function()\n\n    logger.info(\"Main completed\", from_=0)\n\nmain_function()\n</code></pre> <p>Output:</p> <pre><code>INFO    [main_function()]                        Main started\nINFO    [from main_function()]                   Helper operation completed\nINFO    [from main_function()]                   Helper operation details, operation_type=compute\nINFO    [main_function()]                        Main completed\n</code></pre>"},{"location":"CALLER_ATTRIBUTION_EXAMPLES/#using-from_2-callers-caller","title":"Using <code>from_=2</code> (Caller's Caller)","text":"<p>Shows the function that called the caller:</p> <pre><code>from arlogi import get_logger\n\nlogger = get_logger(\"example\")\n\ndef deep_function():\n    # Shows [from top_function()] - two levels up the call stack\n    logger.info(\"Deep operation\", from_=2)\n    logger.info(\"Deep details\", from_=2, depth=\"deep\")\n\ndef middle_function():\n    logger.info(\"Middle function\", from_=0)\n    deep_function()\n\ndef top_function():\n    logger.info(\"Top function\", from_=0)\n    middle_function()\n\ntop_function()\n</code></pre> <p>Output:</p> <pre><code>INFO    [top_function()]                        Top function\nINFO    [middle_function()]                      Middle function\nINFO    [from top_function()]                   Deep operation\nINFO    [from top_function()]                   Deep details, depth=deep\n</code></pre>"},{"location":"CALLER_ATTRIBUTION_EXAMPLES/#different-parameter-syntaxes","title":"Different Parameter Syntaxes","text":""},{"location":"CALLER_ATTRIBUTION_EXAMPLES/#from_-parameter-recommended","title":"<code>from_</code> Parameter (Recommended)","text":"<pre><code>from arlogi import get_logger\n\nlogger = get_logger(\"syntax_example\")\n\ndef function_a():\n    function_b()\n\ndef function_b():\n    # Using from_= parameter\n    logger.info(\"Using from_=0\", from_=0)      # Shows [function_b()]\n    logger.info(\"Using from_=1\", from_=1)      # Shows [from function_a()]\n    logger.info(\"Using from_=2\", from_=2)      # Shows caller of function_a()\n\nfunction_a()\n</code></pre>"},{"location":"CALLER_ATTRIBUTION_EXAMPLES/#from_caller-parameter","title":"<code>from_caller</code> Parameter","text":"<pre><code>from arlogi import get_logger\n\nlogger = get_logger(\"syntax_example\")\n\ndef function_a():\n    function_b()\n\ndef function_b():\n    # Using from_caller parameter\n    logger.info(\"Using from_caller=0\", from_caller=0)  # Shows [function_b()]\n    logger.info(\"Using from_caller=1\", from_caller=1)  # Shows [from function_a()]\n    logger.info(\"Using from_caller=2\", from_caller=2)  # Shows caller of function_a()\n\nfunction_a()\n</code></pre>"},{"location":"CALLER_ATTRIBUTION_EXAMPLES/#from-parameter-with-dictionary-syntax","title":"<code>from</code> Parameter with Dictionary Syntax","text":"<pre><code>from arlogi import get_logger\n\nlogger = get_logger(\"syntax_example\")\n\ndef function_a():\n    function_b()\n\ndef function_b():\n    # Using from parameter with **dict syntax\n    logger.info(\"Using **{'from': 0}\", **{\"from\": 0})    # Shows [function_b()]\n    logger.info(\"Using **{'from': 1}\", **{\"from\": 1})    # Shows [from function_a()]\n    logger.info(\"Using **{'from': 2}\", **{\"from\": 2})    # Shows caller of function_a()\n\nfunction_a()\n</code></pre>"},{"location":"CALLER_ATTRIBUTION_EXAMPLES/#parameter-precedence-examples","title":"Parameter Precedence Examples","text":""},{"location":"CALLER_ATTRIBUTION_EXAMPLES/#understanding-parameter-precedence","title":"Understanding Parameter Precedence","text":"<p>When multiple caller parameters are provided, arlogi follows this precedence:</p> <ol> <li><code>from</code> (highest)</li> <li><code>from_caller</code></li> <li><code>from_</code> (lowest)</li> </ol> <pre><code>from arlogi import get_logger\n\nlogger = get_logger(\"precedence_example\")\n\ndef test_function():\n    # from_ takes precedence over from_caller when both are present\n    logger.info(\n        \"Mixed from_=0, from_caller=1\",\n        from_=0,           # This will be used (lower precedence)\n        from_caller=1      # This will be ignored (higher precedence)\n    )\n\n    # from_caller takes precedence over from_\n    logger.info(\n        \"Mixed from_=1, from_caller=0\",\n        from_=1,           # This will be ignored\n        from_caller=0      # This will be used\n    )\n\n    # from (via dict) takes highest precedence\n    logger.info(\n        \"All three parameters\",\n        **{\"from\": 2},    # This will be used (highest precedence)\n        from_caller=1,    # This will be ignored\n        from_=0           # This will be ignored\n    )\n\ntest_function()\n</code></pre> <p>Output:</p> <pre><code>INFO    [from test_function()]                   Mixed from_=0, from_caller=1\nINFO    [test_function()]                        Mixed from_=1, from_caller=0\nINFO    [from caller of test_function()]         All three parameters\n</code></pre>"},{"location":"CALLER_ATTRIBUTION_EXAMPLES/#cross-module-attribution","title":"Cross-Module Attribution","text":""},{"location":"CALLER_ATTRIBUTION_EXAMPLES/#same-module-attribution","title":"Same Module Attribution","text":"<pre><code># file: app.py\nfrom arlogi import get_logger\n\nlogger = get_logger(\"app\")\n\ndef helper_function():\n    # Shows [from main_function()] - same module, relative path\n    logger.info(\"Helper completed\", from_=1)\n\ndef main_function():\n    logger.info(\"Main started\", from_=0)\n    helper_function()\n    logger.info(\"Main completed\", from_=0)\n\nmain_function()\n</code></pre> <p>Output:</p> <pre><code>INFO    [main_function()]                        Main started\nINFO    [from main_function()]                   Helper completed\nINFO    [main_function()]                        Main completed\n</code></pre>"},{"location":"CALLER_ATTRIBUTION_EXAMPLES/#cross-module-attribution_1","title":"Cross-Module Attribution","text":"<pre><code># file: utils/helpers.py\nfrom arlogi import get_logger\n\nlogger = get_logger(\"utils.helpers\")\n\ndef process_data(data):\n    # Shows [from app.main_function()] - different module, full path\n    logger.info(\"Processing data\", from_=1, data_id=data.get(\"id\"))\n    return {\"status\": \"processed\"}\n\n# file: app/main.py\nfrom utils.helpers import process_data\nfrom arlogi import get_logger\n\nlogger = get_logger(\"app.main\")\n\ndef main_function():\n    logger.info(\"Starting main\", from_=0)\n    result = process_data({\"id\": 123, \"content\": \"test\"})\n    logger.info(\"Main completed\", from_=0, result=result)\n\nmain_function()\n</code></pre> <p>Output:</p> <pre><code>INFO    [app.main_function()]                    Starting main\nINFO    [from app.main_function()]               Processing data, data_id=123\nINFO    [app.main_function()]                    Main completed, result={'status': 'processed'}\n</code></pre>"},{"location":"CALLER_ATTRIBUTION_EXAMPLES/#real-world-application-examples","title":"Real-World Application Examples","text":""},{"location":"CALLER_ATTRIBUTION_EXAMPLES/#web-api-handler","title":"Web API Handler","text":"<pre><code>from arlogi import get_logger\n\nlogger = get_logger(\"api.handlers\")\n\ndef handle_request(request):\n    request_id = generate_request_id()\n\n    logger.info(\n        \"Request received\",\n        from_=1,  # Shows the API endpoint that called this handler\n        request_id=request_id,\n        method=request.method,\n        path=request.path\n    )\n\n    try:\n        result = process_business_logic(request)\n\n        logger.info(\n            \"Request processed successfully\",\n            from_=1,  # Still shows the API endpoint\n            request_id=request_id,\n            status_code=200\n        )\n\n        return result\n\n    except Exception as e:\n        logger.exception(\n            \"Request processing failed\",\n            from_=1,  # Shows the API endpoint\n            request_id=request_id,\n            error_type=type(e).__name__\n        )\n        raise\n\ndef user_endpoint(request):\n    # The handler call above will show [from user_endpoint()]\n    return handle_request(request)\n\ndef product_endpoint(request):\n    # The handler call above will show [from product_endpoint()]\n    return handle_request(request)\n</code></pre>"},{"location":"CALLER_ATTRIBUTION_EXAMPLES/#database-operations","title":"Database Operations","text":"<pre><code>from arlogi import get_logger\n\nlogger = get_logger(\"database.operations\")\n\ndef execute_query(query, params=None):\n    start_time = time.time()\n\n    # Show the business function that initiated the query\n    logger.trace(\n        \"Executing query\",\n        from_=1,\n        query=query,\n        params=params\n    )\n\n    try:\n        cursor = db.cursor()\n        cursor.execute(query, params or [])\n        result = cursor.fetchall()\n        duration = (time.time() - start_time) * 1000\n\n        # Show the business function for the result\n        logger.debug(\n            \"Query completed\",\n            from_=1,\n            query=query,\n            duration_ms=round(duration, 2),\n            rows_affected=len(result)\n        )\n\n        return result\n\n    except Exception as e:\n        duration = (time.time() - start_time) * 1000\n\n        # Show the business function for the error\n        logger.error(\n            \"Query failed\",\n            from_=1,\n            query=query,\n            duration_ms=round(duration, 2),\n            error=str(e)\n        )\n        raise\n\ndef get_user_profile(user_id):\n    logger.info(\"Fetching user profile\", from_=1, user_id=user_id)\n\n    query = \"SELECT * FROM users WHERE id = %s\"\n    params = (user_id,)\n\n    # execute_query will log this as [from get_user_profile()]\n    return execute_query(query, params)\n\ndef authenticate_user(username, password):\n    logger.info(\"Authenticating user\", from_=1, username=username)\n\n    query = \"SELECT * FROM users WHERE username = %s AND password_hash = %s\"\n    params = (username, hash_password(password))\n\n    # execute_query will log this as [from authenticate_user()]\n    return execute_query(query, params)\n</code></pre>"},{"location":"CALLER_ATTRIBUTION_EXAMPLES/#background-job-processing","title":"Background Job Processing","text":"<pre><code>from arlogi import get_logger\n\nlogger = get_logger(\"jobs.processor\")\n\ndef process_job(job_data):\n    job_id = job_data.get(\"id\")\n    job_type = job_data.get(\"type\")\n\n    # Show the job queue that dispatched this job\n    logger.info(\n        \"Job processing started\",\n        from_=1,\n        job_id=job_id,\n        job_type=job_type\n    )\n\n    try:\n        if job_type == \"email\":\n            result = send_email_job(job_data)\n        elif job_type == \"report\":\n            result = generate_report_job(job_data)\n        elif job_type == \"cleanup\":\n            result = cleanup_job(job_data)\n        else:\n            raise ValueError(f\"Unknown job type: {job_type}\")\n\n        # Show the job queue for completion\n        logger.info(\n            \"Job processing completed\",\n            from_=1,\n            job_id=job_id,\n            result_status=result.get(\"status\")\n        )\n\n        return result\n\n    except Exception as e:\n        # Show the job queue for failure\n        logger.exception(\n            \"Job processing failed\",\n            from_=1,\n            job_id=job_id,\n            error_type=type(e).__name__\n        )\n        raise\n\ndef email_job_dispatcher():\n    # process_job will show [from email_job_dispatcher()]\n    process_job({\n        \"id\": \"job-123\",\n        \"type\": \"email\",\n        \"to\": \"user@example.com\",\n        \"subject\": \"Welcome\"\n    })\n\ndef report_job_dispatcher():\n    # process_job will show [from report_job_dispatcher()]\n    process_job({\n        \"id\": \"job-456\",\n        \"type\": \"report\",\n        \"format\": \"pdf\",\n        \"date_range\": \"2025-01-01:2025-12-31\"\n    })\n</code></pre>"},{"location":"CALLER_ATTRIBUTION_EXAMPLES/#class-method-attribution","title":"Class Method Attribution","text":"<pre><code>from arlogi import get_logger\n\nlogger = get_logger(\"services.user\")\n\nclass UserService:\n    def __init__(self):\n        logger.info(\"UserService instance created\", from_=0)\n\n    def create_user(self, user_data):\n        logger.info(\"Creating user\", from_=1, email=user_data.get(\"email\"))\n\n        user_id = self._generate_user_id()\n        self._save_user(user_id, user_data)\n        self._send_welcome_email(user_data)\n\n        logger.info(\"User created successfully\", from_=1, user_id=user_id)\n        return user_id\n\n    def _generate_user_id(self):\n        # Shows [from create_user()] - parent method\n        logger.trace(\"Generating user ID\", from_=1)\n        return f\"user_{uuid.uuid4().hex[:8]}\"\n\n    def _save_user(self, user_id, user_data):\n        # Shows [from create_user()] - grandparent method\n        logger.debug(\"Saving user to database\", from_=2, user_id=user_id)\n        # Database save logic here\n\n    def _send_welcome_email(self, user_data):\n        # Shows [from create_user()] - grandparent method\n        logger.info(\"Sending welcome email\", from_=2, email=user_data.get(\"email\"))\n        # Email sending logic here\n\n# Usage\ndef application_logic():\n    logger.info(\"Application started\", from_=0)\n\n    service = UserService()\n\n    # create_user will show [from application_logic()]\n    user_id = service.create_user({\n        \"email\": \"newuser@example.com\",\n        \"name\": \"New User\"\n    })\n\n    logger.info(\"Application completed\", from_=0, user_id=user_id)\n</code></pre>"},{"location":"CALLER_ATTRIBUTION_EXAMPLES/#error-handling-and-exception-tracking","title":"Error Handling and Exception Tracking","text":"<pre><code>from arlogi import get_logger\n\nlogger = get_logger(\"error.tracking\")\n\ndef risky_operation(data):\n    logger.info(\"Starting risky operation\", from_=1, data_id=data.get(\"id\"))\n\n    try:\n        result = process_data(data)\n        logger.info(\"Operation successful\", from_=1, result=result)\n        return result\n\n    except ValueError as e:\n        # Show the caller function for the error\n        logger.warning(\n            \"Invalid data format\",\n            from_=1,\n            error=str(e),\n            data_type=type(data).__name__\n        )\n        raise\n\n    except ConnectionError as e:\n        # Show the caller function for connection error\n        logger.error(\n            \"Network connection failed\",\n            from_=1,\n            error=str(e),\n            retry_possible=True\n        )\n        raise\n\n    except Exception as e:\n        # Show the caller function for unexpected errors\n        logger.exception(\n            \"Unexpected error in operation\",\n            from_=1,\n            error_type=type(e).__name__\n        )\n        raise\n\ndef business_process():\n    try:\n        # risky_operation will show [from business_process()]\n        risky_operation({\"id\": 123, \"value\": \"test\"})\n    except Exception:\n        # business_process will be shown as the caller\n        logger.error(\"Business process failed\", from_=0)\n        raise\n\ndef user_interface():\n    try:\n        # risky_operation will show [from user_interface()]\n        risky_operation({\"id\": 456, \"invalid\": \"data\"})\n    except Exception:\n        # user_interface will be shown as the caller\n        logger.error(\"UI operation failed\", from_=0)\n        raise\n</code></pre>"},{"location":"CALLER_ATTRIBUTION_EXAMPLES/#performance-considerations","title":"Performance Considerations","text":""},{"location":"CALLER_ATTRIBUTION_EXAMPLES/#efficient-caller-attribution","title":"Efficient Caller Attribution","text":"<pre><code>from arlogi import get_logger\n\nlogger = get_logger(\"performance.example\")\n\ndef high_frequency_function():\n    # Standard logging without caller attribution (fast)\n    for i in range(1000):\n        logger.debug(\"Processing item %d\", i)\n\n    # Caller attribution only when needed\n    logger.info(\"Batch processing started\", from_=1, total=1000)\n\n    for i in range(1000):\n        # More expensive logging with caller attribution\n        if i % 100 == 0:  # Log every 100th item\n            logger.debug(\"Progress update\", from_=1, progress=i)\n\ndef optimized_error_tracking():\n    try:\n        # Standard logging for normal operations\n        logger.info(\"Normal operation\")\n\n        # Caller attribution only for debugging\n        if DEBUG_MODE:\n            logger.debug(\"Detailed debug info\", from_=1, complex_data=data)\n\n    except Exception as e:\n        # Always use caller attribution for errors\n        logger.exception(\"Error occurred\", from_=1, error_type=type(e).__name__)\n</code></pre>"},{"location":"CALLER_ATTRIBUTION_EXAMPLES/#testing-with-caller-attribution","title":"Testing with Caller Attribution","text":""},{"location":"CALLER_ATTRIBUTION_EXAMPLES/#unit-test-examples","title":"Unit Test Examples","text":"<pre><code>import pytest\nfrom arlogi import get_logger\n\ndef test_function_call_attribution(caplog):\n    logger = get_logger(\"test_module\")\n\n    def test_function():\n        logger.info(\"Test message\", from_=1)\n\n    with caplog.at_level(\"INFO\"):\n        test_function()\n\n        # Check that the log contains caller attribution\n        assert \"from test_function_call_attribution\" in caplog.text\n\ndef test_deep_call_attribution(caplog):\n    logger = get_logger(\"test_module\")\n\n    def deep_function():\n        logger.info(\"Deep message\", from_=2)\n\n    def middle_function():\n        deep_function()\n\n    def top_function():\n        middle_function()\n\n    with caplog.at_level(\"INFO\"):\n        top_function()\n\n        # Check that the log shows top_function as caller\n        assert \"from test_deep_call_attribution\" in caplog.text\n\ndef test_parameter_precedence(caplog):\n    logger = get_logger(\"test_module\")\n\n    with caplog.at_level(\"INFO\"):\n        # from_ should be used over from_caller\n        logger.info(\"Test message\", from_=1, from_caller=2)\n\n        # Check that from_=1 was used\n        assert \"test_parameter_precedence\" in caplog.text\n</code></pre>"},{"location":"CALLER_ATTRIBUTION_EXAMPLES/#best-practices","title":"Best Practices","text":""},{"location":"CALLER_ATTRIBUTION_EXAMPLES/#recommended-patterns","title":"Recommended Patterns","text":"<pre><code>from arlogi import get_logger\n\nlogger = get_logger(\"my_module\")\n\n# \u2705 GOOD: Use from_=0 for function entry/exit\ndef my_function():\n    logger.info(\"Function started\", from_=0)\n    # Function logic\n    logger.info(\"Function completed\", from_=0)\n\n# \u2705 GOOD: Use from_=1 to show business context\ndef helper_function():\n    logger.info(\"Helper operation\", from_=1, operation_type=\"compute\")\n\n# \u2705 GOOD: Use caller attribution for errors\ndef risky_operation():\n    try:\n        # Operation logic\n        pass\n    except Exception as e:\n        logger.exception(\"Operation failed\", from_=1, error=str(e))\n        raise\n\n# \u274c AVOID: Overusing deep caller attribution\ndef deep_function():\n    # from_=3+ is rarely useful and adds overhead\n    logger.info(\"Deep operation\", from_=3)\n\n# \u274c AVOID: Mixing different caller parameters\ndef confusing_function():\n    # This is confusing and should be avoided\n    logger.info(\"Mixed message\", from_=1, from_caller=2, **{\"from\": 3})\n</code></pre>"},{"location":"CALLER_ATTRIBUTION_EXAMPLES/#recommended-caller-attribution-depth","title":"Recommended Caller Attribution Depth","text":"<ul> <li><code>from_=0</code>: Function boundaries and state changes</li> <li><code>from_=1</code>: Business operations and user actions</li> <li><code>from_=2</code>: Rare cases for debugging complex call chains</li> <li><code>from_=3+</code>: Generally avoid unless specific debugging needs</li> </ul> <p>These examples demonstrate the power and flexibility of arlogi's caller attribution feature for creating maintainable, debuggable applications.</p>"},{"location":"CONFIGURATION_GUIDE/","title":"Configuration Guide","text":"<p>Complete guide to configuring arlogi logging for your applications, including global setup, per-module configuration, and advanced handler configuration.</p>"},{"location":"CONFIGURATION_GUIDE/#quick-configuration","title":"Quick Configuration","text":""},{"location":"CONFIGURATION_GUIDE/#modern-architecture-direct-loggingconfig-recommended","title":"Modern Architecture: Direct <code>LoggingConfig</code> (Recommended)","text":"<p>The preferred way to configure <code>arlogi</code> is using the <code>LoggingConfig</code> pattern. This approach clearly separates configuration data from initialization logic and provides a type-safe interface.</p> <pre><code>from arlogi import LoggingConfig, LoggerFactory, get_logger\n\n# 1. Configuration as a dataclass\nconfig = LoggingConfig(\n    level=\"INFO\",\n    module_levels={\"app.db\": \"DEBUG\"},\n    json_file_name=\"logs/app.jsonl\"\n)\n\n# 2. Apply via factory\nLoggerFactory._apply_configuration(config)\n\n# 3. Use loggers\nlogger = get_logger(\"my_app\")\nlogger.info(\"Application started using LoggingConfig\")\n</code></pre>"},{"location":"CONFIGURATION_GUIDE/#legacy-helper-setup_logging-deprecated","title":"Legacy Helper: <code>setup_logging()</code> (Deprecated)","text":"<p>[!WARNING] <code>setup_logging()</code> is now considered a legacy helper and is deprecated in favor of the <code>LoggingConfig</code> pattern. It remains available for backward compatibility and simple scripts.</p> <pre><code>from arlogi import setup_logging\n\n# Basic configuration (helper)\nsetup_logging(level=\"INFO\")\n</code></pre>"},{"location":"CONFIGURATION_GUIDE/#complete-production-setup","title":"Complete Production Setup","text":"<pre><code>from arlogi import LoggingConfig, LoggerFactory, get_logger\n\nconfig = LoggingConfig(\n    level=\"INFO\",\n    module_levels={\n        \"app.network\": \"TRACE\",\n        \"app.database\": \"DEBUG\",\n        \"app.security\": \"WARNING\"\n    },\n    json_file_name=\"logs/app.jsonl\",\n    json_file_only=False,\n    use_syslog=True,\n    show_time=False,\n    show_level=True,\n    show_path=True\n)\nLoggerFactory._apply_configuration(config)\n\nlogger = get_logger(\"app.main\")\nlogger.info(\"Production logging configured\")\n</code></pre>"},{"location":"CONFIGURATION_GUIDE/#configuration-reference","title":"Configuration Reference","text":""},{"location":"CONFIGURATION_GUIDE/#loggingconfig-attributes","title":"<code>LoggingConfig</code> Attributes","text":"<p>| Parameter        | Type             | Default | Description                           | | ---------------- | ---------------- | ------- | ------------------------------------- | -------------------------------- | | <code>level</code>          | <code>int             | str</code>    | <code>\"INFO\"</code>                              | Global log level for all modules | | <code>module_levels</code>  | <code>Dict[str, str]</code> | <code>{}</code>    | Per-module log level overrides        | | <code>json_file_name</code> | <code>str             | None</code>   | <code>None</code>                                | JSON log file path               | | <code>json_file_only</code> | <code>bool</code>           | <code>False</code> | Output only to JSON file (no console) | | <code>use_syslog</code>     | <code>bool</code>           | <code>False</code> | Enable syslog output                  | | <code>syslog_address</code> | <code>str             | tuple</code>  | <code>\"/dev/log\"</code>                          | Syslog server address            | | <code>show_time</code>      | <code>bool</code>           | <code>False</code> | Show timestamps in console output     | | <code>show_level</code>     | <code>bool</code>           | <code>True</code>  | Show log levels in console output     | | <code>show_path</code>      | <code>bool</code>           | <code>True</code>  | Show file paths in console output     |</p>"},{"location":"CONFIGURATION_GUIDE/#log-levels","title":"Log Levels","text":"<pre><code>import logging\nfrom arlogi import TRACE\n\n# Available levels (from lowest to highest)\nTRACE     # 5  - Custom ultra-detailed debugging\nlogging.DEBUG    # 10 - Standard debugging\nlogging.INFO     # 20 - General information\nlogging.WARNING  # 30 - Warnings\nlogging.ERROR    # 40 - Errors\nlogging.CRITICAL # 50 - Critical failures\n\n# Can use string names in LoggingConfig\nconfig = LoggingConfig(level=\"INFO\")     # Same as logging.INFO\nconfig = LoggingConfig(level=\"DEBUG\")    # Same as logging.DEBUG\nconfig = LoggingConfig(level=TRACE)      # Custom level\n</code></pre>"},{"location":"CONFIGURATION_GUIDE/#per-module-configuration","title":"Per-Module Configuration","text":""},{"location":"CONFIGURATION_GUIDE/#module-level-overrides","title":"Module-Level Overrides","text":""},{"location":"CONFIGURATION_GUIDE/#module-level-overrides_1","title":"Module-Level Overrides","text":"<pre><code>from arlogi import LoggingConfig, LoggerFactory\n\nconfig = LoggingConfig(\n    level=\"INFO\",  # Global level\n    module_levels={\n        # Ultra-detailed logging for network operations\n        \"app.network\": \"TRACE\",\n\n        # Detailed logging for database operations\n        \"app.database\": \"DEBUG\",\n\n        # Quiet security logging (warnings only)\n        \"app.security\": \"WARNING\"\n    }\n)\nLoggerFactory._apply_configuration(config)\n</code></pre>"},{"location":"CONFIGURATION_GUIDE/#module-hierarchy-matching","title":"Module Hierarchy Matching","text":"<pre><code>from arlogi import setup_logging\n\nsetup_logging(\n    level=\"INFO\",\n    module_levels={\n        # Affects: app.network.http, app.network.tcp, app.network.udp\n        \"app.network\": \"TRACE\",\n\n        # Affects: app.database.mysql, app.database.postgresql\n        \"app.database\": \"DEBUG\",\n\n        # Affects: app.cache.redis, app.cache.memory\n        \"app.cache\": \"INFO\",\n\n        # Specific module override\n        \"app.network.http.client\": \"DEBUG\"\n    }\n)\n\n# Examples:\n# get_logger(\"app.network.http\") -&gt; TRACE level\n# get_logger(\"app.network.tcp\") -&gt; TRACE level\n# get_logger(\"app.database.mysql\") -&gt; DEBUG level\n# get_logger(\"app.network.http.client\") -&gt; DEBUG level (specific override)\n# get_logger(\"app.other\") -&gt; INFO level (global)\n</code></pre>"},{"location":"CONFIGURATION_GUIDE/#handler-configuration","title":"Handler Configuration","text":""},{"location":"CONFIGURATION_GUIDE/#console-handler-configuration","title":"Console Handler Configuration","text":""},{"location":"CONFIGURATION_GUIDE/#console-handler-configuration_1","title":"Console Handler Configuration","text":"<pre><code>from arlogi import LoggingConfig, LoggerFactory\n\n# Basic console configuration\nconfig = LoggingConfig(\n    level=\"INFO\",\n    show_time=True,\n    show_level=True,\n    show_path=True\n)\nLoggerFactory._apply_configuration(config)\n\n# Disable console output (JSON file only)\nconfig = LoggingConfig(\n    level=\"INFO\",\n    json_file_name=\"logs/app.jsonl\",\n    json_file_only=True\n)\nLoggerFactory._apply_configuration(config)\n</code></pre>"},{"location":"CONFIGURATION_GUIDE/#json-file-configuration","title":"JSON File Configuration","text":"<pre><code>from arlogi import LoggingConfig, LoggerFactory\n\n# Basic JSON file logging\nconfig = LoggingConfig(json_file_name=\"logs/app.jsonl\")\nLoggerFactory._apply_configuration(config)\n\n# JSON-only logging\nconfig = LoggingConfig(\n    level=\"INFO\",\n    json_file_name=\"logs/app.jsonl\",\n    json_file_only=True\n)\nLoggerFactory._apply_configuration(config)\n</code></pre>"},{"location":"CONFIGURATION_GUIDE/#json-file-structure","title":"JSON File Structure","text":"<pre><code>{\n  \"timestamp\": \"2025-12-20T22:45:30.123456Z\",\n  \"level\": \"INFO\",\n  \"name\": \"app.main\",\n  \"message\": \"User logged in successfully\",\n  \"module\": \"main\",\n  \"function\": \"handle_login\",\n  \"line\": 42,\n  \"from_caller\": \"auth.authenticate\",\n  \"user_id\": 12345,\n  \"session_id\": \"sess_abc123\"\n}\n</code></pre>"},{"location":"CONFIGURATION_GUIDE/#custom-json-handlers","title":"Custom JSON Handlers","text":"<pre><code>from arlogi import get_logger, get_json_logger\nfrom arlogi.handlers import JSONFileHandler\n\n# Default JSON logger\njson_logger = get_json_logger(\"audit\", \"logs/audit.jsonl\")\n\n# Custom JSON handler with specific configuration\nhandler = JSONFileHandler(\n    filename=\"logs/custom.jsonl\",\n    mode=\"a\",           # Append mode\n    encoding=\"utf-8\",   # File encoding\n    delay=False         # Delay file creation\n)\n\nimport logging\ncustom_logger = get_logger(\"custom\")\ncustom_logger.addHandler(handler)\ncustom_logger.setLevel(logging.INFO)\n\ncustom_logger.info(\"Custom JSON logging\", custom_field=\"value\")\n</code></pre>"},{"location":"CONFIGURATION_GUIDE/#syslog-configuration-modern","title":"Syslog Configuration (Modern)","text":"<pre><code>from arlogi import setup_logging\n\n# Local syslog\nsetup_logging(\n    level=\"INFO\",\n    use_syslog=True,\n    syslog_address=\"/dev/log\"  # Default\n)\n\n# Remote syslog server\nsetup_logging(\n    level=\"INFO\",\n    use_syslog=True,\n    syslog_address=(\"syslog.example.com\", 514)\n)\n\n# Syslog with specific facility\nsetup_logging(\n    level=\"INFO\",\n    use_syslog=True,\n    syslog_address=\"/dev/log\"\n)\n\n# Syslog-only logger\nfrom arlogi import get_syslog_logger\nsyslog_logger = get_syslog_logger(\"security\")\nsyslog_logger.error(\"Security event detected\")\n</code></pre>"},{"location":"CONFIGURATION_GUIDE/#syslog-handler-details","title":"Syslog Handler Details","text":"<pre><code>from arlogi.handlers import ArlogiSyslogHandler\n\n# Local Unix domain socket\nhandler = ArlogiSyslogHandler(address=\"/dev/log\")\n\n# Remote UDP syslog\nhandler = ArlogiSyslogHandler(\n    address=(\"logs.example.com\", 514),\n    facility=\"user\",\n    socktype=\"UDP\"\n)\n\n# Remote TCP syslog\nhandler = ArlogiSyslogHandler(\n    address=(\"logs.example.com\", 514),\n    facility=\"daemon\",\n    socktype=\"TCP\"\n)\n\n# Custom facility\nimport syslog\nhandler = ArlogiSyslogHandler(\n    address=\"/dev/log\",\n    facility=syslog.LOG_LOCAL0\n)\n</code></pre>"},{"location":"CONFIGURATION_GUIDE/#application-structure-examples","title":"Application Structure Examples","text":""},{"location":"CONFIGURATION_GUIDE/#microservice-configuration","title":"Microservice Configuration","text":"<pre><code># config/logging.py\nfrom arlogi import setup_logging\n\ndef setup_service_logging(service_name, environment=\"production\"):\n    \"\"\"Configure logging for microservice\"\"\"\n\n    if environment == \"development\":\n        # Development: verbose console logging\n        setup_logging(\n            level=\"DEBUG\",\n            show_time=True,\n            show_level=True,\n            show_path=True\n        )\n    elif environment == \"testing\":\n        # Testing: JSON-only for automated analysis\n        setup_logging(\n            level=\"INFO\",\n            json_file_name=f\"logs/{service_name}.jsonl\",\n            json_file_only=True\n        )\n    else:\n        # Production: console + JSON + syslog\n        setup_logging(\n            level=\"INFO\",\n            module_levels={\n                f\"{service_name}.network\": \"DEBUG\",\n                f\"{service_name}.database\": \"DEBUG\"\n            },\n            json_file_name=f\"logs/{service_name}.jsonl\",\n            use_syslog=True,\n            show_time=False,\n            show_level=True,\n            show_path=True\n        )\n\n# main.py\nfrom config.logging import setup_service_logging\nfrom arlogi import get_logger\n\nsetup_service_logging(\"user-service\", environment=\"production\")\n\nlogger = get_logger(\"user-service.main\")\nlogger.info(\"User service started\")\n</code></pre>"},{"location":"CONFIGURATION_GUIDE/#web-application-configuration","title":"Web Application Configuration","text":"<pre><code># app/config.py\nfrom arlogi import setup_logging\n\nclass LoggingConfig:\n    @staticmethod\n    def configure(app_name, environment=\"development\"):\n        \"\"\"Configure logging for web application\"\"\"\n\n        base_config = {\n            \"module_levels\": {\n                f\"{app_name}.network\": \"DEBUG\",\n                f\"{app_name}.database\": \"DEBUG\",\n                f\"{app_name}.auth\": \"INFO\",\n                f\"{app_name}.api\": \"INFO\"\n            }\n        }\n\n        if environment == \"development\":\n            setup_logging(\n                level=\"DEBUG\",\n                show_time=True,\n                show_path=True,\n                **base_config\n            )\n\n        elif environment == \"staging\":\n            setup_logging(\n                level=\"INFO\",\n                json_file_name=f\"logs/{app_name}-staging.jsonl\",\n                use_syslog=True,\n                syslog_address=(\"staging-logs.company.com\", 514),\n                **base_config\n            )\n\n        elif environment == \"production\":\n            setup_logging(\n                level=\"WARNING\",  # Less verbose in production\n                module_levels={\n                    f\"{app_name}.auth\": \"ERROR\",      # Only auth errors\n                    f\"{app_name}.api\": \"WARNING\",     # API warnings\n                    f\"{app_name}.business\": \"INFO\",   # Business events\n                },\n                json_file_name=f\"logs/{app_name}.jsonl\",\n                use_syslog=True,\n                syslog_address=(\"logs.company.com\", 514),\n                **base_config\n            )\n\n# app.py\nfrom app.config import LoggingConfig\nfrom arlogi import get_logger\n\nLoggingConfig.configure(\"myapp\", environment=\"production\")\n\napp_logger = get_logger(\"myapp.app\")\napp_logger.info(\"Web application started\")\n</code></pre>"},{"location":"CONFIGURATION_GUIDE/#cli-application-configuration","title":"CLI Application Configuration","text":"<pre><code># cli/config.py\nimport os\nfrom arlogi import setup_logging\n\ndef setup_cli_logging(verbosity=0, log_file=None):\n    \"\"\"Configure logging for CLI application\"\"\"\n\n    if verbosity &gt;= 2:\n        # Very verbose: DEBUG level with console details\n        setup_logging(\n            level=\"DEBUG\",\n            show_time=True,\n            show_level=True,\n            show_path=True,\n            json_file_name=log_file if log_file else None\n        )\n    elif verbosity &gt;= 1:\n        # Verbose: INFO level with basic console\n        setup_logging(\n            level=\"INFO\",\n            show_time=False,\n            show_level=True,\n            show_path=False,\n            json_file_name=log_file if log_file else None\n        )\n    else:\n        # Quiet: ERROR level only\n        setup_logging(\n            level=\"ERROR\",\n            json_file_name=log_file if log_file else None,\n            json_file_only=not log_file\n        )\n\n# cli/main.py\nimport argparse\nfrom cli.config import setup_cli_logging\nfrom arlogi import get_logger\n\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-v\", \"--verbose\", action=\"count\", default=0)\n    parser.add_argument(\"--log-file\", help=\"Log to file\")\n    args = parser.parse_args()\n\n    setup_cli_logging(args.verbose, args.log_file)\n\n    logger = get_logger(\"cli.main\")\n    logger.info(\"CLI application started\", verbose=args.verbose)\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"CONFIGURATION_GUIDE/#environment-specific-configuration","title":"Environment-Specific Configuration","text":""},{"location":"CONFIGURATION_GUIDE/#development-environment","title":"Development Environment","text":"<pre><code>from arlogi import LoggingConfig, LoggerFactory\n\ndef configure_development():\n    \"\"\"Development: maximum verbosity for debugging\"\"\"\n    config = LoggingConfig(\n        level=\"DEBUG\",\n        module_levels={\"app.*\": \"TRACE\"},\n        show_time=True\n    )\n    LoggerFactory._apply_configuration(config)\n</code></pre>"},{"location":"CONFIGURATION_GUIDE/#testing-environment","title":"Testing Environment","text":"<pre><code>from arlogi import LoggingConfig, LoggerFactory\n\ndef configure_testing():\n    \"\"\"Testing: structured logs for automated analysis\"\"\"\n    config = LoggingConfig(\n        level=\"INFO\",\n        json_file_name=\"logs/tests.jsonl\",\n        json_file_only=True\n    )\n    LoggerFactory._apply_configuration(config)\n</code></pre>"},{"location":"CONFIGURATION_GUIDE/#staging-environment","title":"Staging Environment","text":"<pre><code>from arlogi import setup_logging\n\ndef configure_staging():\n    \"\"\"Staging: production-like with extra debugging\"\"\"\n    setup_logging(\n        level=\"INFO\",\n        module_levels={\n            \"app.auth\": \"DEBUG\",      # Debug authentication\n            \"app.payments\": \"DEBUG\",  # Debug payments\n            \"app.api\": \"INFO\"\n        },\n        json_file_name=\"logs/staging.jsonl\",\n        use_syslog=True,\n        syslog_address=(\"staging-logs.company.com\", 514),\n        show_time=False,\n        show_level=True,\n        show_path=False\n    )\n</code></pre>"},{"location":"CONFIGURATION_GUIDE/#production-environment","title":"Production Environment","text":"<pre><code>from arlogi import LoggingConfig, LoggerFactory\n\ndef configure_production():\n    \"\"\"Production: essential logging only\"\"\"\n    config = LoggingConfig(\n        level=\"WARNING\",\n        module_levels={\n            \"app.auth\": \"ERROR\",\n            \"app.business\": \"INFO\",\n        },\n        json_file_name=\"logs/production.jsonl\",\n        use_syslog=True\n    )\n    LoggerFactory._apply_configuration(config)\n</code></pre>"},{"location":"CONFIGURATION_GUIDE/#dynamic-configuration","title":"Dynamic Configuration","text":""},{"location":"CONFIGURATION_GUIDE/#runtime-level-adjustment","title":"Runtime Level Adjustment","text":"<pre><code>from arlogi import get_logger\n\n# Get logger and adjust level at runtime\nlogger = get_logger(\"app.module\")\n\n# Check current level\nprint(f\"Current level: {logger.level}\")\n\n# Adjust level dynamically\nlogger.setLevel(\"DEBUG\")\nlogger.info(\"Level changed to DEBUG\")\n\n# Or use numeric levels\nimport logging\nlogger.setLevel(logging.INFO)\nlogger.info(\"Level changed to INFO\")\n</code></pre>"},{"location":"CONFIGURATION_GUIDE/#configuration-from-environment-variables","title":"Configuration from Environment Variables","text":"<pre><code>import os\nfrom arlogi import setup_logging\n\ndef configure_from_env():\n    \"\"\"Configure logging from environment variables\"\"\"\n\n    # Basic configuration\n    level = os.getenv(\"LOG_LEVEL\", \"INFO\")\n    json_file = os.getenv(\"LOG_FILE\", None)\n    syslog_enabled = os.getenv(\"LOG_SYSLOG\", \"false\").lower() == \"true\"\n\n    config = {\n        \"level\": level,\n        \"json_file_name\": json_file,\n        \"use_syslog\": syslog_enabled\n    }\n\n    # Console formatting from environment\n    if os.getenv(\"LOG_SHOW_TIME\", \"false\").lower() == \"true\":\n        config[\"show_time\"] = True\n\n    if os.getenv(\"LOG_SHOW_PATH\", \"true\").lower() == \"false\":\n        config[\"show_path\"] = False\n\n    # Module levels from environment (comma-separated)\n    module_levels_str = os.getenv(\"LOG_MODULE_LEVELS\", \"\")\n    if module_levels_str:\n        module_levels = {}\n        for item in module_levels_str.split(\",\"):\n            if \":\" in item:\n                module, level = item.strip().split(\":\", 1)\n                module_levels[module.strip()] = level.strip()\n        config[\"module_levels\"] = module_levels\n\n    setup_logging(**config)\n\n# Usage\nconfigure_from_env()\n</code></pre>"},{"location":"CONFIGURATION_GUIDE/#configuration-file-support","title":"Configuration File Support","text":"<pre><code>import json\nimport yaml\nfrom pathlib import Path\nfrom arlogi import setup_logging\n\ndef load_config_from_file(config_path):\n    \"\"\"Load logging configuration from JSON or YAML file\"\"\"\n\n    config_file = Path(config_path)\n\n    if not config_file.exists():\n        raise FileNotFoundError(f\"Config file not found: {config_path}\")\n\n    if config_file.suffix.lower() == '.json':\n        with open(config_file, 'r') as f:\n            config = json.load(f)\n    elif config_file.suffix.lower() in ['.yaml', '.yml']:\n        with open(config_file, 'r') as f:\n            config = yaml.safe_load(f)\n    else:\n        raise ValueError(f\"Unsupported config file format: {config_file.suffix}\")\n\n    setup_logging(**config)\n\n# config.json example:\n# {\n#   \"level\": \"INFO\",\n#   \"module_levels\": {\n#     \"app.database\": \"DEBUG\",\n#     \"app.auth\": \"WARNING\"\n#   },\n#   \"json_file_name\": \"logs/app.jsonl\",\n#   \"show_time\": false,\n#   \"show_level\": true,\n#   \"show_path\": true\n# }\n\n# Usage\nload_config_from_file(\"config/logging.json\")\n</code></pre>"},{"location":"CONFIGURATION_GUIDE/#advanced-handler-configuration","title":"Advanced Handler Configuration","text":""},{"location":"CONFIGURATION_GUIDE/#multiple-json-files","title":"Multiple JSON Files","text":"<pre><code>from arlogi import get_logger\nfrom arlogi.handlers import JSONFileHandler\nimport logging\n\n# Create separate loggers for different purposes\napp_logger = get_logger(\"app\")\nsecurity_logger = get_logger(\"security\")\naudit_logger = get_logger(\"audit\")\n\n# Add separate JSON handlers\nsecurity_handler = JSONFileHandler(\"logs/security.jsonl\")\naudit_handler = JSONFileHandler(\"logs/audit.jsonl\")\n\nsecurity_logger.addHandler(security_handler)\nsecurity_logger.setLevel(logging.WARNING)\n\naudit_logger.addHandler(audit_handler)\naudit_logger.setLevel(logging.INFO)\n\n# Usage\napp_logger.info(\"Application message\")          # Goes to console/default\nsecurity_logger.warning(\"Security event\")      # Goes to security.jsonl\naudit_logger.info(\"Audit trail entry\")         # Goes to audit.jsonl\n</code></pre>"},{"location":"CONFIGURATION_GUIDE/#custom-formatters","title":"Custom Formatters","text":"<pre><code>import logging\nfrom arlogi.handlers import ColoredConsoleHandler\n\n# Create custom console handler\nhandler = ColoredConsoleHandler(\n    show_time=True,\n    show_level=True,\n    show_path=True,\n    level_styles={\n        \"TRACE\": \"dim blue\",\n        \"DEBUG\": \"dim cyan\",\n        \"INFO\": \"green\",\n        \"WARNING\": \"yellow\",\n        \"ERROR\": \"red\",\n        \"CRITICAL\": \"bold red\"\n    }\n)\n\n# Add to specific logger\nlogger = get_logger(\"custom\")\nlogger.addHandler(handler)\nlogger.setLevel(logging.DEBUG)\n\nlogger.info(\"Custom formatted message\")\n</code></pre>"},{"location":"CONFIGURATION_GUIDE/#filtering-logs","title":"Filtering Logs","text":"<pre><code>import logging\n\nclass BusinessEventFilter(logging.Filter):\n    \"\"\"Filter to only allow business event logs\"\"\"\n\n    def filter(self, record):\n        return hasattr(record, 'event_type')\n\n# Create logger with filter\nlogger = get_logger(\"business\")\nbusiness_filter = BusinessEventFilter()\n\n# Add filter to all handlers\nfor handler in logger.handlers:\n    handler.addFilter(business_filter)\n\n# These will be logged\nlogger.info(\"User registered\", event_type=\"user_signup\")\nlogger.info(\"Order placed\", event_type=\"order_created\")\n\n# These will be filtered out\nlogger.info(\"Debug message\")\nlogger.debug(\"Technical details\")\n</code></pre>"},{"location":"CONFIGURATION_GUIDE/#configuration-validation","title":"Configuration Validation","text":""},{"location":"CONFIGURATION_GUIDE/#validate-configuration","title":"Validate Configuration","text":"<pre><code>from arlogi import setup_logging, get_logger\nimport logging\n\ndef validate_logging_config():\n    \"\"\"Validate and test logging configuration\"\"\"\n\n    try:\n        # Test basic logging\n        logger = get_logger(\"validation\")\n        logger.info(\"Configuration validation started\")\n\n        # Test all log levels\n        logger.trace(\"TRACE level test\")\n        logger.debug(\"DEBUG level test\")\n        logger.info(\"INFO level test\")\n        logger.warning(\"WARNING level test\")\n        logger.error(\"ERROR level test\")\n\n        # Test caller attribution\n        logger.info(\"Caller attribution test\", from_=0)\n\n        # Test structured logging\n        logger.info(\"Structured data test\", key=\"value\", number=42)\n\n        # Test exception logging\n        try:\n            raise ValueError(\"Test exception\")\n        except ValueError:\n            logger.exception(\"Exception test\")\n\n        print(\"\u2705 Logging configuration validated successfully\")\n        return True\n\n    except Exception as e:\n        print(f\"\u274c Logging configuration validation failed: {e}\")\n        return False\n\n# Usage\nif validate_logging_config():\n    print(\"Ready to start application\")\nelse:\n    print(\"Fix logging configuration before starting\")\n</code></pre>"},{"location":"CONFIGURATION_GUIDE/#performance-optimization","title":"Performance Optimization","text":""},{"location":"CONFIGURATION_GUIDE/#high-performance-configuration","title":"High-Performance Configuration","text":"<pre><code>from arlogi import setup_logging\n\ndef configure_high_performance():\n    \"\"\"Optimize for high-performance applications\"\"\"\n\n    setup_logging(\n        level=\"WARNING\",  # Minimal logging\n        json_file_name=\"logs/perf.jsonl\",\n        show_time=False,  # Fast console output\n        show_level=False,\n        show_path=False\n    )\n\ndef configure_balanced():\n    \"\"\"Balance between performance and observability\"\"\"\n\n    setup_logging(\n        level=\"INFO\",\n        module_levels={\n            \"app.critical\": \"DEBUG\",  # Only critical modules verbose\n        },\n        json_file_name=\"logs/balanced.jsonl\",\n        show_time=False,  # Faster console\n        show_level=True,\n        show_path=False\n    )\n</code></pre>"},{"location":"CONFIGURATION_GUIDE/#conditional-logging","title":"Conditional Logging","text":"<pre><code>import os\nfrom arlogi import setup_logging\n\nDEBUG_MODE = os.getenv(\"DEBUG\", \"false\").lower() == \"true\"\n\nif DEBUG_MODE:\n    # Development configuration\n    setup_logging(\n        level=\"DEBUG\",\n        show_time=True,\n        show_path=True\n    )\nelse:\n    # Production configuration\n    setup_logging(\n        level=\"INFO\",\n        json_file_name=\"logs/production.jsonl\"\n    )\n\n# Usage in code\nfrom arlogi import get_logger\n\nlogger = get_logger(\"performance\")\n\ndef expensive_operation():\n    if DEBUG_MODE:\n        logger.debug(\"Starting expensive operation\", from_=1,\n                    debug_data=get_debug_info())\n\n    # Expensive operation here\n    result = perform_calculation()\n\n    if DEBUG_MODE:\n        logger.debug(\"Expensive operation completed\", from_=1,\n                    result=result)\n\n    return result\n</code></pre> <p>This comprehensive configuration guide covers all aspects of setting up arlogi logging for different application types and environments.</p>"},{"location":"DEVELOPER_GUIDE/","title":"Arlogi Developer Guide","text":"<p>This guide is for contributors and maintainers of the arlogi library.</p>"},{"location":"DEVELOPER_GUIDE/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Development Setup</li> <li>Project Structure</li> <li>Testing</li> <li>Code Quality</li> <li>Release Process</li> <li>Contributing</li> </ul>"},{"location":"DEVELOPER_GUIDE/#development-setup","title":"Development Setup","text":""},{"location":"DEVELOPER_GUIDE/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.13 or higher</li> <li>uv package manager</li> <li>Git</li> </ul>"},{"location":"DEVELOPER_GUIDE/#clone-repository","title":"Clone Repository","text":"<pre><code>git clone https://github.com/your-org/arlogi.git\ncd arlogi\n</code></pre>"},{"location":"DEVELOPER_GUIDE/#install-dependencies","title":"Install Dependencies","text":"<pre><code># Install uv if not already installed\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# Create virtual environment and install dependencies\nuv sync\n</code></pre>"},{"location":"DEVELOPER_GUIDE/#development-commands","title":"Development Commands","text":"<pre><code># Run tests\nuv run pytest\n\n# Run tests with coverage\nuv run pytest --cov=src/arlogi --cov-report=html\n\n# Run linter\nuv run ruff check src/arlogi tests\n\n# Format code\nuv run ruff format src/arlogi tests\n\n# Check type hints (if mypy is added)\nuv run mypy src/arlogi\n</code></pre>"},{"location":"DEVELOPER_GUIDE/#project-structure","title":"Project Structure","text":"<pre><code>arlogi/\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 arlogi/\n\u2502       \u251c\u2500\u2500 __init__.py              # Public API exports\n\u2502       \u251c\u2500\u2500 config.py                # LoggingConfig dataclass\n\u2502       \u251c\u2500\u2500 factory.py               # LoggerFactory, TraceLogger\n\u2502       \u251c\u2500\u2500 handler_factory.py       # HandlerFactory\n\u2502       \u251c\u2500\u2500 handlers.py              # Handler implementations\n\u2502       \u251c\u2500\u2500 levels.py                # TRACE level registration\n\u2502       \u2514\u2500\u2500 types.py                 # LoggerProtocol\n\u251c\u2500\u2500 tests/\n\u2502   \u251c\u2500\u2500 test_core.py                 # Core functionality tests\n\u2502   \u251c\u2500\u2500 test_features.py             # Feature tests\n\u2502   \u2514\u2500\u2500 example/\n\u2502       \u2514\u2500\u2500 example.py               # Example usage\n\u251c\u2500\u2500 docs/\n\u2502   \u251c\u2500\u2500 API_REFERENCE.md             # Complete API documentation\n\u2502   \u251c\u2500\u2500 ARCHITECTURE.md              # Architecture diagrams\n\u2502   \u251c\u2500\u2500 USER_GUIDE.md                # User guide\n\u2502   \u2514\u2500\u2500 DEVELOPER_GUIDE.md           # This file\n\u251c\u2500\u2500 pyproject.toml                   # Project configuration\n\u251c\u2500\u2500 ty.toml                          # Type checking configuration\n\u251c\u2500\u2500 .ruff.toml                       # Ruff linter configuration\n\u2514\u2500\u2500 README.md                        # Project README\n</code></pre>"},{"location":"DEVELOPER_GUIDE/#module-responsibilities","title":"Module Responsibilities","text":"Module Responsibility Complexity Target <code>config.py</code> Configuration validation &amp; storage &lt; 5 per method <code>factory.py</code> Logger creation &amp; orchestration &lt; 5 per method <code>handler_factory.py</code> Handler creation &lt; 3 per method <code>handlers.py</code> Output handlers &lt; 10 per method <code>levels.py</code> TRACE level registration N/A (simple) <code>types.py</code> Protocol definitions N/A (declarative)"},{"location":"DEVELOPER_GUIDE/#testing","title":"Testing","text":""},{"location":"DEVELOPER_GUIDE/#running-tests","title":"Running Tests","text":"<pre><code># Run all tests\nuv run pytest\n\n# Run specific test file\nuv run pytest tests/test_core.py\n\n# Run with verbose output\nuv run pytest -v\n\n# Run with coverage\nuv run pytest --cov=src/arlogi --cov-report=term-missing\n</code></pre>"},{"location":"DEVELOPER_GUIDE/#coverage-requirements","title":"Coverage Requirements","text":"Module Target Coverage Status <code>config.py</code> 80% 80% <code>factory.py</code> 80% 75% <code>handler_factory.py</code> 70% 49% <code>handlers.py</code> 60% 36% <code>levels.py</code> 90% 85%"},{"location":"DEVELOPER_GUIDE/#test-categories","title":"Test Categories","text":""},{"location":"DEVELOPER_GUIDE/#unit-tests","title":"Unit Tests","text":"<p>Test individual functions and methods in isolation.</p> <pre><code>def test_logging_config_validation():\n    \"\"\"Test that invalid log levels raise ValueError.\"\"\"\n    with pytest.raises(ValueError):\n        LoggingConfig(level=\"INVALID\")\n\ndef test_direct_config_apply():\n    \"\"\"Test that direct LoggingConfig application works.\"\"\"\n    config = LoggingConfig(level=\"DEBUG\")\n    LoggerFactory._apply_configuration(config)\n    assert logging.getLogger().level == logging.DEBUG\n</code></pre>"},{"location":"DEVELOPER_GUIDE/#integration-tests","title":"Integration Tests","text":"<p>Test interactions between components.</p> <pre><code>def test_setup_with_json_file():\n    \"\"\"Test that setup_logging creates JSON file handler.\"\"\"\n    setup_logging(json_file_name=\"logs/test.jsonl\")\n    root = logging.getLogger()\n    assert any(isinstance(h, JSONFileHandler) for h in root.handlers)\n</code></pre>"},{"location":"DEVELOPER_GUIDE/#feature-tests","title":"Feature Tests","text":"<p>Test end-to-end functionality.</p> <pre><code>def test_caller_attribution():\n    \"\"\"Test that caller attribution shows correct function.\"\"\"\n    logger = get_logger(\"test\")\n    logger.info(\"Test message\", from_=1)\n    # Verify output contains parent function name\n</code></pre>"},{"location":"DEVELOPER_GUIDE/#writing-tests","title":"Writing Tests","text":""},{"location":"DEVELOPER_GUIDE/#test-structure","title":"Test Structure","text":"<pre><code>import pytest\nfrom arlogi import setup_logging, get_logger\n\nclass TestLoggerFactory:\n    \"\"\"Tests for LoggerFactory class.\"\"\"\n\n    def setup_method(self):\n        \"\"\"Reset logging state before each test.\"\"\"\n        # Clear existing handlers\n        root = logging.getLogger()\n        for handler in root.handlers[:]:\n            root.removeHandler(handler)\n\n    def test_get_logger_returns_logger(self):\n        \"\"\"Test that get_logger returns a valid logger.\"\"\"\n        logger = get_logger(\"test\")\n        assert logger is not None\n        assert logger.name == \"test\"\n\n    @pytest.mark.parametrize(\"level\", [\"DEBUG\", \"INFO\", \"WARNING\"])\n    def test_logger_respects_level(self, level):\n        \"\"\"Test that logger respects configured level.\"\"\"\n        setup_logging(level=level)\n        logger = get_logger(\"test\")\n        assert logger.getEffectiveLevel() == getattr(logging, level)\n</code></pre>"},{"location":"DEVELOPER_GUIDE/#test-fixtures","title":"Test Fixtures","text":"<pre><code>@pytest.fixture\ndef temp_log_file(tmp_path):\n    \"\"\"Create a temporary log file path.\"\"\"\n    return tmp_path / \"test.jsonl\"\n\n@pytest.fixture\ndef configured_logger(temp_log_file):\n    \"\"\"Create a logger configured for testing.\"\"\"\n    setup_logging(\n        level=\"DEBUG\",\n        json_file_name=str(temp_log_file)\n    )\n    return get_logger(\"test\")\n</code></pre>"},{"location":"DEVELOPER_GUIDE/#test-mode-detection","title":"Test Mode Detection","text":"<p>Tests should work correctly with arlogi's test mode detection:</p> <pre><code>def test_test_mode_detection():\n    \"\"\"Verify is_test_mode() returns True during pytest.\"\"\"\n    from arlogi import is_test_mode\n    assert is_test_mode() is True\n</code></pre>"},{"location":"DEVELOPER_GUIDE/#code-quality","title":"Code Quality","text":""},{"location":"DEVELOPER_GUIDE/#linting-with-ruff","title":"Linting with Ruff","text":"<pre><code># Check for issues\nuv run ruff check src/arlogi tests\n\n# Auto-fix issues\nuv run ruff check --fix src/arlogi tests\n\n# Format code\nuv run ruff format src/arlogi tests\n</code></pre>"},{"location":"DEVELOPER_GUIDE/#ruff-configuration","title":"Ruff Configuration","text":"<p>Key rules from <code>.ruff.toml</code>:</p> Rule Description Severity C901 Complexity limit (10) Error F401 Unused imports Error F841 Unused variables Error SIM Simplify code Warning"},{"location":"DEVELOPER_GUIDE/#complexity-limits","title":"Complexity Limits","text":"Metric Limit Enforcement Cyclomatic Complexity 10 Ruff C901 Method Length 30 lines Code review Class Length 300 lines Code review Module Length 500 lines Consider splitting"},{"location":"DEVELOPER_GUIDE/#code-style-guidelines","title":"Code Style Guidelines","text":""},{"location":"DEVELOPER_GUIDE/#naming-conventions","title":"Naming Conventions","text":"<pre><code># Classes: PascalCase\nclass LoggingConfig:\n    pass\n\n# Functions/Variables: snake_case\ndef get_logger(name):\n    pass\n\n# Constants: UPPER_SNAKE_CASE\nTRACE_LEVEL_NUM = 5\n\n# Private methods: _leading_underscore\ndef _internal_method(self):\n    pass\n</code></pre>"},{"location":"DEVELOPER_GUIDE/#docstring-format","title":"Docstring Format","text":"<pre><code>def complex_function(arg1, arg2):\n    \"\"\"Brief description of function.\n\n    Longer description if needed.\n\n    Args:\n        arg1: Description of arg1\n        arg2: Description of arg2\n\n    Returns:\n        Description of return value\n\n    Raises:\n        ValueError: If arg1 is invalid\n\n    Examples:\n        &gt;&gt;&gt; complex_function(\"a\", \"b\")\n        \"result\"\n    \"\"\"\n    pass\n</code></pre>"},{"location":"DEVELOPER_GUIDE/#type-hints","title":"Type Hints","text":"<pre><code>from typing import Any, List, Dict, Optional\n\n# Always use type hints for public APIs\ndef process_data(\n    data: Dict[str, Any],\n    options: Optional[Dict[str, Any]] = None\n) -&gt; List[str]:\n    \"\"\"Process data with options.\"\"\"\n    pass\n</code></pre>"},{"location":"DEVELOPER_GUIDE/#pre-commit-hooks","title":"Pre-commit Hooks","text":"<p>Create <code>.git/hooks/pre-commit</code>:</p> <pre><code>#!/bin/bash\nset -e\n\necho \"Running ruff check...\"\nuv run ruff check src/arlogi tests\n\necho \"Running ruff format...\"\nuv run ruff format --check src/arlogi tests\n\necho \"Running tests...\"\nuv run pytest tests/ -q\n\necho \"All checks passed!\"\n</code></pre> <p>Make executable:</p> <pre><code>chmod +x .git/hooks/pre-commit\n</code></pre>"},{"location":"DEVELOPER_GUIDE/#release-process","title":"Release Process","text":""},{"location":"DEVELOPER_GUIDE/#version-management","title":"Version Management","text":"<p>Arlogi uses semantic versioning: <code>MAJOR.MINOR.PATCH</code></p> <ul> <li>MAJOR: Breaking changes</li> <li>MINOR: New features, backward compatible</li> <li>PATCH: Bug fixes, backward compatible</li> </ul>"},{"location":"DEVELOPER_GUIDE/#release-checklist","title":"Release Checklist","text":"<ol> <li>Update Version</li> </ol> <pre><code># Update pyproject.toml\nversion = \"0.513.0\"\n</code></pre> <ol> <li>Update Changelog</li> </ol> <pre><code>## [0.513.0] - 2025-12-28\n\n### Added\n\n- New feature X\n\n### Changed\n\n- Improved Y\n\n### Fixed\n\n- Bug Z\n</code></pre> <ol> <li>Run Full Test Suite</li> </ol> <pre><code>uv run pytest --cov=src/arlogi\n</code></pre> <ol> <li>Create Git Tag</li> </ol> <pre><code>git tag -a v0.513.0 -m \"Release v0.513.0\"\ngit push origin v0.513.0\n</code></pre> <ol> <li>Build Distribution</li> </ol> <pre><code>uv build\n</code></pre> <ol> <li>Publish to PyPI <pre><code>uv publish\n</code></pre></li> </ol>"},{"location":"DEVELOPER_GUIDE/#release-notes-template","title":"Release Notes Template","text":"<pre><code># Release {version}\n\n## Summary\n\n{Brief description of release}\n\n## What's New\n\n- Feature 1\n- Feature 2\n\n## Breaking Changes\n\n- Breaking change 1 (migration guide)\n\n## Bug Fixes\n\n- Bug fix 1\n- Bug fix 2\n\n## Upgrading\n\nSee [MIGRATION.md](docs/MIGRATION.md) for upgrade instructions.\n</code></pre>"},{"location":"DEVELOPER_GUIDE/#contributing","title":"Contributing","text":""},{"location":"DEVELOPER_GUIDE/#contribution-workflow","title":"Contribution Workflow","text":"<ol> <li>Fork Repository</li> </ol> <pre><code># Fork on GitHub, then clone\ngit clone https://github.com/YOUR_USERNAME/arlogi.git\ncd arlogi\ngit remote add upstream https://github.com/original/arlogi.git\n</code></pre> <ol> <li>Create Feature Branch</li> </ol> <pre><code>git checkout -b feature/your-feature-name\n</code></pre> <ol> <li>Make Changes</li> <li>Write code</li> <li>Add tests</li> <li> <p>Update documentation</p> </li> <li> <p>Run Quality Checks</p> </li> </ol> <pre><code>uv run ruff check src/arlogi tests\nuv run pytest tests/\n</code></pre> <ol> <li>Commit Changes</li> </ol> <pre><code>git add .\ngit commit -m \"feat: add new feature\"\n</code></pre> <ol> <li>Push and Create PR <pre><code>git push origin feature/your-feature-name\n# Create PR on GitHub\n</code></pre></li> </ol>"},{"location":"DEVELOPER_GUIDE/#commit-message-format","title":"Commit Message Format","text":"<p>Follow Conventional Commits:</p> <pre><code>&lt;type&gt;(&lt;scope&gt;): &lt;description&gt;\n\n[optional body]\n\n[optional footer]\n</code></pre> <p>Types:</p> <ul> <li><code>feat</code>: New feature</li> <li><code>fix</code>: Bug fix</li> <li><code>docs</code>: Documentation changes</li> <li><code>refactor</code>: Code refactoring</li> <li><code>test</code>: Test changes</li> <li><code>chore</code>: Maintenance tasks</li> </ul> <p>Examples:</p> <pre><code>feat(factory): add LoggingConfig support\n\nBREAKING CHANGE: setup_logging() signature changed\n\nfix(handlers): resolve unused variable warning\n\ndocs(api): update handler examples\n</code></pre>"},{"location":"DEVELOPER_GUIDE/#pull-request-guidelines","title":"Pull Request Guidelines","text":""},{"location":"DEVELOPER_GUIDE/#pr-title","title":"PR Title","text":"<pre><code>feat: add async handler support\n</code></pre>"},{"location":"DEVELOPER_GUIDE/#pr-description-template","title":"PR Description Template","text":"<pre><code>## Summary\n\nBrief description of changes.\n\n## Changes\n\n- Added async handler class\n- Updated tests\n- Updated documentation\n\n## Testing\n\n- Added unit tests for async handler\n- Manual testing with asyncio application\n\n## Checklist\n\n- [ ] Tests pass\n- [ ] No linting errors\n- [ ] Documentation updated\n- [ ] CHANGELOG.md updated\n</code></pre>"},{"location":"DEVELOPER_GUIDE/#code-review-criteria","title":"Code Review Criteria","text":"<p>PRs are reviewed against:</p> <ol> <li>Functionality</li> <li>Does it work as intended?</li> <li> <p>Are edge cases handled?</p> </li> <li> <p>Code Quality</p> </li> <li>Is code readable?</li> <li>Are names descriptive?</li> <li> <p>Is complexity acceptable?</p> </li> <li> <p>Testing</p> </li> <li>Are tests comprehensive?</li> <li> <p>Is coverage adequate?</p> </li> <li> <p>Documentation</p> </li> <li>Are docstrings complete?</li> <li> <p>Is user documentation updated?</p> </li> <li> <p>Backward Compatibility</p> </li> <li>Are breaking changes documented?</li> <li>Is migration path clear?</li> </ol>"},{"location":"DEVELOPER_GUIDE/#architecture-decisions","title":"Architecture Decisions","text":""},{"location":"DEVELOPER_GUIDE/#current-architecture","title":"Current Architecture","text":"<p>Arlogi follows SOLID principles:</p> <ul> <li>S: Each class has single responsibility</li> <li>O: HandlerFactory is extensible</li> <li>L: All handlers are substitutable</li> <li>I: LoggerProtocol is focused</li> <li>D: Depends on abstractions (Protocol)</li> </ul>"},{"location":"DEVELOPER_GUIDE/#decision-records","title":"Decision Records","text":"<p>Significant architectural decisions should be documented:</p> <pre><code># ADR-001: Use Protocol for Logger Interface\n\n## Status\n\nAccepted\n\n## Context\n\nNeed type-safe logger interface that doesn't require inheritance.\n\n## Decision\n\nUse `typing.Protocol` for `LoggerProtocol`.\n\n## Consequences\n\n- Pros: Type safety without inheritance\n- Cons: Requires Python 3.8+\n</code></pre>"},{"location":"DEVELOPER_GUIDE/#performance-guidelines","title":"Performance Guidelines","text":""},{"location":"DEVELOPER_GUIDE/#performance-targets","title":"Performance Targets","text":"Operation Target Notes Log call (no attribution) &lt; 1\u03bcs Standard logging overhead Log call (with attribution) &lt; 5\u03bcs Stack frame inspection Handler emit &lt; 10\u03bcs I/O excluded"},{"location":"DEVELOPER_GUIDE/#profiling","title":"Profiling","text":"<pre><code>import cProfile\nimport pstats\n\ndef profile_logging():\n    pr = cProfile.Profile()\n    pr.enable()\n\n    # Logging code\n    for _ in range(10000):\n        logger.info(\"Test message\")\n\n    pr.disable()\n    stats = pstats.Stats(pr)\n    stats.sort_stats('cumulative')\n    stats.print_stats(10)\n</code></pre>"},{"location":"DEVELOPER_GUIDE/#optimization-checklist","title":"Optimization Checklist","text":"<ul> <li>[ ] Avoid expensive string formatting when disabled</li> <li>[ ] Use lazy evaluation for complex operations</li> <li>[ ] Minimize stack frame inspection depth</li> <li>[ ] Cache repeated operations</li> <li>[ ] Use efficient data structures</li> </ul>"},{"location":"DEVELOPER_GUIDE/#documentation","title":"Documentation","text":""},{"location":"DEVELOPER_GUIDE/#updating-documentation","title":"Updating Documentation","text":"<ol> <li>API Changes: Update <code>API_REFERENCE.md</code></li> <li>New Features: Update <code>USER_GUIDE.md</code></li> <li>Architecture Changes: Update <code>ARCHITECTURE.md</code></li> <li>Examples: Update <code>tests/example/example.py</code></li> </ol>"},{"location":"DEVELOPER_GUIDE/#docstring-standards","title":"Docstring Standards","text":"<p>All public APIs must have docstrings:</p> <pre><code>def public_function(arg1: str) -&gt; bool:\n    \"\"\"Brief description.\n\n    Extended description if needed.\n\n    Args:\n        arg1: Description\n\n    Returns:\n        Description of return\n\n    Raises:\n        ValueError: When arg1 is invalid\n\n    Examples:\n        &gt;&gt;&gt; public_function(\"test\")\n        True\n    \"\"\"\n    pass\n</code></pre>"},{"location":"DEVELOPER_GUIDE/#continuous-integration","title":"Continuous Integration","text":""},{"location":"DEVELOPER_GUIDE/#github-actions-workflow","title":"GitHub Actions Workflow","text":"<pre><code>name: CI\n\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Install uv\n        run: curl -LsSf https://astral.sh/uv/install.sh | sh\n      - name: Install dependencies\n        run: uv sync\n      - name: Run linting\n        run: uv run ruff check src/arlogi tests\n      - name: Run tests\n        run: uv run pytest --cov=src/arlogi\n</code></pre>"},{"location":"DEVELOPER_GUIDE/#getting-help","title":"Getting Help","text":"<ul> <li>Issues: GitHub Issues</li> <li>Discussions: GitHub Discussions</li> <li>Email: maintainers@example.com</li> </ul>"},{"location":"DEVELOPER_GUIDE/#license","title":"License","text":"<p>Contributions are licensed under the MIT License. See LICENSE for details.</p> <p>By contributing, you agree that your contributions will be licensed under the MIT License.</p>"},{"location":"USER_GUIDE/","title":"Arlogi User Guide","text":"<p>Complete user guide for the arlogi logging library. Learn how to install, configure, and use arlogi effectively.</p>"},{"location":"USER_GUIDE/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Installation</li> <li>Quick Start</li> <li>Basic Usage</li> <li>Configuration</li> <li>Caller Attribution</li> <li>Output Handlers</li> <li>Common Patterns</li> <li>Troubleshooting</li> </ul>"},{"location":"USER_GUIDE/#installation","title":"Installation","text":""},{"location":"USER_GUIDE/#requirements","title":"Requirements","text":"<ul> <li>Python 3.13 or higher</li> <li>Optional: <code>rich</code> for enhanced console output</li> </ul>"},{"location":"USER_GUIDE/#using-pip","title":"Using pip","text":"<pre><code>pip install arlogi\n</code></pre>"},{"location":"USER_GUIDE/#using-uv","title":"Using uv","text":"<pre><code>uv add arlogi\n</code></pre>"},{"location":"USER_GUIDE/#from-source","title":"From Source","text":"<pre><code>git clone https://github.com/your-org/arlogi.git\ncd arlogi\npip install -e .\n</code></pre>"},{"location":"USER_GUIDE/#quick-start","title":"Quick Start","text":""},{"location":"USER_GUIDE/#minimal-setup","title":"Minimal Setup","text":"<pre><code>from arlogi import LoggingConfig, LoggerFactory, get_logger\n\n# 1. Configure logging using the modern architecture\nconfig = LoggingConfig(level=\"INFO\")\nLoggerFactory._apply_configuration(config)\n\n# 2. Get a logger\nlogger = get_logger(__name__)\n\n# 3. Log a message\nlogger.info(\"Hello, Arlogi!\")\n</code></pre> <p>Output:</p> <pre><code>I  Hello, Arlogi!    your_module.py:7\n</code></pre>"},{"location":"USER_GUIDE/#basic-usage","title":"Basic Usage","text":""},{"location":"USER_GUIDE/#log-levels","title":"Log Levels","text":"<pre><code>from arlogi import get_logger, TRACE\n\nlogger = get_logger(__name__)\n\n# Ultra-detailed debugging\nlogger.trace(\"Variable value: x = %s\", x, from_=0)\n\n# Detailed information for troubleshooting\nlogger.debug(\"SQL query: %s\", query, from_=1)\n\n# General information about application flow\nlogger.info(\"User logged in successfully\", user_id=123)\n\n# Something unexpected, but application continues\nlogger.warning(\"Configuration file not found, using defaults\")\n\n# Error occurred, application can continue\nlogger.error(\"Failed to connect to database\", database=\"users\")\n\n# Serious error, application may not continue\nlogger.critical(\"Out of memory, shutting down\")\n</code></pre>"},{"location":"USER_GUIDE/#logging-exceptions","title":"Logging Exceptions","text":"<pre><code>from arlogi import get_logger\n\nlogger = get_logger(__name__)\n\ndef process_data(data):\n    try:\n        result = complex_operation(data)\n        return result\n    except Exception as e:\n        # Logs exception with full traceback\n        logger.exception(\"Failed to process data\", data_id=data.get(\"id\"))\n        raise\n</code></pre>"},{"location":"USER_GUIDE/#structured-logging","title":"Structured Logging","text":"<pre><code>from arlogi import get_logger\n\nlogger = get_logger(__name__)\n\n# Add extra fields for structured logging\nlogger.info(\n    \"API request processed\",\n    request_id=\"req-abc-123\",\n    method=\"GET\",\n    path=\"/api/users\",\n    status_code=200,\n    duration_ms=45\n)\n</code></pre>"},{"location":"USER_GUIDE/#configuration","title":"Configuration","text":""},{"location":"USER_GUIDE/#modern-architecture-loggingconfig","title":"Modern Architecture: LoggingConfig","text":"<p>The preferred way to configure <code>arlogi</code> in modern applications is using the <code>LoggingConfig</code> pattern. This approach clearly separates configuration data from initialization logic and provides a type-safe interface.</p> <pre><code>from arlogi import LoggingConfig, LoggerFactory\n\n# 1. Create the configuration object\nconfig = LoggingConfig(\n    level=\"INFO\",\n    module_levels={\"app.db\": \"DEBUG\"},\n    json_file_name=\"logs/app.jsonl\",\n    show_time=True\n)\n\n# 2. Apply it globally\nLoggerFactory._apply_configuration(config)\n</code></pre> <p>[!TIP] This pattern is highly recommended for production applications, especially when configuration is sourced from complex environment logic or external files.</p>"},{"location":"USER_GUIDE/#legacy-helper-setup_logging-deprecated","title":"Legacy Helper: <code>setup_logging()</code> (Deprecated)","text":"<p>[!WARNING] <code>setup_logging()</code> is now considered a legacy helper and is deprecated in favor of the <code>LoggingConfig</code> pattern. It remains available for backward compatibility and simple scripts but may be removed in a future major version.</p> <pre><code>from arlogi import setup_logging\n\nsetup_logging(\n    level=\"INFO\",\n    show_time=True,\n    show_level=True,\n    show_path=True\n)\n</code></pre>"},{"location":"USER_GUIDE/#per-module-levels","title":"Per-Module Levels","text":"<pre><code>from arlogi import LoggingConfig, LoggerFactory\n\nconfig = LoggingConfig(\n    level=\"INFO\",\n    module_levels={\n        \"app.database\": \"DEBUG\",      # Verbose database logging\n        \"app.network\": \"TRACE\",       # Ultra-detailed network logs\n        \"app.security\": \"WARNING\",    # Only security warnings and above\n        \"app.performance\": \"ERROR\"    # Only performance errors\n    }\n)\nLoggerFactory._apply_configuration(config)\n</code></pre>"},{"location":"USER_GUIDE/#json-file-logging","title":"JSON File Logging","text":"<pre><code>from arlogi import LoggingConfig, LoggerFactory\n\n# Console + JSON file\nconfig = LoggingConfig(\n    level=\"INFO\",\n    json_file_name=\"logs/app.jsonl\"\n)\nLoggerFactory._apply_configuration(config)\n</code></pre> <p>JSON Output Format:</p> <pre><code>{\n  \"timestamp\": \"2025-12-28T10:30:00.123456\",\n  \"level\": \"INFO\",\n  \"logger_name\": \"app.main\",\n  \"message\": \"User logged in\",\n  \"module\": \"main\",\n  \"function\": \"login\",\n  \"line_number\": 42\n}\n</code></pre>"},{"location":"USER_GUIDE/#json-only-output","title":"JSON-Only Output","text":"<pre><code>from arlogi import LoggingConfig, LoggerFactory\n\n# JSON output only (no console)\nconfig = LoggingConfig(\n    level=\"INFO\",\n    json_file_only=True\n)\nLoggerFactory._apply_configuration(config)\n</code></pre>"},{"location":"USER_GUIDE/#syslog-integration","title":"Syslog Integration","text":"<pre><code>from arlogi import LoggingConfig, LoggerFactory\n\n# Add syslog to root logger\nconfig = LoggingConfig(\n    level=\"INFO\",\n    use_syslog=True,\n    syslog_address=\"/dev/log\"  # or (\"localhost\", 514)\n)\nLoggerFactory._apply_configuration(config)\n</code></pre>"},{"location":"USER_GUIDE/#complete-configuration","title":"Complete Configuration","text":"<pre><code>from arlogi import LoggingConfig, LoggerFactory\n\nconfig = LoggingConfig(\n    level=\"INFO\",\n    module_levels={\n        \"app.db\": \"DEBUG\",\n        \"app.api\": \"TRACE\"\n    },\n    json_file_name=\"logs/app.jsonl\",\n    use_syslog=True,\n    show_time=True,\n    show_level=True,\n    show_path=True\n)\nLoggerFactory._apply_configuration(config)\n</code></pre>"},{"location":"USER_GUIDE/#caller-attribution","title":"Caller Attribution","text":""},{"location":"USER_GUIDE/#understanding-depth-values","title":"Understanding Depth Values","text":"<p>The <code>from_</code> parameter controls which function is shown in the log:</p> <pre><code>from arlogi import get_logger\n\nlogger = get_logger(__name__)\n\ndef main():\n    logger.info(\"Main entry point\", from_=0)  # Shows: main()\n    process_data()\n\ndef process_data():\n    logger.info(\"Processing\", from_=0)        # Shows: process_data()\n    logger.info(\"Called from main\", from_=1)  # Shows: main()\n    validate()\n\ndef validate():\n    logger.info(\"Validating\", from_=0)        # Shows: validate()\n    logger.info(\"From process\", from_=1)      # Shows: process_data()\n    logger.info(\"From main\", from_=2)         # Shows: main()\n</code></pre>"},{"location":"USER_GUIDE/#cross-module-attribution","title":"Cross-Module Attribution","text":"<pre><code># file: app/utils.py\nfrom arlogi import get_logger\n\nlogger = get_logger(__name__)\n\ndef fetch_user(user_id):\n    logger.info(\"Fetching user\", from_=1)  # Shows caller\n    # ... fetch logic\n    return user\n\n# file: app/main.py\nfrom arlogi import get_logger\nfrom app.utils import fetch_user\n\nlogger = get_logger(__name__)\n\ndef handle_request(user_id):\n    logger.info(\"Request received\", from_=0)\n    user = fetch_user(user_id)  # utils.py shows: handle_request()\n    logger.info(\"Request complete\", from_=0)\n</code></pre>"},{"location":"USER_GUIDE/#best-practices","title":"Best Practices","text":"Use Case Recommended <code>from_</code> Library/Utility code <code>from_=1</code> (show caller) Application code <code>from_=0</code> (show current function) Debugging complex flows <code>from_=2+</code> (show deeper context)"},{"location":"USER_GUIDE/#output-handlers","title":"Output Handlers","text":""},{"location":"USER_GUIDE/#console-handler","title":"Console Handler","text":"<pre><code>from arlogi import get_logger\nfrom arlogi.handlers import ColoredConsoleHandler\n\nlogger = get_logger(__name__)\n\n# Custom colors\nhandler = ColoredConsoleHandler(\n    show_time=True,\n    show_level=True,\n    show_path=True,\n    level_styles={\n        \"info\": \"blue\",\n        \"warning\": \"yellow\",\n        \"error\": \"bold red\"\n    }\n)\n</code></pre> <p>Available Color Options:</p> <ul> <li><code>grey37</code>, <code>grey50</code>, <code>grey75</code></li> <li><code>blue</code>, <code>cyan</code>, <code>green</code>, <code>yellow</code>, <code>red</code></li> <li><code>bold blue</code>, <code>bold red</code>, etc.</li> </ul>"},{"location":"USER_GUIDE/#json-logger","title":"JSON Logger","text":"<pre><code>from arlogi import get_json_logger\n\n# JSON to file\naudit_logger = get_json_logger(\"audit\", \"logs/audit.jsonl\")\naudit_logger.info(\"User action\", extra={\"user_id\": 123})\n\n# JSON to stderr\njson_logger = get_json_logger()\njson_logger.info(\"Structured log\", extra={\"key\": \"value\"})\n</code></pre>"},{"location":"USER_GUIDE/#syslog-logger","title":"Syslog Logger","text":"<pre><code>from arlogi import get_syslog_logger\n\n# Dedicated syslog logger\nsecurity_logger = get_syslog_logger(\"security\")\nsecurity_logger.warning(\"Brute force attempt\", extra={\"ip\": \"192.168.1.1\"})\n</code></pre>"},{"location":"USER_GUIDE/#common-patterns","title":"Common Patterns","text":""},{"location":"USER_GUIDE/#application-startup","title":"Application Startup","text":"<pre><code>from arlogi import LoggingConfig, LoggerFactory, get_logger\n\ndef main():\n    # 1. Configure logging first using modern architecture\n    config = LoggingConfig(\n        level=\"INFO\",\n        module_levels={\n            \"app.database\": \"DEBUG\",\n            \"app.network\": \"TRACE\"\n        },\n        json_file_name=\"logs/app.jsonl\"\n    )\n    LoggerFactory._apply_configuration(config)\n\n    logger = get_logger(\"app.main\")\n    logger.info(\"Application starting up\")\n\n    # Initialize components\n    # init_database()\n    # init_api_server()\n\n    logger.info(\"Application ready\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"USER_GUIDE/#requestresponse-logging","title":"Request/Response Logging","text":"<pre><code>from arlogi import get_logger\nimport time\n\nlogger = get_logger(\"app.api\")\n\ndef handle_request(request):\n    request_id = generate_id()\n    start_time = time.time()\n\n    logger.info(\n        \"Request received\",\n        from_=1,\n        request_id=request_id,\n        method=request.method,\n        path=request.path\n    )\n\n    try:\n        result = process_request(request)\n        duration = (time.time() - start_time) * 1000\n\n        logger.info(\n            \"Request completed\",\n            from_=1,\n            request_id=request_id,\n            status_code=200,\n            duration_ms=round(duration, 2)\n        )\n        return result\n\n    except Exception as e:\n        duration = (time.time() - start_time) * 1000\n\n        logger.exception(\n            \"Request failed\",\n            from_=1,\n            request_id=request_id,\n            error=str(e),\n            duration_ms=round(duration, 2)\n        )\n        raise\n</code></pre>"},{"location":"USER_GUIDE/#database-operation-logging","title":"Database Operation Logging","text":"<pre><code>from arlogi import get_logger\nimport time\n\nlogger = get_logger(\"app.database\")\n\ndef execute_query(query, params=None):\n    start_time = time.time()\n\n    logger.trace(\n        \"Executing query\",\n        from_=1,\n        query=query,\n        params=params\n    )\n\n    try:\n        result = db.execute(query, params)\n        duration = (time.time() - start_time) * 1000\n\n        logger.debug(\n            \"Query executed successfully\",\n            from_=1,\n            query=truncate(query, 100),\n            duration_ms=round(duration, 2),\n            rows_affected=result.rowcount\n        )\n\n        return result\n\n    except Exception as e:\n        duration = (time.time() - start_time) * 1000\n\n        logger.error(\n            \"Query execution failed\",\n            from_=1,\n            query=query,\n            duration_ms=round(duration, 2),\n            error=str(e)\n        )\n        raise\n</code></pre>"},{"location":"USER_GUIDE/#background-task-logging","title":"Background Task Logging","text":"<pre><code>from arlogi import get_logger\nimport asyncio\n\nlogger = get_logger(\"app.tasks\")\n\nasync def process_task(task_id, data):\n    logger.info(\n        \"Task started\",\n        from_=1,\n        task_id=task_id,\n        data_size=len(data)\n    )\n\n    try:\n        # Process the task\n        result = await async_process(data)\n\n        logger.info(\n            \"Task completed\",\n            from_=1,\n            task_id=task_id,\n            result_size=len(result)\n        )\n        return result\n\n    except Exception as e:\n        logger.exception(\n            \"Task failed\",\n            from_=1,\n            task_id=task_id,\n            error=str(e)\n        )\n        raise\n</code></pre>"},{"location":"USER_GUIDE/#troubleshooting","title":"Troubleshooting","text":""},{"location":"USER_GUIDE/#issue-logs-not-appearing","title":"Issue: Logs Not Appearing","text":"<p>Symptoms: No log output in console</p> <p>Solutions:</p> <ol> <li>Check configuration is applied correctly</li> </ol> <pre><code>from arlogi import LoggingConfig, LoggerFactory\nconfig = LoggingConfig(level=\"DEBUG\")  # Show all logs\nLoggerFactory._apply_configuration(config)\n</code></pre> <ol> <li>Verify logger name matches module levels</li> </ol> <pre><code># If module_levels={\"app.db\": \"DEBUG\"}\nlogger = get_logger(\"app.db\")  # Must match exactly\n</code></pre> <ol> <li>Check test mode detection</li> </ol> <pre><code>from arlogi import is_test_mode\nprint(f\"Test mode: {is_test_mode()}\")\n</code></pre>"},{"location":"USER_GUIDE/#issue-duplicate-logs","title":"Issue: Duplicate Logs","text":"<p>Symptoms: Same message appears multiple times</p> <p>Solutions:</p> <ol> <li>Check for multiple configuration calls</li> </ol> <pre><code># Only apply configuration once at startup\nconfig = LoggingConfig(level=\"INFO\")\nLoggerFactory._apply_configuration(config)\n</code></pre> <ol> <li>Check logger propagation</li> </ol> <pre><code>logger = get_logger(\"my_module\")\nlogger.propagate = False  # Disable if needed\n</code></pre>"},{"location":"USER_GUIDE/#issue-caller-attribution-shows-wrong-function","title":"Issue: Caller Attribution Shows Wrong Function","text":"<p>Symptoms: Attribution shows incorrect function name</p> <p>Solutions:</p> <ol> <li>Adjust the <code>from_</code> depth</li> </ol> <pre><code>logger.info(\"Message\", from_=0)  # Current function\nlogger.info(\"Message\", from_=1)  # Caller\nlogger.info(\"Message\", from_=2)  # Caller's caller\n</code></pre> <ol> <li>Check for wrapper functions</li> </ol> <pre><code># If using decorators\n@log_decorator\ndef my_function():\n    pass\n\n# Use from_=2 to skip the decorator\n</code></pre>"},{"location":"USER_GUIDE/#issue-rich-colors-not-working","title":"Issue: Rich Colors Not Working","text":"<p>Symptoms: Console output has no colors</p> <p>Solutions:</p> <ol> <li>Install rich dependency</li> </ol> <pre><code>pip install rich\n</code></pre> <ol> <li>Check terminal supports colors</li> </ol> <pre><code>from rich.console import Console\nconsole = Console()\nconsole.print(\"[bold red]Test colors[/bold red]\")\n</code></pre>"},{"location":"USER_GUIDE/#issue-json-file-not-created","title":"Issue: JSON File Not Created","text":"<p>Symptoms: JSON log file doesn't exist</p> <p>Solutions:</p> <ol> <li>Check directory permissions</li> </ol> <pre><code>mkdir -p logs\nchmod 755 logs\n</code></pre> <ol> <li>Use absolute path</li> </ol> <pre><code>config = LoggingConfig(json_file_name=\"/var/log/myapp/app.jsonl\")\nLoggerFactory._apply_configuration(config)\n</code></pre>"},{"location":"USER_GUIDE/#issue-syslog-not-working","title":"Issue: Syslog Not Working","text":"<p>Symptoms: Syslog messages not appearing</p> <p>Solutions:</p> <ol> <li>Verify syslog address</li> </ol> <pre><code># For Unix socket\nconfig = LoggingConfig(syslog_address=\"/dev/log\", use_syslog=True)\nLoggerFactory._apply_configuration(config)\n\n# For network syslog\nconfig = LoggingConfig(syslog_address=(\"localhost\", 514), use_syslog=True)\nLoggerFactory._apply_configuration(config)\n</code></pre> <ol> <li>Check syslog is running</li> </ol> <pre><code># Linux\nsystemctl status rsyslog\n\n# macOS\nlog show --predicate 'eventMessage contains \"test\"'\n</code></pre>"},{"location":"USER_GUIDE/#advanced-usage","title":"Advanced Usage","text":""},{"location":"USER_GUIDE/#conditional-logging","title":"Conditional Logging","text":"<pre><code>from arlogi import get_logger\n\nlogger = get_logger(__name__)\n\n# Only log if enabled (avoid string formatting overhead)\nif logger.isEnabledFor(logging.DEBUG):\n    logger.debug(\"Expensive debug info: %s\", expensive_operation())\n</code></pre>"},{"location":"USER_GUIDE/#context-managers","title":"Context Managers","text":"<pre><code>from contextlib import contextmanager\nfrom arlogi import get_logger\n\nlogger = get_logger(__name__)\n\n@contextmanager\ndef log_context(operation_name):\n    logger.info(\"Starting: %s\", operation_name, from_=1)\n    start_time = time.time()\n    try:\n        yield\n    finally:\n        duration = time.time() - start_time\n        logger.info(\n            \"Completed: %s\",\n            operation_name,\n            from_=1,\n            duration_ms=round(duration * 1000, 2)\n        )\n\n# Usage\nwith log_context(\"database_migration\"):\n    run_migration()\n</code></pre>"},{"location":"USER_GUIDE/#lazy-log-evaluation","title":"Lazy Log Evaluation","text":"<pre><code>from arlogi import get_logger\n\nlogger = get_logger(__name__)\n\n# Use lambda for expensive operations\nlogger.debug(lambda: expensive_debug_info())\n</code></pre>"},{"location":"USER_GUIDE/#best-practices_1","title":"Best Practices","text":""},{"location":"USER_GUIDE/#do","title":"DO","text":"<ul> <li>Use descriptive log messages</li> <li>Include context (request IDs, user IDs, etc.)</li> <li>Use appropriate log levels</li> <li>Log exceptions with <code>logger.exception()</code></li> <li>Use <code>from_=1</code> in library/utility code</li> </ul>"},{"location":"USER_GUIDE/#dont","title":"DON'T","text":"<ul> <li>Log sensitive data (passwords, tokens, PII)</li> <li>Use <code>print()</code> statements</li> <li>Log at inappropriate levels (ERROR for expected conditions)</li> <li>Create too many loggers (use module hierarchy)</li> <li>Include large objects in log messages</li> </ul>"},{"location":"USER_GUIDE/#performance-tips","title":"Performance Tips","text":"<ol> <li>Use lazy evaluation for expensive operations</li> </ol> <pre><code>logger.debug(lambda: expensive_debug_info())\n</code></pre> <ol> <li>Check log level before complex operations</li> </ol> <pre><code>if logger.isEnabledFor(logging.DEBUG):\n    logger.debug(\"Complex info: %s\", complex_operation())\n</code></pre> <ol> <li>Use structured logging for parsing</li> </ol> <pre><code>logger.info(\"Event\", extra={\"structured\": \"data\"})\n</code></pre> <ol> <li>Avoid excessive string formatting</li> </ol> <pre><code># Good\nlogger.info(\"User %s logged in\", user.name)\n\n# Avoid\nlogger.info(f\"User {user.name} logged in\")  # Formatting happens even if log is disabled\n</code></pre>"},{"location":"USER_GUIDE/#getting-help","title":"Getting Help","text":"<ul> <li>Documentation: Documentation Index</li> <li>Issues: GitHub Issues</li> <li>Discussions: GitHub Discussions</li> </ul>"},{"location":"USER_GUIDE/#license","title":"License","text":"<p>MIT License - see LICENSE file for details.</p>"},{"location":"C4-Documentation/","title":"C4 Architecture Documentation","text":"<p>This directory contains comprehensive C4 architecture documentation for the arlogi Python logging library, following the C4 model created by Simon Brown.</p>"},{"location":"C4-Documentation/#about-the-c4-model","title":"About the C4 Model","text":"<p>The C4 model is a simple way to model software architecture at four levels of detail:</p> <ol> <li>Context - High-level view of the system, its users, and external systems</li> <li>Container - Applications, data stores, micro-services, etc.</li> <li>Component - Logical components within containers</li> <li>Code - Detailed code-level documentation</li> </ol> <p>For more information, visit: https://c4model.com/</p>"},{"location":"C4-Documentation/#documentation-structure","title":"Documentation Structure","text":"<pre><code>C4-Documentation/\n\u251c\u2500\u2500 README.md                          # This file\n\u251c\u2500\u2500 c4-context.md                      # System context (Level 1)\n\u251c\u2500\u2500 c4-container.md                    # Container-level documentation (Level 2)\n\u251c\u2500\u2500 c4-component.md                    # Master component index (Level 3)\n\u251c\u2500\u2500 c4-component-core-logging.md       # Core Logging Library component\n\u251c\u2500\u2500 c4-component-test-suite.md         # Test Suite component\n\u251c\u2500\u2500 c4-component-documentation.md      # Documentation System component\n\u251c\u2500\u2500 c4-code-src-arlogi.md              # Source code documentation (Level 4)\n\u251c\u2500\u2500 c4-code-tests.md                   # Test suite code documentation\n\u251c\u2500\u2500 c4-code-tests-example.md           # Example tests code documentation\n\u251c\u2500\u2500 c4-code-docs-reference.md          # API reference docs structure\n\u251c\u2500\u2500 c4-code-docs-scripts.md            # Documentation build scripts\n\u251c\u2500\u2500 c4-code-subdir.md                  # Subdirectory test module\n\u2514\u2500\u2500 apis/                              # API specifications\n    \u2514\u2500\u2500 arlogi-api.yaml                # OpenAPI 3.1.0 specification\n</code></pre>"},{"location":"C4-Documentation/#quick-navigation","title":"Quick Navigation","text":""},{"location":"C4-Documentation/#start-here","title":"Start Here","text":"<ul> <li>System Context (c4-context.md) - Begin here for a high-level overview of the arlogi system, its users, and its place in the broader software ecosystem.</li> </ul>"},{"location":"C4-Documentation/#architecture-levels","title":"Architecture Levels","text":"<ul> <li>Level 1: System Context - Who uses the system and what external systems it interacts with</li> <li>Level 2: Containers - How the system is deployed (Python package, documentation site, test suite)</li> <li>Level 3: Components - Logical components and their relationships</li> <li>Level 4: Code Documentation - Detailed code-level documentation</li> </ul>"},{"location":"C4-Documentation/#component-documentation","title":"Component Documentation","text":"<ul> <li>Core Logging Library - The main logging functionality</li> <li>Test Suite - Quality assurance and testing infrastructure</li> <li>Documentation System - Documentation generation and deployment</li> </ul>"},{"location":"C4-Documentation/#code-level-documents","title":"Code-Level Documents","text":"<ul> <li>Source Code (src/arlogi) - Core library implementation</li> <li>Test Suite (tests) - Test implementations</li> <li>Example Tests (tests/example) - Example usage</li> <li>Documentation Scripts (docs/scripts) - Build automation</li> <li>API Reference (docs/reference) - Generated documentation</li> <li>Subdir Tests (subdir) - Additional test module</li> </ul>"},{"location":"C4-Documentation/#api-specifications","title":"API Specifications","text":"<ul> <li>OpenAPI Specification (apis/arlogi-api.yaml) - Complete API documentation in OpenAPI 3.1.0 format</li> </ul>"},{"location":"C4-Documentation/#system-overview","title":"System Overview","text":"<p>arlogi is a robust, type-safe logging library for Python that extends the standard logging module with modern features and premium aesthetics.</p>"},{"location":"C4-Documentation/#key-features","title":"Key Features","text":"<ul> <li>Custom TRACE level (level 5) for ultra-detailed debugging</li> <li>Premium colored output using the <code>rich</code> library</li> <li>Structured JSON logging for log aggregation systems</li> <li>Module-specific configuration capabilities</li> <li>Dedicated destination loggers (JSON-only, syslog-only)</li> <li>Caller attribution feature to trace log calls across function boundaries</li> <li>Type safety with LoggerProtocol</li> </ul>"},{"location":"C4-Documentation/#personas","title":"Personas","text":"<p>The system serves the following primary users:</p> <ol> <li>Application Developer - Build applications with production-ready logging</li> <li>Library Developer - Create reusable libraries with caller attribution</li> <li>QA/Testing Engineer - Test applications with automated test mode</li> <li>DevOps Engineer - Manage logs in production environments</li> <li>Documentation User - Access API documentation and user guides</li> <li>Contributor/Maintainer - Contribute to the codebase</li> </ol>"},{"location":"C4-Documentation/#technology-stack","title":"Technology Stack","text":"<ul> <li>Language: Python 3.13+</li> <li>Console Output: Rich 14.2.0+</li> <li>Documentation: MkDocs 1.5+, Material Theme, MkDocstrings</li> <li>Testing: pytest 9.0.2+, pytest-cov 7.0.0+</li> <li>Build System: uv package manager, hatchling</li> </ul>"},{"location":"C4-Documentation/#reading-guide","title":"Reading Guide","text":""},{"location":"C4-Documentation/#for-non-technical-stakeholders","title":"For Non-Technical Stakeholders","text":"<p>Start with the System Context document to understand:</p> <ul> <li>What the system does</li> <li>Who uses it</li> <li>What problems it solves</li> <li>How it fits into the broader ecosystem</li> </ul>"},{"location":"C4-Documentation/#for-developers","title":"For Developers","text":"<ol> <li>Read the System Context for a high-level overview</li> <li>Review the Containers to understand deployment architecture</li> <li>Study the Components to understand logical architecture</li> <li>Dive into Code-Level Documentation for implementation details</li> </ol>"},{"location":"C4-Documentation/#for-architects","title":"For Architects","text":"<p>Focus on:</p> <ul> <li>System Context - System boundaries and external relationships</li> <li>Containers - Deployment architecture and technology choices</li> <li>Components - Component boundaries and interactions</li> </ul>"},{"location":"C4-Documentation/#for-contributors","title":"For Contributors","text":"<p>Start with:</p> <ul> <li>Core Logging Library Component - Understand the main component</li> <li>Source Code Documentation - Detailed implementation</li> <li>Test Suite Component - Testing approach</li> </ul>"},{"location":"C4-Documentation/#diagrams","title":"Diagrams","text":"<p>Each level of documentation includes Mermaid diagrams that visualize:</p> <ul> <li>Context Level - System context diagram showing users and external systems</li> <li>Container Level - Container diagram showing deployment units</li> <li>Component Level - Component diagrams showing logical components and relationships</li> <li>Code Level - Class hierarchy and module dependency diagrams</li> </ul> <p>These diagrams can be rendered in any Mermaid-compatible viewer, including:</p> <ul> <li>GitHub/GitLab markdown rendering</li> <li>MkDocs with Mermaid extension</li> <li>VS Code with Mermaid preview extensions</li> <li>Online Mermaid live editor (https://mermaid.live/)</li> </ul>"},{"location":"C4-Documentation/#contributing","title":"Contributing","text":"<p>When making changes to the arlogi codebase:</p> <ol> <li>Update the relevant code-level documentation</li> <li>Review and update component documentation if needed</li> <li>Check if container or context documentation needs updates</li> <li>Ensure all diagrams remain accurate</li> </ol>"},{"location":"C4-Documentation/#additional-resources","title":"Additional Resources","text":"<ul> <li>Documentation Index - Project overview and getting started guide</li> <li>API Reference - Complete API documentation</li> <li>Developer Guide - Contribution guidelines</li> <li>Configuration Guide - Configuration options</li> <li>Live Documentation - Deployed documentation site</li> </ul>"},{"location":"C4-Documentation/#license","title":"License","text":"<p>This documentation is part of the arlogi project and follows the same license terms.</p> <p>Documentation Version: 1.0 Last Updated: 2025-12-28 C4 Model Version: Based on https://c4model.com/</p>"},{"location":"C4-Documentation/c4-code-docs-reference/","title":"C4 Code Level: API Reference Documentation","text":""},{"location":"C4-Documentation/c4-code-docs-reference/#overview","title":"Overview","text":"<ul> <li>Name: API Reference Documentation Directory</li> <li>Description: Generated API reference documentation for the arlogi logging library</li> <li>Location: <code>/docs/reference/</code></li> <li>Format: Markdown files with MkDocs configuration</li> <li>Purpose: Provides comprehensive auto-generated API documentation for developers using the arlogi library</li> </ul>"},{"location":"C4-Documentation/c4-code-docs-reference/#code-elements","title":"Code Elements","text":""},{"location":"C4-Documentation/c4-code-docs-reference/#generated-documentation-files","title":"Generated Documentation Files","text":"<p>The <code>docs/reference</code> directory contains auto-generated markdown files that reference specific Python modules:</p> <ul> <li><code>config.md</code></li> <li>Description: Documents the <code>arlogi.config</code> module</li> <li>Location: <code>/docs/reference/arlogi/config.md</code></li> <li>Source Reference: <code>/src/arlogi/config.py</code></li> <li> <p>Dependencies: Uses MkDocstrings Python handler</p> </li> <li> <p><code>factory.md</code></p> </li> <li>Description: Documents the <code>arlogi.factory</code> module</li> <li>Location: <code>/docs/reference/arlogi/factory.md</code></li> <li>Source Reference: <code>/src/arlogi/factory.py</code></li> <li> <p>Dependencies: Uses MkDocstrings Python handler</p> </li> <li> <p><code>handler_factory.md</code></p> </li> <li>Description: Documents the <code>arlogi.handler_factory</code> module</li> <li>Location: <code>/docs/reference/arlogi/handler_factory.md</code></li> <li>Source Reference: <code>/src/arlogi/handler_factory.py</code></li> <li> <p>Dependencies: Uses MkDocstrings Python handler</p> </li> <li> <p><code>handlers.md</code></p> </li> <li>Description: Documents the <code>arlogi.handlers</code> module</li> <li>Location: <code>/docs/reference/arlogi/handlers.md</code></li> <li>Source Reference: <code>/src/arlogi/handlers.py</code></li> <li> <p>Dependencies: Uses MkDocstrings Python handler</p> </li> <li> <p><code>levels.md</code></p> </li> <li>Description: Documents the <code>arlogi.levels</code> module</li> <li>Location: <code>/docs/reference/arlogi/levels.md</code></li> <li>Source Reference: <code>/src/arlogi/levels.py</code></li> <li> <p>Dependencies: Uses MkDocstrings Python handler</p> </li> <li> <p><code>types.md</code></p> </li> <li>Description: Documents the <code>arlogi.types</code> module</li> <li>Location: <code>/docs/reference/arlogi/types.md</code></li> <li>Source Reference: <code>/src/arlogi/types.py</code></li> <li>Dependencies: Uses MkDocstrings Python handler</li> </ul>"},{"location":"C4-Documentation/c4-code-docs-reference/#mkdocs-configuration","title":"MkDocs Configuration","text":"<ul> <li>File: <code>/mkdocs.yml</code></li> <li>Description: Main configuration file for the documentation site</li> <li>Purpose: Defines navigation, theme, plugins, and structure for the generated documentation</li> <li>Key Components:</li> <li>Material theme with code copy feature</li> <li>MkDocstrings plugin for automatic Python API documentation</li> <li>Search plugin for navigation</li> <li>PyMdownX extensions for syntax highlighting and Mermaid support</li> </ul>"},{"location":"C4-Documentation/c4-code-docs-reference/#navigation-structure","title":"Navigation Structure","text":"<p>The documentation follows this navigation hierarchy: <pre><code>Reference/\n\u251c\u2500\u2500 Config\n\u251c\u2500\u2500 Factory\n\u251c\u2500\u2500 Handler factory\n\u251c\u2500\u2500 Handlers\n\u251c\u2500\u2500 Levels\n\u2514\u2500\u2500 Types\n</code></pre></p>"},{"location":"C4-Documentation/c4-code-docs-reference/#dependencies","title":"Dependencies","text":""},{"location":"C4-Documentation/c4-code-docs-reference/#source-dependencies","title":"Source Dependencies","text":"<p>All documentation files directly reference corresponding Python source modules in <code>/src/arlogi/</code>: - <code>arlogi.config</code> - Configuration management - <code>arlogi.factory</code> - Logger factory implementations - <code>arlogi.handler_factory</code> - Handler creation utilities - <code>arlogi.handlers</code> - Handler classes - <code>arlogi.levels</code> - Logging levels definitions - <code>arlogi.types</code> - Type definitions and protocols</p>"},{"location":"C4-Documentation/c4-code-docs-reference/#tool-dependencies","title":"Tool Dependencies","text":"<ul> <li>MkDocs: Static site generator for documentation</li> <li>Material Theme: Modern documentation theme</li> <li>MkDocstrings: Plugin for automatic API documentation generation</li> <li>Python: Source language for the documented code</li> <li>PyMdownX: Markdown extensions</li> </ul>"},{"location":"C4-Documentation/c4-code-docs-reference/#configuration-dependencies","title":"Configuration Dependencies","text":"<ul> <li><code>mkdocs.yml</code>: Main configuration file</li> <li><code>docs/extra.css</code>: Custom styling</li> <li><code>docs/index.md</code>: Homepage content</li> <li>Documentation files in other directories (API_REFERENCE.md, USER_GUIDE.md, etc.)</li> </ul>"},{"location":"C4-Documentation/c4-code-docs-reference/#relationships","title":"Relationships","text":""},{"location":"C4-Documentation/c4-code-docs-reference/#source-code-documentation-relationship","title":"Source Code Documentation Relationship","text":"<pre><code>---\ntitle: Documentation Generation Flow\n---\nflowchart LR\n    subgraph Source Code\n        A[arlogi/config.py]\n        B[arlogi/factory.py]\n        C[arlogi/handler_factory.py]\n        D[arlogi/handlers.py]\n        E[arlogi/levels.py]\n        F[arlogi/types.py]\n    end\n\n    subgraph MkDocstrings Plugin\n        G[Python Handler]\n        H[Docstring Parsing]\n        I[Signature Extraction]\n    end\n\n    subgraph Generated Docs\n        J[config.md]\n        K[factory.md]\n        L[handler_factory.md]\n        M[handlers.md]\n        N[levels.md]\n        O[types.md]\n    end\n\n    subgraph MkDocs Site\n        P[Material Theme]\n        Q[Navigation]\n        R[Search]\n    end\n\n    A --&gt; H --&gt; I --&gt; J\n    B --&gt; H --&gt; I --&gt; K\n    C --&gt; H --&gt; I --&gt; L\n    D --&gt; H --&gt; I --&gt; M\n    E --&gt; H --&gt; I --&gt; N\n    F --&gt; H --&gt; I --&gt; O\n\n    J --&gt; Q\n    K --&gt; Q\n    L --&gt; Q\n    M --&gt; Q\n    N --&gt; Q\n    O --&gt; Q\n\n    Q --&gt; P\n    Q --&gt; R</code></pre>"},{"location":"C4-Documentation/c4-code-docs-reference/#documentation-structure-relationship","title":"Documentation Structure Relationship","text":"<pre><code>---\ntitle: Documentation Architecture\n---\nclassDiagram\n    namespace Documentation {\n        class ReferenceDocs {\n            &lt;&lt;directory&gt;&gt;\n            +config.md\n            +factory.md\n            +handler_factory.md\n            +handlers.md\n            +levels.md\n            +types.md\n        }\n\n        class MkDocsConfig {\n            &lt;&lt;configuration&gt;&gt;\n            +site_name\n            +theme\n            +plugins\n            +nav\n        }\n\n        class SourceFiles {\n            &lt;&lt;source&gt;&gt;\n            +config.py\n            +factory.py\n            +handler_factory.py\n            +handlers.py\n            +levels.py\n            +types.py\n        }\n    }\n\n    MkDocsConfig --&gt; ReferenceDocs : generates\n    ReferenceDocs --&gt; SourceFiles : references</code></pre>"},{"location":"C4-Documentation/c4-code-docs-reference/#cross-reference-relationships","title":"Cross-Reference Relationships","text":"<p>The documentation system maintains the following relationships:</p> <ol> <li>Direct References: Each markdown file uses MkDocs inline syntax (<code>::: module.path</code>) to reference Python modules</li> <li>Navigation Integration: MkDocs.yml includes the reference section in the main navigation</li> <li>Theme Integration: Uses Material theme features for consistent styling</li> <li>Plugin Integration: Leverages MkDocstrings for automatic documentation generation</li> <li>Code Integration: Source code changes automatically propagate to documentation through rebuild</li> </ol>"},{"location":"C4-Documentation/c4-code-docs-reference/#integration-points","title":"Integration Points","text":"<ul> <li>API Reference: Complements the detailed API_REFERENCE.md with auto-generated documentation</li> <li>User Guide: Provides technical details for developers implementing the library</li> <li>Developer Guide: Serves as reference for contributors</li> <li>Configuration Guide: Integrates with configuration documentation</li> </ul>"},{"location":"C4-Documentation/c4-code-docs-reference/#notes","title":"Notes","text":"<p>This directory represents the automated documentation generation system for the arlogi library. The documentation is generated using MkDocs with the MkDocstrings plugin, which automatically extracts docstrings and type information from the Python source code. The Material theme provides a modern, readable interface for developers exploring the API.</p> <p>Key features of this documentation system: - Auto-generated from source code docstrings - Type hints and signature information preserved - Searchable through MkDocs search plugin - Integrates with GitHub-style code copying - Supports cross-references and navigation - Follows MkDocs best practices for Python libraries</p> <p>The documentation can be built using <code>mkdocs build</code> and served locally with <code>mkdocs serve</code> for development purposes.</p>"},{"location":"C4-Documentation/c4-code-docs-scripts/","title":"C4 Code Level: docs/scripts","text":""},{"location":"C4-Documentation/c4-code-docs-scripts/#overview","title":"Overview","text":"<ul> <li>Name: Documentation Build Scripts</li> <li>Description: Scripts for building, generating, and publishing documentation for the arlogi library</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/docs/scripts</code></li> <li>Language: Bash, Python</li> <li>Purpose: Automates documentation generation, reference page creation, and deployment of documentation to a remote server</li> </ul>"},{"location":"C4-Documentation/c4-code-docs-scripts/#code-elements","title":"Code Elements","text":""},{"location":"C4-Documentation/c4-code-docs-scripts/#scripts","title":"Scripts","text":""},{"location":"C4-Documentation/c4-code-docs-scripts/#build_pubsh","title":"<code>build_pub.sh</code>","text":"<ul> <li>Description: Bash script for publishing built documentation to a remote server via SSH</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/docs/scripts/build_pub.sh:1-32</code></li> <li>Type: Shell script</li> <li>Purpose: Deploys generated documentation from <code>./site</code> directory to remote web server</li> <li>Dependencies:</li> <li><code>bash</code> shell</li> <li><code>ssh</code> client</li> <li><code>rsync</code> for file synchronization</li> <li>Remote SSH server access</li> <li>Key Variables:</li> <li><code>DOCS_SOURCE</code>: Local source directory (<code>./site</code>)</li> <li><code>REMOTE_USER</code>: SSH username (<code>root</code>)</li> <li><code>REMOTE_HOST</code>: Remote server IP (<code>192.168.168.5</code>)</li> <li><code>REMOTE_PATH</code>: Remote destination path (<code>/opt/c/nginx/html/arlogi</code>)</li> <li><code>SSH_KEY</code>: SSH private key path (<code>$HOME/.ssh/il-ed25519</code>)</li> </ul>"},{"location":"C4-Documentation/c4-code-docs-scripts/#gen_ref_pagespy","title":"<code>gen_ref_pages.py</code>","text":"<ul> <li>Description: Python script for generating API reference documentation from source code</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/docs/scripts/gen_ref_pages.py:1-118</code></li> <li>Type: Python script</li> <li>Purpose: Extracts classes and functions from Python source files and creates MkDocs-compatible markdown files</li> <li>Dependencies:</li> <li><code>python</code> (3.x)</li> <li>Standard library modules: <code>re</code>, <code>sys</code>, <code>pathlib</code></li> <li>Source directory: <code>src/arlogi/</code></li> <li>Output directory: <code>docs/reference/</code></li> </ul>"},{"location":"C4-Documentation/c4-code-docs-scripts/#functions","title":"Functions","text":""},{"location":"C4-Documentation/c4-code-docs-scripts/#extract_classes_and_functionsfilepath-path-tupleliststr-liststr","title":"<code>extract_classes_and_functions(filepath: Path) -&gt; tuple[list[str], list[str]]</code>","text":"<ul> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/docs/scripts/gen_ref_pages.py:12-24</code></li> <li>Description: Extracts class and function names from a given Python file using regex patterns</li> <li>Parameters:</li> <li><code>filepath</code>: Path object pointing to the Python file to analyze</li> <li>Returns: Tuple containing lists of class names and function names</li> <li>Dependencies: <code>pathlib.Path</code>, <code>re</code> module</li> <li>Regex Patterns:</li> <li>Classes: <code>(?:^|\\n)class\\s(\\w+)(?:\\(|:)</code></li> <li>Functions: <code>(?:^|\\n)def\\s(\\w+)\\(</code> (filtered to exclude private functions)</li> </ul>"},{"location":"C4-Documentation/c4-code-docs-scripts/#create_markdownmd_filepath-path-module_path-str-classes-list-functions-list","title":"<code>create_markdown(md_filepath: Path, module_path: str, classes: list, functions: list)</code>","text":"<ul> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/docs/scripts/gen_ref_pages.py:27-48</code></li> <li>Description: Creates a Markdown file containing the API reference for the given Python module</li> <li>Parameters:</li> <li><code>md_filepath</code>: Path where the markdown file should be created</li> <li><code>module_path</code>: Python module path (e.g., <code>arlogi.handlers</code>)</li> <li><code>classes</code>: List of class names found in the module</li> <li><code>functions</code>: List of function names found in the module</li> <li>Returns: Relative path to the created markdown file</li> <li>Dependencies: <code>pathlib.Path</code></li> <li>Generated Content: MkDocs-friendly markdown with autodoc configuration</li> </ul>"},{"location":"C4-Documentation/c4-code-docs-scripts/#create_nav_menu_yamlnav_items-listpath","title":"<code>create_nav_menu_yaml(nav_items: list[Path])</code>","text":"<ul> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/docs/scripts/gen_ref_pages.py:51-83</code></li> <li>Description: Prints a YAML-friendly navigation structure for MkDocs configuration</li> <li>Parameters:</li> <li><code>nav_items</code>: List of Path objects for generated markdown files</li> <li>Returns: None (prints to stdout)</li> <li>Dependencies: <code>pathlib.Path</code></li> <li>Functionality:</li> <li>Creates nested navigation structure</li> <li>Converts underscores to spaces and capitalizes names</li> <li>Generates proper YAML indentation for MkDocs nav section</li> </ul>"},{"location":"C4-Documentation/c4-code-docs-scripts/#main","title":"<code>main()</code>","text":"<ul> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/docs/scripts/gen_ref_pages.py:85-114</code></li> <li>Description: Main function to orchestrate reference documentation generation</li> <li>Parameters: None</li> <li>Returns: None</li> <li>Dependencies:</li> <li><code>sys</code> module for path manipulation</li> <li><code>extract_classes_and_functions()</code></li> <li><code>create_markdown()</code></li> <li><code>create_nav_menu_yaml()</code></li> <li>Workflow:</li> <li>Adds source directory to Python path</li> <li>Recursively searches for Python files in <code>src/</code> directory</li> <li>Skips private modules (those starting with <code>_</code>)</li> <li>Extracts classes and functions from each Python file</li> <li>Generates markdown files for modules with content</li> <li>Creates navigation structure and prints YAML</li> </ul>"},{"location":"C4-Documentation/c4-code-docs-scripts/#dependencies","title":"Dependencies","text":""},{"location":"C4-Documentation/c4-code-docs-scripts/#internal-dependencies","title":"Internal Dependencies","text":"<ul> <li>Source Code: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/</code> - Python modules for which documentation is generated</li> <li>Documentation Structure: <code>/opt/Code/2026/_Libs/arlogi/docs/reference/</code> - Output directory for generated reference pages</li> <li>MkDocs Configuration: Relies on MkDocs for final documentation generation</li> </ul>"},{"location":"C4-Documentation/c4-code-docs-scripts/#external-dependencies","title":"External Dependencies","text":"<ul> <li>Bash Utilities:</li> <li><code>bash</code> - Shell interpreter</li> <li><code>ssh</code> - SSH client for remote connection</li> <li><code>rsync</code> - File synchronization utility</li> <li><code>chmod</code> - File permission utility</li> <li> <p><code>mkdir</code> - Directory creation utility</p> </li> <li> <p>Python Libraries:</p> </li> <li><code>re</code> - Regular expression operations</li> <li><code>sys</code> - System-specific parameters and functions</li> <li> <p><code>pathlib</code> - Object-oriented filesystem paths</p> </li> <li> <p>Infrastructure:</p> </li> <li>SSH key authentication (<code>$HOME/.ssh/il-ed25519</code>)</li> <li>Remote SSH server access</li> <li>Web server deployment environment</li> </ul>"},{"location":"C4-Documentation/c4-code-docs-scripts/#relationships","title":"Relationships","text":""},{"location":"C4-Documentation/c4-code-docs-scripts/#script-workflow-diagram","title":"Script Workflow Diagram","text":"<pre><code>---\ntitle: Documentation Build Workflow\n---\nflowchart TB\n    subgen_ref_pages[gen_ref_pages.py]\n    subbuild_pub[build_pub.sh]\n    submkdocs[mkdocs build]\n\n    subgen_ref_pages --&gt; extract[extract_classes_and_functions]\n    subgen_ref_pages --&gt; create_md[create_markdown]\n    subgen_ref_pages --&gt; create_nav[create_nav_menu_yaml]\n\n    submkdocs --&gt; |Creates| site[/site directory]\n    site --&gt; |Deploys| subbuild_pub\n\n    style gen_ref_pages.py fill:#f9f,stroke:#333,stroke-width:2px\n    style build_pub.sh fill:#ccf,stroke:#333,stroke-width:2px\n    style site fill:#9cf,stroke:#333,stroke-width:2px</code></pre>"},{"location":"C4-Documentation/c4-code-docs-scripts/#file-dependencies","title":"File Dependencies","text":"<pre><code>---\ntitle: File Dependency Graph\n---\nflowchart LR\n    subgen_script[gen_ref_pages.py]\n    subbuild_script[build_pub.sh]\n    subsource[Source Files&lt;br&gt;src/arlogi/*.py]\n    subdocs[Generated Docs&lt;br&gt;docs/reference/*.md]\n    subsite[Site Build&lt;br&gt;site/]\n    subremote[Remote Server&lt;br&gt;192.168.168.5]\n\n    subsource --&gt; gen_script\n    gen_script --&gt; docs\n    docs --&gt; mkdocs[MkDocs Build]\n    mkdocs --&gt; site\n    site --&gt; build_script\n    build_script --&gt; remote\n\n    style gen_script fill:#f9f,stroke:#333\n    style build_script fill:#ccf,stroke:#333\n    style source fill:#9cf,stroke:#333\n    style docs fill:#9cf,stroke:#333\n    style site fill:#f96,stroke:#333\n    style remote fill:#6cf,stroke:#333</code></pre>"},{"location":"C4-Documentation/c4-code-docs-scripts/#function-call-flow","title":"Function Call Flow","text":"<pre><code>---\ntitle: Function Call Hierarchy\n---\nflowchart TB\n    main[main()]\n    extract[extract_classes_and_functions&lt;br/&gt;(filepath: Path)]\n    create_md[create_markdown&lt;br/&gt;(md_filepath, module_path, classes, functions)]\n    create_nav[create_nav_menu_yaml&lt;br/&gt;(nav_items)]\n\n    main --&gt; extract\n    main --&gt; create_md\n    main --&gt; create_nav\n\n    style main fill:#f9f,stroke:#333,stroke-width:2px\n    style extract fill:#ccf,stroke:#333\n    style create_md fill:#ccf,stroke:#333\n    style create_nav fill:#ccf,stroke:#333</code></pre>"},{"location":"C4-Documentation/c4-code-docs-scripts/#notes","title":"Notes","text":"<ul> <li>The <code>build_pub.sh</code> script is designed for deployment to a specific remote server with hardcoded configuration values</li> <li>The <code>gen_ref_pages.py</code> script uses simple regex patterns for code analysis, which may not capture all edge cases but provides good automation for basic API documentation</li> <li>Both scripts are executable and designed to be run from the repository root directory</li> <li>The scripts support automated documentation generation as part of a CI/CD pipeline or manual documentation updates</li> <li>Reference page generation creates MkDocs-autodoc compatible markdown files with proper navigation structure</li> </ul>"},{"location":"C4-Documentation/c4-code-src-arlogi/","title":"C4 Code Level: src/arlogi","text":""},{"location":"C4-Documentation/c4-code-src-arlogi/#overview","title":"Overview","text":"<ul> <li>Name: arlogi Core Library</li> <li>Description: The core logging library implementation providing structured, colored console logging, JSON logging, syslog integration, and caller attribution features</li> <li>Location: <code>/src/arlogi</code></li> <li>Language: Python</li> <li>Purpose: Implements a modern, feature-rich logging library with custom formatters, multiple output targets, and enhanced debugging capabilities</li> </ul>"},{"location":"C4-Documentation/c4-code-src-arlogi/#code-elements","title":"Code Elements","text":""},{"location":"C4-Documentation/c4-code-src-arlogi/#functionsmethods","title":"Functions/Methods","text":""},{"location":"C4-Documentation/c4-code-src-arlogi/#configpy","title":"config.py","text":"<ul> <li><code>LoggingConfig.__post_init__(self) -&gt; None</code></li> <li>Description: Validates configuration after initialization, checking levels and module names</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/config.py:40</code></li> <li> <p>Dependencies: <code>_validate_level</code> method, <code>logging</code> module</p> </li> <li> <p><code>LoggingConfig._validate_level(level: int | str) -&gt; None</code></p> </li> <li>Description: Validates a log level value, raising ValueError for invalid levels</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/config.py:52</code></li> <li> <p>Dependencies: <code>logging</code> module</p> </li> <li> <p><code>LoggingConfig.resolved_level -&gt; int</code></p> </li> <li>Description: Property that returns the global level as an integer</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/config.py:80</code></li> <li> <p>Dependencies: <code>logging</code> module</p> </li> <li> <p><code>LoggingConfig.show_console -&gt; bool</code></p> </li> <li>Description: Property that determines if console output should be shown</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/config.py:91</code></li> <li> <p>Dependencies: None</p> </li> <li> <p><code>LoggingConfig.has_json_output -&gt; bool</code></p> </li> <li>Description: Property that determines if JSON output is configured</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/config.py:100</code></li> <li> <p>Dependencies: None</p> </li> <li> <p><code>LoggingConfig.resolve_module_level(name: str, level: str | int) -&gt; int</code></p> </li> <li>Description: Resolves a module level to an integer</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/config.py:108</code></li> <li> <p>Dependencies: <code>logging</code> module</p> </li> <li> <p><code>LoggingConfig.to_dict() -&gt; dict[str, Any]</code></p> </li> <li>Description: Converts configuration to a dictionary representation</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/config.py:122</code></li> <li> <p>Dependencies: None</p> </li> <li> <p><code>LoggingConfig.from_kwargs(**kwargs: Any) -&gt; \"LoggingConfig\"</code></p> </li> <li>Description: Factory method to create LoggingConfig from keyword arguments</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/config.py:140</code></li> <li> <p>Dependencies: <code>LoggingConfig</code> class constructor</p> </li> <li> <p><code>is_test_mode() -&gt; bool</code></p> </li> <li>Description: Detects if running under a test runner (pytest, unittest)</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/config.py:169</code></li> <li> <p>Dependencies: <code>sys</code> module, <code>os</code> module</p> </li> <li> <p><code>get_default_level() -&gt; int</code></p> </li> <li>Description: Returns DEBUG level in test mode, INFO otherwise</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/config.py:185</code></li> <li>Dependencies: <code>logging</code> module, <code>is_test_mode()</code> function</li> </ul>"},{"location":"C4-Documentation/c4-code-src-arlogi/#factorypy","title":"factory.py","text":"<ul> <li><code>TraceLogger._get_caller_info(depth: int) -&gt; tuple[str, str]</code></li> <li>Description: Finds module and function names at specified stack depth</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/factory.py:27</code></li> <li> <p>Dependencies: <code>sys</code> module</p> </li> <li> <p><code>TraceLogger._process_params(msg: Any, kwargs: dict[str, Any]) -&gt; tuple[Any, dict[str, Any]]</code></p> </li> <li>Description: Processes caller attribution and moves custom kwargs to 'extra'</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/factory.py:52</code></li> <li> <p>Dependencies: <code>rich.markup.escape</code> function</p> </li> <li> <p><code>TraceLogger.trace(msg: Any, *args: Any, **kwargs: Any) -&gt; None</code></p> </li> <li>Description: Logs a message with TRACE level (below DEBUG)</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/factory.py:121</code></li> <li> <p>Dependencies: <code>_process_params</code> method, <code>TRACE_LEVEL_NUM</code></p> </li> <li> <p><code>TraceLogger.debug(msg: Any, *args: Any, **kwargs: Any) -&gt; None</code></p> </li> <li>Description: Logs a debug message with caller attribution support</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/factory.py:133</code></li> <li> <p>Dependencies: <code>_process_params</code> method</p> </li> <li> <p><code>TraceLogger.info(msg: Any, *args: Any, **kwargs: Any) -&gt; None</code></p> </li> <li>Description: Logs an info message with caller attribution support</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/factory.py:138</code></li> <li> <p>Dependencies: <code>_process_params</code> method</p> </li> <li> <p><code>TraceLogger.warning(msg: Any, *args: Any, **kwargs: Any) -&gt; None</code></p> </li> <li>Description: Logs a warning message with caller attribution support</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/factory.py:143</code></li> <li> <p>Dependencies: <code>_process_params</code> method</p> </li> <li> <p><code>TraceLogger.error(msg: Any, *args: Any, **kwargs: Any) -&gt; None</code></p> </li> <li>Description: Logs an error message with caller attribution support</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/factory.py:148</code></li> <li> <p>Dependencies: <code>_process_params</code> method</p> </li> <li> <p><code>TraceLogger.critical(msg: Any, *args: Any, **kwargs: Any) -&gt; None</code></p> </li> <li>Description: Logs a critical message with caller attribution support</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/factory.py:153</code></li> <li> <p>Dependencies: <code>_process_params</code> method</p> </li> <li> <p><code>TraceLogger.exception(msg: Any, *args: Any, **kwargs: Any) -&gt; None</code></p> </li> <li>Description: Logs an exception with traceback and caller attribution</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/factory.py:158</code></li> <li> <p>Dependencies: <code>_process_params</code> method</p> </li> <li> <p><code>TraceLogger.log(level: int, msg: Any, *args: Any, **kwargs: Any) -&gt; None</code></p> </li> <li>Description: Logs a message at specified level with caller attribution</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/factory.py:163</code></li> <li> <p>Dependencies: <code>_process_params</code> method</p> </li> <li> <p><code>LoggerFactory.setup(level: int | str = logging.INFO, **kwargs) -&gt; None</code></p> </li> <li>Description: Centralized logging setup method that configures root logger (Legacy helper, calls _apply_configuration)</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/factory.py:179</code></li> <li> <p>Dependencies: <code>LoggingConfig</code>, <code>_apply_configuration</code> method</p> </li> <li> <p><code>LoggerFactory._apply_configuration(config: LoggingConfig) -&gt; None</code></p> </li> <li>Description: Applies a LoggingConfig to the root logger (Primary configuration method)</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/factory.py:221</code></li> <li> <p>Dependencies: <code>_initialize_trace_level</code>, <code>_configure_root_logger</code>, <code>_clear_and_add_handlers</code>, <code>_configure_module_levels</code></p> </li> <li> <p><code>LoggerFactory._initialize_trace_level() -&gt; None</code></p> </li> <li>Description: Registers custom TRACE level with Python's logging module</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/factory.py:238</code></li> <li> <p>Dependencies: <code>register_trace_level</code>, <code>logging.setLoggerClass</code></p> </li> <li> <p><code>LoggerFactory._configure_root_logger(config: LoggingConfig) -&gt; None</code></p> </li> <li>Description: Configures the root logger level</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/factory.py:244</code></li> <li> <p>Dependencies: <code>logging.getLogger</code>, <code>config.resolved_level</code></p> </li> <li> <p><code>LoggerFactory._clear_and_add_handlers(config: LoggingConfig) -&gt; None</code></p> </li> <li>Description: Clears existing handlers and adds configured ones</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/factory.py:254</code></li> <li> <p>Dependencies: <code>HandlerFactory.create_handlers</code></p> </li> <li> <p><code>LoggerFactory._configure_module_levels(config: LoggingConfig) -&gt; None</code></p> </li> <li>Description: Applies module-specific log level overrides</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/factory.py:272</code></li> <li> <p>Dependencies: <code>config.module_levels</code>, <code>config.resolve_module_level</code></p> </li> <li> <p><code>LoggerFactory.is_test_mode() -&gt; bool</code></p> </li> <li>Description: Detects if running under a test runner (delegates to is_test_mode)</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/factory.py:287</code></li> <li> <p>Dependencies: <code>is_test_mode()</code> function</p> </li> <li> <p><code>LoggerFactory.get_logger(name: str, level: int | str | None = None) -&gt; LoggerProtocol</code></p> </li> <li>Description: Gets a logger instance with caller attribution support</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/factory.py:296</code></li> <li> <p>Dependencies: <code>get_default_level()</code>, <code>logging.getLogger</code></p> </li> <li> <p><code>LoggerFactory.get_json_logger(name: str = \"json\", json_file_name: str | None = None) -&gt; LoggerProtocol</code></p> </li> <li>Description: Gets a dedicated JSON-only logger bypassing root handlers</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/factory.py:318</code></li> <li> <p>Dependencies: <code>JSONFileHandler</code>, <code>JSONHandler</code></p> </li> <li> <p><code>LoggerFactory.get_syslog_logger(name: str = \"syslog\", address: str | tuple[str, int] = \"/dev/log\") -&gt; LoggerProtocol</code></p> </li> <li>Description: Gets a dedicated syslog-only logger bypassing root handlers</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/factory.py:342</code></li> <li> <p>Dependencies: <code>ArlogiSyslogHandler</code></p> </li> <li> <p><code>LoggerFactory.get_global_logger() -&gt; LoggerProtocol</code></p> </li> <li>Description: Gets or initializes the global logger instance</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/factory.py:361</code></li> <li> <p>Dependencies: <code>get_logger()</code> method</p> </li> <li> <p><code>setup_logging(level: int | str = logging.INFO, **kwargs) -&gt; None</code></p> </li> <li>Description: Convenience wrapper around LoggerFactory.setup() (Legacy helper)</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/factory.py:374</code></li> <li> <p>Dependencies: <code>LoggerFactory.setup</code></p> </li> <li> <p><code>get_logger(name: str, level: int | str | None = None) -&gt; LoggerProtocol</code></p> </li> <li>Description: Gets a logger instance with caller attribution support</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/factory.py:413</code></li> <li> <p>Dependencies: <code>LoggerFactory.get_logger</code></p> </li> <li> <p><code>get_json_logger(name: str = \"json\", json_file_name: str | None = None) -&gt; LoggerProtocol</code></p> </li> <li>Description: Gets a dedicated JSON-only logger</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/factory.py:426</code></li> <li> <p>Dependencies: <code>LoggerFactory.get_json_logger</code></p> </li> <li> <p><code>get_syslog_logger(name: str = \"syslog\", address: str | tuple[str, int] = \"/dev/log\") -&gt; LoggerProtocol</code></p> </li> <li>Description: Gets a dedicated syslog-only logger</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/factory.py:441</code></li> <li>Dependencies: <code>LoggerFactory.get_syslog_logger</code></li> </ul>"},{"location":"C4-Documentation/c4-code-src-arlogi/#handler_factorypy","title":"handler_factory.py","text":"<ul> <li><code>HandlerFactory.create_console(config: LoggingConfig) -&gt; ColoredConsoleHandler</code></li> <li>Description: Creates a colored console handler with configuration settings</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/handler_factory.py:26</code></li> <li> <p>Dependencies: <code>ColoredConsoleHandler</code>, <code>config</code> attributes</p> </li> <li> <p><code>HandlerFactory.create_json_stream() -&gt; JSONHandler</code></p> </li> <li>Description: Creates a JSON stream handler (outputs to stderr)</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/handler_factory.py:47</code></li> <li> <p>Dependencies: <code>JSONHandler</code></p> </li> <li> <p><code>HandlerFactory.create_json_file(config: LoggingConfig) -&gt; JSONFileHandler</code></p> </li> <li>Description: Creates a JSON file handler with file path from config</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/handler_factory.py:59</code></li> <li> <p>Dependencies: <code>JSONFileHandler</code>, <code>config.json_file_name</code></p> </li> <li> <p><code>HandlerFactory.create_json_handler(config: LoggingConfig) -&gt; logging.Handler</code></p> </li> <li>Description: Creates appropriate JSON handler based on configuration (file or stream)</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/handler_factory.py:82</code></li> <li> <p>Dependencies: <code>create_json_file</code>, <code>create_json_stream</code></p> </li> <li> <p><code>HandlerFactory.create_syslog(config: LoggingConfig) -&gt; ArlogiSyslogHandler</code></p> </li> <li>Description: Creates a syslog handler with configuration settings</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/handler_factory.py:107</code></li> <li> <p>Dependencies: <code>ArlogiSyslogHandler</code>, <code>config.syslog_address</code></p> </li> <li> <p><code>HandlerFactory.create_handlers(config: LoggingConfig) -&gt; list[logging.Handler]</code></p> </li> <li>Description: Creates all handlers based on configuration (main factory method)</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/handler_factory.py:126</code></li> <li>Dependencies: Individual create methods for each handler type</li> </ul>"},{"location":"C4-Documentation/c4-code-src-arlogi/#handlerspy","title":"handlers.py","text":"<ul> <li><code>ColoredConsoleHandler.__init__(show_time: bool = False, show_level: bool = True, show_path: bool = True, level_styles: dict[str, str] | None = None, project_root: str | None = None, *args: Any, **kwargs: Any)</code></li> <li>Description: Initializes colored console handler with Rich formatting</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/handlers.py:31</code></li> <li> <p>Dependencies: <code>Console</code>, <code>RichHandler</code>, <code>sys</code> module</p> </li> <li> <p><code>ColoredConsoleHandler._find_project_root() -&gt; str</code></p> </li> <li>Description: Finds project root by looking for common indicators (.git, pyproject.toml, etc.)</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/handlers.py:86</code></li> <li> <p>Dependencies: <code>os</code> module</p> </li> <li> <p><code>ColoredConsoleHandler.render(*, record: logging.LogRecord, traceback: Any, message_renderable: Any) -&gt; Any</code></p> </li> <li>Description: Override render method to show relative paths from project root</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/handlers.py:120</code></li> <li> <p>Dependencies: <code>pathlib.Path</code>, <code>os.path.relpath</code></p> </li> <li> <p><code>ColoredConsoleHandler.get_level_text(record: logging.LogRecord) -&gt; Any</code></p> </li> <li>Description: Gets level text as single character with styling</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/handlers.py:164</code></li> <li> <p>Dependencies: <code>Text</code> from rich</p> </li> <li> <p><code>ColoredConsoleHandler.render_message(record: logging.LogRecord, message: str) -&gt; Any</code></p> </li> <li>Description: Renders message text with level-specific styling</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/handlers.py:183</code></li> <li> <p>Dependencies: Super class method, level_styles</p> </li> <li> <p><code>JSONFormatter.format(record: logging.LogRecord) -&gt; str</code></p> </li> <li>Description: Formats log record as JSON with standard fields and extra data</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/handlers.py:210</code></li> <li> <p>Dependencies: <code>json.dumps</code>, <code>datetime</code>, <code>formatException</code></p> </li> <li> <p><code>JSONHandler.__init__(stream: Any = None)</code></p> </li> <li>Description: Initializes JSON stream handler with JSONFormatter</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/handlers.py:254</code></li> <li> <p>Dependencies: <code>JSONFormatter</code>, <code>sys.stderr</code></p> </li> <li> <p><code>JSONFileHandler.__init__(filename: str, mode: str = \"a\", encoding: str | None = None, delay: bool = False)</code></p> </li> <li>Description: Initializes JSON file handler with automatic directory creation</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/handlers.py:270</code></li> <li> <p>Dependencies: <code>os.makedirs</code>, <code>os.path</code>, <code>JSONFormatter</code></p> </li> <li> <p><code>ArlogiSyslogHandler.__init__(address: str | tuple[str, int] = \"/dev/log\", facility: int | str = logging.handlers.SysLogHandler.LOG_USER, socktype: int | None = None)</code></p> </li> <li>Description: Initializes syslog handler with graceful fallback for missing /dev/log</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/handlers.py:303</code></li> <li>Dependencies: <code>logging.handlers.SysLogHandler</code>, graceful fallback logic</li> </ul>"},{"location":"C4-Documentation/c4-code-src-arlogi/#levelspy","title":"levels.py","text":"<ul> <li><code>register_trace_level() -&gt; None</code></li> <li>Description: Registers the custom TRACE level with Python's logging module</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/levels.py:7</code></li> <li>Dependencies: <code>logging</code> module, adds <code>trace</code> method to <code>logging.Logger</code></li> </ul>"},{"location":"C4-Documentation/c4-code-src-arlogi/#typespy","title":"types.py","text":"<ul> <li><code>LoggerProtocol</code> (Protocol class)</li> <li>Description: Runtime checkable protocol defining the interface for arlogi loggers</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/types.py:4</code></li> <li>Dependencies: <code>typing.Protocol</code>, <code>typing.runtime_checkable</code></li> </ul>"},{"location":"C4-Documentation/c4-code-src-arlogi/#classesmodules","title":"Classes/Modules","text":""},{"location":"C4-Documentation/c4-code-src-arlogi/#configpy_1","title":"config.py","text":"<ul> <li><code>LoggingConfig</code></li> <li>Description: Immutable dataclass configuration for logging setup with Builder pattern</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/config.py:14</code></li> <li>Methods: <code>__post_init__</code>, <code>_validate_level</code>, <code>resolved_level</code>, <code>show_console</code>, <code>has_json_output</code>, <code>resolve_module_level</code>, <code>to_dict</code>, <code>from_kwargs</code></li> <li>Dependencies: <code>dataclasses.dataclass</code>, <code>logging</code> module</li> </ul>"},{"location":"C4-Documentation/c4-code-src-arlogi/#factorypy_1","title":"factory.py","text":"<ul> <li><code>TraceLogger</code></li> <li>Description: Custom logger class extending Python's Logger with TRACE level and caller attribution</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/factory.py:18</code></li> <li>Methods: <code>_get_caller_info</code>, <code>_process_params</code>, <code>trace</code>, <code>debug</code>, <code>info</code>, <code>warning</code>, <code>error</code>, <code>critical</code>, <code>exception</code>, <code>log</code></li> <li> <p>Dependencies: <code>logging.Logger</code>, <code>rich.markup.escape</code></p> </li> <li> <p><code>LoggerFactory</code></p> </li> <li>Description: Factory class for creating and configuring logger instances with global state management</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/factory.py:169</code></li> <li>Methods: <code>setup</code>, <code>_apply_configuration</code>, <code>_initialize_trace_level</code>, <code>_configure_root_logger</code>, <code>_clear_and_add_handlers</code>, <code>_configure_module_levels</code>, <code>is_test_mode</code>, <code>get_logger</code>, <code>get_json_logger</code>, <code>get_syslog_logger</code>, <code>get_global_logger</code></li> <li>Dependencies: <code>logging</code> module, <code>HandlerFactory</code>, various handler classes</li> </ul>"},{"location":"C4-Documentation/c4-code-src-arlogi/#handler_factorypy_1","title":"handler_factory.py","text":"<ul> <li><code>HandlerFactory</code></li> <li>Description: Factory class for creating logging handlers with consistent creation logic</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/handler_factory.py:19</code></li> <li>Methods: <code>create_console</code>, <code>create_json_stream</code>, <code>create_json_file</code>, <code>create_json_handler</code>, <code>create_syslog</code>, <code>create_handlers</code></li> <li>Dependencies: <code>logging</code> module, various handler classes, <code>LoggingConfig</code></li> </ul>"},{"location":"C4-Documentation/c4-code-src-arlogi/#handlerspy_1","title":"handlers.py","text":"<ul> <li><code>ColoredConsoleHandler</code></li> <li>Description: Rich-based colored console handler with project root detection and custom formatting</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/handlers.py:21</code></li> <li>Methods: <code>__init__</code>, <code>_find_project_root</code>, <code>render</code>, <code>get_level_text</code>, <code>render_message</code></li> <li> <p>Dependencies: <code>RichHandler</code>, <code>rich.console.Console</code>, <code>rich.logging</code>, <code>rich.text.Text</code></p> </li> <li> <p><code>JSONFormatter</code></p> </li> <li>Description: JSON formatter for structured log output with standard fields and extra data</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/handlers.py:203</code></li> <li>Methods: <code>format</code></li> <li> <p>Dependencies: <code>json</code>, <code>datetime</code>, <code>logging.Formatter</code></p> </li> <li> <p><code>JSONHandler</code></p> </li> <li>Description: Stream handler that outputs log records as JSON to stderr</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/handlers.py:248</code></li> <li>Methods: <code>__init__</code></li> <li> <p>Dependencies: <code>logging.StreamHandler</code>, <code>JSONFormatter</code></p> </li> <li> <p><code>JSONFileHandler</code></p> </li> <li>Description: File handler that outputs log records as JSON to a file with auto directory creation</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/handlers.py:264</code></li> <li>Methods: <code>__init__</code></li> <li> <p>Dependencies: <code>logging.FileHandler</code>, <code>os.makedirs</code>, <code>JSONFormatter</code></p> </li> <li> <p><code>ArlogiSyslogHandler</code></p> </li> <li>Description: Robust syslog handler with standard formatting and automatic fallback to UDP</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/handlers.py:294</code></li> <li>Methods: <code>__init__</code></li> <li>Dependencies: <code>logging.handlers.SysLogHandler</code>, graceful fallback logic</li> </ul>"},{"location":"C4-Documentation/c4-code-src-arlogi/#levelspy_1","title":"levels.py","text":"<ul> <li>Module constants and function for custom TRACE level</li> <li><code>TRACE_LEVEL_NUM = 5</code>: Custom log level below DEBUG</li> <li><code>TRACE_LEVEL_NAME = \"TRACE\"</code>: Name of the custom level</li> <li><code>register_trace_level()</code>: Function to register the level with logging module</li> </ul>"},{"location":"C4-Documentation/c4-code-src-arlogi/#typespy_1","title":"types.py","text":"<ul> <li><code>LoggerProtocol</code></li> <li>Description: Protocol defining the interface for arlogi loggers with caller attribution support</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/src/arlogi/types.py:4</code></li> <li>Methods: Protocol-defined method signatures for logging operations</li> <li>Dependencies: <code>typing.Protocol</code>, <code>typing.runtime_checkable</code></li> </ul>"},{"location":"C4-Documentation/c4-code-src-arlogi/#dependencies","title":"Dependencies","text":""},{"location":"C4-Documentation/c4-code-src-arlogi/#internal-dependencies","title":"Internal Dependencies","text":"<ul> <li>All modules import from each other to form a cohesive logging system</li> <li>Handler factory depends on handler implementations</li> <li>Factory module depends on config, handlers, and handler factory</li> <li>Config module provides configuration data used by all other modules</li> </ul>"},{"location":"C4-Documentation/c4-code-src-arlogi/#external-dependencies","title":"External Dependencies","text":"<ul> <li><code>logging</code> (Python standard library): Core logging functionality</li> <li><code>os</code> (Python standard library): File system operations, environment variables</li> <li><code>sys</code> (Python standard library): System-specific parameters and functions</li> <li><code>dataclasses</code> (Python standard library): Dataclass creation</li> <li><code>json</code> (Python standard library): JSON formatting</li> <li><code>datetime</code> (Python standard library): Date and time handling</li> <li><code>typing</code> (Python standard library): Type hints and protocols</li> <li><code>pathlib</code> (Python standard library): Path handling</li> <li><code>rich.console</code>: Rich console output</li> <li><code>rich.logging</code>: Rich logging integration</li> <li><code>rich.markup</code>: Rich markup escaping</li> <li><code>rich.text</code>: Rich text formatting</li> <li><code>logging.handlers</code>: Syslog handler implementation</li> </ul>"},{"location":"C4-Documentation/c4-code-src-arlogi/#relationships","title":"Relationships","text":"<p>This codebase uses an object-oriented design with several key components:</p>"},{"location":"C4-Documentation/c4-code-src-arlogi/#class-hierarchy-diagram","title":"Class Hierarchy Diagram","text":"<pre><code>---\ntitle: arlogi Class Hierarchy\n---\nclassDiagram\n    namespace core {\n        class LoggerFactory {\n            -_initialized: bool\n            -_global_logger: TraceLogger | None\n            +setup(level, ...)\n            +_apply_configuration(config)\n            +get_logger(name, level)\n            +get_json_logger(name, json_file_name)\n            +get_syslog_logger(name, address)\n            +get_global_logger()\n        }\n        class TraceLogger {\n            +trace(msg, ...)\n            +debug(msg, ...)\n            +info(msg, ...)\n            +warning(msg, ...)\n            +error(msg, ...)\n            +critical(msg, ...)\n            +exception(msg, ...)\n            +log(level, msg, ...)\n        }\n        class LoggingConfig {\n            +level: int | str\n            +module_levels: dict[str, str | int] | None\n            +json_file_name: str | None\n            +json_file_only: bool\n            +use_syslog: bool\n            +syslog_address: str | tuple[str, int]\n            +show_time: bool\n            +show_level: bool\n            +show_path: bool\n            +resolved_level: int\n            +show_console: bool\n            +has_json_output: bool\n            +resolve_module_level(name, level) int\n            +to_dict() dict\n            +from_kwargs(**kwargs) LoggingConfig\n        }\n    }\n\n    namespace handlers {\n        class ColoredConsoleHandler {\n            +__init__(show_time, show_level, show_path, level_styles, project_root)\n            +_find_project_root()\n            +render(record, traceback, message_renderable)\n            +get_level_text(record)\n            +render_message(record, message)\n        }\n        class JSONFormatter {\n            +format(record)\n        }\n        class JSONHandler {\n            +__init__(stream)\n        }\n        class JSONFileHandler {\n            +__init__(filename, mode, encoding, delay)\n        }\n        class ArlogiSyslogHandler {\n            +__init__(address, facility, socktype)\n        }\n    }\n\n    namespace factory {\n        class HandlerFactory {\n            +create_console(config)\n            +create_json_stream()\n            +create_json_file(config)\n            +create_json_handler(config)\n            +create_syslog(config)\n            +create_handlers(config)\n        }\n    }\n\n    namespace protocol {\n        interface LoggerProtocol {\n            &lt;&lt;interface&gt;&gt;\n            +trace(msg, *args, from_caller, from_, **kwargs)\n            +debug(msg, *args, from_caller, from_, **kwargs)\n            +info(msg, *args, from_caller, from_, **kwargs)\n            +warning(msg, *args, from_caller, from_, **kwargs)\n            +error(msg, *args, from_caller, from_, **kwargs)\n            +critical(msg, *args, from_caller, from_, **kwargs)\n            +exception(msg, *args, from_caller, from_, **kwargs)\n            +log(level, msg, *args, from_caller, from_, **kwargs)\n            +setLevel(level)\n            +isEnabledFor(level)\n        }\n    }\n\n    TraceLogger ..&gt; LoggerProtocol : implements\n    TraceLogger ..&gt; LoggingConfig : uses\n    HandlerFactory ..&gt; LoggingConfig : uses\n    HandlerFactory ..&gt; ColoredConsoleHandler : creates\n    HandlerFactory ..&gt; JSONHandler : creates\n    HandlerFactory ..&gt; JSONFileHandler : creates\n    HandlerFactory ..&gt; ArlogiSyslogHandler : creates\n    ColoredConsoleHandler --|&gt; RichHandler : extends\n    JSONHandler --|&gt; StreamHandler : extends\n    JSONFileHandler --|&gt; FileHandler : extends\n    ArlogiSyslogHandler --|&gt; SysLogHandler : extends\n    JSONHandler --&gt; JSONFormatter : uses\n    JSONFileHandler --&gt; JSONFormatter : uses</code></pre>"},{"location":"C4-Documentation/c4-code-src-arlogi/#module-relationships","title":"Module Relationships","text":"<pre><code>---\ntitle: arlogi Module Dependencies\n---\nflowchart TD\n    subgraph Public API\n        __init__[__init__.py]\n        get_logger[get_logger]\n        get_json_logger[get_json_logger]\n        get_syslog_logger[get_syslog_logger]\n        setup_logging[setup_logging]\n    end\n\n    subgraph Core Modules\n        config[config.py]\n        factory[factory.py]\n        handler_factory[handler_factory.py]\n        handlers[handlers.py]\n        levels[levels.py]\n        types[types.py]\n    end\n\n    subgraph External\n        logging[logging]\n        rich[rich]\n        json[json]\n        os\n        sys\n    end\n\n    __init__ --&gt; config\n    __init__ --&gt; factory\n    __init__ --&gt; handler_factory\n    __init__ --&gt; levels\n    __init__ --&gt; types\n\n    get_logger --&gt; factory\n    get_json_logger --&gt; factory\n    get_syslog_logger --&gt; factory\n    setup_logging --&gt; factory\n\n    factory --&gt; config\n    factory --&gt; handler_factory\n    factory --&gt; handlers\n    factory --&gt; levels\n\n    handler_factory --&gt; handlers\n    handler_factory --&gt; config\n\n    handlers --&gt; logging\n    handlers --&gt; rich\n    handlers --&gt; json\n    handlers --&gt; os\n    handlers --&gt; sys\n\n    config --&gt; logging\n    config --&gt; os\n    config --&gt; sys\n\n    levels --&gt; logging\n\n    types --&gt; typing</code></pre>"},{"location":"C4-Documentation/c4-code-src-arlogi/#notes","title":"Notes","text":"<p>This C4 Code-level documentation captures the complete structure of the arlogi Python logging library. The library follows object-oriented principles with:</p> <ol> <li>Factory Pattern: LoggerFactory and HandlerFactory for creating instances</li> <li>Configuration Pattern: Immutable LoggingConfig dataclass with validation</li> <li>Handler Pattern: Multiple specialized handlers (console, JSON, syslog)</li> <li>Strategy Pattern: Different formatting and output strategies</li> <li>Protocol Pattern: LoggerProtocol for type-safe interfaces</li> </ol> <p>Key architectural features include:</p> <ul> <li>Caller attribution with stack inspection</li> <li>Custom TRACE logging level</li> <li>Graceful fallback for syslog on unsupported systems</li> <li>Rich-colored console output with project root detection</li> <li>Structured JSON logging with extra field support</li> <li>Test mode detection and default level adjustment</li> <li>Immutable configuration with validation</li> </ul> <p>All code elements are fully documented with their signatures, locations, and dependencies, forming the foundation for understanding the arlogi library's implementation.</p>"},{"location":"C4-Documentation/c4-code-subdir/","title":"C4 Code Level: subdir","text":""},{"location":"C4-Documentation/c4-code-subdir/#overview","title":"Overview","text":"<ul> <li>Name: Subdirectory Test Module</li> <li>Description: Test directory demonstrating the arlogi library's functionality from a nested subdirectory location</li> <li>Location: <code>/subdir/</code></li> <li>Language: Python</li> <li>Purpose: This directory serves as an example/test location to verify that the arlogi logging library works correctly when imported from subdirectories and demonstrates relative path handling</li> </ul>"},{"location":"C4-Documentation/c4-code-subdir/#code-elements","title":"Code Elements","text":""},{"location":"C4-Documentation/c4-code-subdir/#functionsmethods","title":"Functions/Methods","text":""},{"location":"C4-Documentation/c4-code-subdir/#main-implicit-main-execution","title":"<code>main()</code> (implicit main execution)","text":"<ul> <li>Signature: No explicit function - script-level execution</li> <li>Description: Main execution block that demonstrates the arlogi library functionality</li> <li>Location: <code>subdir/test_nested.py:1-19</code></li> <li>Dependencies: <code>arlogi.setup_logging</code>, <code>arlogi.get_logger</code></li> </ul>"},{"location":"C4-Documentation/c4-code-subdir/#classesmodules","title":"Classes/Modules","text":""},{"location":"C4-Documentation/c4-code-subdir/#test_nestedpy-module","title":"<code>test_nested.py</code> Module","text":"<ul> <li>Description: Test script demonstrating arlogi library usage from a subdirectory</li> <li>Location: <code>subdir/test_nested.py</code></li> <li>Elements:</li> <li>Imports <code>setup_logging</code> and <code>get_logger</code> from arlogi</li> <li>Configures logging with specific settings (INFO level, no timestamps, show level and path)</li> <li>Creates a logger instance with name \"test.subdir\"</li> <li>Logs informational and error messages</li> <li>Dependencies:</li> <li><code>arlogi</code> (main library package)</li> <li><code>arlogi.factory</code> (provides setup_logging and get_logger)</li> </ul>"},{"location":"C4-Documentation/c4-code-subdir/#dependencies","title":"Dependencies","text":""},{"location":"C4-Documentation/c4-code-subdir/#internal-dependencies","title":"Internal Dependencies","text":"<ul> <li>arlogi: Main logging library package</li> <li><code>arlogi.factory</code>: Provides <code>setup_logging</code> and <code>get_logger</code> functions</li> <li><code>arlogi.config</code>: Provides logging configuration classes and utilities</li> </ul>"},{"location":"C4-Documentation/c4-code-subdir/#external-dependencies","title":"External Dependencies","text":"<ul> <li>logging: Python's built-in logging module (likely used by arlogi internally)</li> </ul>"},{"location":"C4-Documentation/c4-code-subdir/#relationships","title":"Relationships","text":"<p>This is a simple test module that demonstrates the arlogi library's functionality. Since this is a procedural script rather than OOP code, we'll use a flowchart to show the execution flow:</p> <pre><code>---\ntitle: Test Execution Flow for subdir/test_nested.py\n---\nflowchart TB\n    subgraph Import\n        A[import arlogi&lt;br&gt;setup_logging&lt;br&gt;get_logger]\n    end\n    subgraph Setup\n        B[setup_logging&lt;br&gt;level=INFO&lt;br&gt;show_time=False&lt;br&gt;show_level=True&lt;br&gt;show_path=True]\n    end\n    subgraph Logger Creation\n        C[logger =&lt;br&gt;get_logger&lt;br&gt;\"test.subdir\"]\n    end\n    subgraph Logging\n        D[logger.info&lt;br&gt;\"Message from subdir\"]\n        E[logger.error&lt;br&gt;\"Error from subdir\"]\n    end\n\n    A --&gt; B\n    B --&gt; C\n    C --&gt; D\n    C --&gt; E</code></pre>"},{"location":"C4-Documentation/c4-code-subdir/#notes","title":"Notes","text":"<ul> <li>This test file serves as validation that the arlogi library works correctly when imported from subdirectories</li> <li>The logger name \"test.subdir\" suggests hierarchical logging naming conventions</li> <li>The configuration demonstrates practical logging setup with path visibility enabled</li> <li>This appears to be part of the test suite for the arlogi library</li> <li>The cache file indicates this test has been run with pytest</li> </ul>"},{"location":"C4-Documentation/c4-code-tests-example/","title":"C4 Code Level: tests/example","text":""},{"location":"C4-Documentation/c4-code-tests-example/#overview","title":"Overview","text":"<ul> <li>Name: Tests Example Directory</li> <li>Description: Example/test implementations demonstrating arlogi logging library usage patterns and features</li> <li>Location: <code>/tests/example</code></li> <li>Language: Python</li> <li>Purpose: Comprehensive demonstration of arlogi library capabilities including module-specific logging levels, dedicated loggers, caller attribution, and cross-module logging patterns</li> </ul>"},{"location":"C4-Documentation/c4-code-tests-example/#code-elements","title":"Code Elements","text":""},{"location":"C4-Documentation/c4-code-tests-example/#functionsmethods","title":"Functions/Methods","text":"<ul> <li><code>main() -&gt; None</code></li> <li>Description: Main entry point demonstrating comprehensive arlogi features including environment-based configuration, module-specific levels, dedicated loggers, and caller attribution</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/tests/example/example.py:8</code></li> <li> <p>Dependencies: <code>os.environ</code>, <code>setup_logging</code>, <code>get_logger</code>, <code>get_json_logger</code>, <code>get_syslog_logger</code>, <code>worker.do_work()</code></p> </li> <li> <p><code>worker_function() -&gt; None</code></p> </li> <li>Description: Nested function demonstrating caller attribution with different depth levels</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/tests/example/example.py:74</code></li> <li> <p>Dependencies: <code>logger</code>, <code>worker.do_work()</code></p> </li> <li> <p><code>do_work(depth: int = 0) -&gt; None</code></p> </li> <li>Description: Worker function demonstrating logging with cross-module caller attribution</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/tests/example/worker.py:5</code></li> <li>Dependencies: <code>logger</code></li> </ul>"},{"location":"C4-Documentation/c4-code-tests-example/#variables","title":"Variables","text":"<ul> <li><code>env_level: str</code></li> <li>Description: Environment variable LOG_LEVEL value, defaults to \"INFO\"</li> <li> <p>Location: <code>/opt/Code/2026/_Libs/arlogi/tests/example/example.py:10</code></p> </li> <li> <p><code>logger: Logger</code></p> </li> <li>Description: Logger instance for \"app.main\" module demonstrating standard logging</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/tests/example/example.py:27</code></li> <li> <p>Dependencies: <code>get_logger(\"app.main\")</code></p> </li> <li> <p><code>net_logger: Logger</code></p> </li> <li>Description: Logger instance for \"app.network\" module with TRACE-level override</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/tests/example/example.py:28</code></li> <li> <p>Dependencies: <code>get_logger(\"app.network\")</code></p> </li> <li> <p><code>db_logger: Logger</code></p> </li> <li>Description: Logger instance for \"app.database\" module with DEBUG-level override</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/tests/example/example.py:29</code></li> <li> <p>Dependencies: <code>get_logger(\"app.database\")</code></p> </li> <li> <p><code>audit_logger: Logger</code></p> </li> <li>Description: Dedicated JSON logger for audit logging with file output</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/tests/example/example.py:64</code></li> <li> <p>Dependencies: <code>get_json_logger(\"audit\")</code></p> </li> <li> <p><code>syslog_logger: Logger</code></p> </li> <li>Description: Dedicated syslog logger for security events</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/tests/example/example.py:68</code></li> <li> <p>Dependencies: <code>get_syslog_logger(\"security\")</code></p> </li> <li> <p><code>logger: Logger</code></p> </li> <li>Description: Worker module logger for \"app.worker\" namespace</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/tests/example/worker.py:3</code></li> <li>Dependencies: <code>get_logger(\"app.worker\")</code></li> </ul>"},{"location":"C4-Documentation/c4-code-tests-example/#dependencies","title":"Dependencies","text":""},{"location":"C4-Documentation/c4-code-tests-example/#internal-dependencies","title":"Internal Dependencies","text":"<ul> <li><code>worker.do_work()</code> - Cross-module worker function calls</li> <li><code>arlogi.setup_logging()</code> - Library setup configuration</li> <li><code>arlogi.get_logger()</code> - Logger creation</li> <li><code>arlogi.get_json_logger()</code> - Dedicated JSON logger creation</li> <li><code>arlogi.get_syslog_logger()</code> - Syslog logger creation</li> </ul>"},{"location":"C4-Documentation/c4-code-tests-example/#external-dependencies","title":"External Dependencies","text":"<ul> <li><code>os</code> - Standard library for environment variable access</li> <li><code>arlogi</code> - Main logging library being demonstrated</li> </ul>"},{"location":"C4-Documentation/c4-code-tests-example/#relationships","title":"Relationships","text":"<p>This directory demonstrates a functional logging system with clear separation of concerns between modules and different logger types.</p>"},{"location":"C4-Documentation/c4-code-tests-example/#module-relationship-diagram","title":"Module Relationship Diagram","text":"<pre><code>---\ntitle: Example Logging System Architecture\n---\nclassDiagram\n    namespace __main__ {\n        class Example {\n            +main() void\n            +worker_function() void\n            -env_level str\n            -logger Logger\n            -net_logger Logger\n            -db_logger Logger\n            -audit_logger Logger\n            -syslog_logger Logger\n        }\n    }\n\n    namespace worker {\n        class Worker {\n            +do_work(depth int) void\n            -logger Logger\n        }\n    }\n\n    namespace arlogi {\n        class LoggingSystem {\n            +setup_logging() void\n            +get_logger() Logger\n            +get_json_logger() Logger\n            +get_syslog_logger() Logger\n        }\n    }\n\n    Example --&gt; LoggingSystem : uses\n    Example --&gt; Worker : calls\n    Worker --&gt; LoggingSystem : uses\n\n    note for Example \"Demonstrates multi-module logging with attribution\"\n    note for Worker \"Shows cross-module caller attribution\"\n    note for LoggingSystem \"arlogi logging library core functions\"</code></pre>"},{"location":"C4-Documentation/c4-code-tests-example/#data-flow-diagram","title":"Data Flow Diagram","text":"<pre><code>---\ntitle: Logging Data Flow\n---\nflowchart LR\n    subgraph Configuration\n        A[Environment Variables]\n        B[setup_logging]\n    end\n\n    subgraph Loggers\n        C[Main Logger]\n        D[Network Logger]\n        E[Database Logger]\n        F[Audit Logger]\n        G[Syslog Logger]\n        H[Worker Logger]\n    end\n\n    subgraph Outputs\n        I[Console]\n        J[JSON File logs/root_test.jsonl]\n        K[JSON File logs/dedicated_test.jsonl]\n        L[Syslog]\n    end\n\n    A --&gt; B\n    B --&gt; C\n    B --&gt; D\n    B --&gt; E\n    B --&gt; H\n    C --&gt; I\n    C --&gt; J\n    D --&gt; I\n    D --&gt; J\n    E --&gt; I\n    E --&gt; J\n    F --&gt; K\n    G --&gt; L\n    H --&gt; J\n    H --&gt; I\n\n    note for B \"Module-specific levels configured&lt;br/&gt;app.network: TRACE&lt;br/&gt;app.database: DEBUG\"\n    note for H \"Cross-module attribution support\"</code></pre>"},{"location":"C4-Documentation/c4-code-tests-example/#notes","title":"Notes","text":"<p>The example directory serves as a comprehensive demonstration of arlogi's core features: - Environment-based log level configuration - Module-specific log level overrides - Multiple logger types (standard, JSON-only, syslog) - Caller attribution with depth control (<code>from_</code> parameter) - Cross-module logging attribution support - Clean formatting with optional time/path display</p> <p>The structure shows how logging can be organized across modules while maintaining proper attribution and separation of concerns in a multi-module application.</p>"},{"location":"C4-Documentation/c4-code-tests/","title":"C4 Code Level: tests","text":""},{"location":"C4-Documentation/c4-code-tests/#overview","title":"Overview","text":"<ul> <li>Name: Arlogi Test Suite</li> <li>Description: Comprehensive test suite for the arlogi logging library, covering core functionality, features, and integration examples</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/tests</code></li> <li>Language: Python</li> <li>Purpose: Validate the correctness, reliability, and feature completeness of the arlogi logging library through unit tests and integration examples</li> </ul>"},{"location":"C4-Documentation/c4-code-tests/#code-elements","title":"Code Elements","text":""},{"location":"C4-Documentation/c4-code-tests/#test-functions-in-test_corepy","title":"Test Functions in test_core.py","text":""},{"location":"C4-Documentation/c4-code-tests/#test_trace_level_registered","title":"<code>test_trace_level_registered()</code>","text":"<ul> <li>Signature: <code>test_trace_level_registered() -&gt; None</code></li> <li>Description: Validates that the TRACE log level is properly registered in the logging system</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/tests/test_core.py:6</code></li> <li>Dependencies: <code>arlogi.TRACE</code>, <code>arlogi.get_logger</code>, <code>logging.getLevelName</code></li> </ul>"},{"location":"C4-Documentation/c4-code-tests/#test_protocol_compliance","title":"<code>test_protocol_compliance()</code>","text":"<ul> <li>Signature: <code>test_protocol_compliance() -&gt; None</code></li> <li>Description: Ensures that logger instances properly implement the LoggerProtocol interface</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/tests/test_core.py:11</code></li> <li>Dependencies: <code>arlogi.LoggerProtocol</code>, <code>arlogi.get_logger</code>, <code>isinstance()</code></li> </ul>"},{"location":"C4-Documentation/c4-code-tests/#test_test_mode_detection","title":"<code>test_test_mode_detection()</code>","text":"<ul> <li>Signature: <code>test_test_mode_detection() -&gt; None</code></li> <li>Description: Verifies that the LoggerFactory correctly detects test mode and returns appropriate behavior</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/tests/test_core.py:15</code></li> <li>Dependencies: <code>arlogi.factory.LoggerFactory.is_test_mode()</code></li> </ul>"},{"location":"C4-Documentation/c4-code-tests/#test_logging_callscaplog","title":"<code>test_logging_calls(caplog)</code>","text":"<ul> <li>Signature: <code>test_logging_calls(caplog: Any) -&gt; None</code></li> <li>Description: Tests that all logging levels (TRACE, DEBUG, INFO) work correctly when called on a logger instance</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/tests/test_core.py:19</code></li> <li>Dependencies: <code>caplog</code> (pytest fixture), <code>arlogi.TRACE</code>, <code>arlogi.get_logger</code></li> </ul>"},{"location":"C4-Documentation/c4-code-tests/#test-functions-in-test_featurespy","title":"Test Functions in test_features.py","text":""},{"location":"C4-Documentation/c4-code-tests/#test_module_specific_levels","title":"<code>test_module_specific_levels()</code>","text":"<ul> <li>Signature: <code>test_module_specific_levels() -&gt; None</code></li> <li>Description: Validates module-specific log level configuration works as expected</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/tests/test_features.py:7</code></li> <li>Dependencies: <code>arlogi.setup_logging()</code>, <code>arlogi.get_logger</code>, <code>logging.INFO</code>, <code>logging.DEBUG</code></li> </ul>"},{"location":"C4-Documentation/c4-code-tests/#test_json_loggercapsys","title":"<code>test_json_logger(capsys)</code>","text":"<ul> <li>Signature: <code>test_json_logger(capsys: Any) -&gt; None</code></li> <li>Description: Tests the dedicated JSON logger functionality and its output format</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/tests/test_features.py:27</code></li> <li>Dependencies: <code>capsys</code> (pytest fixture), <code>arlogi.get_json_logger()</code>, <code>json.loads</code></li> </ul>"},{"location":"C4-Documentation/c4-code-tests/#test_trace_stacklevelcaplog","title":"<code>test_trace_stacklevel(caplog)</code>","text":"<ul> <li>Signature: <code>test_trace_stacklevel(caplog: Any) -&gt; None</code></li> <li>Description: Validates that stacklevel functionality works correctly for the TRACE level</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/tests/test_features.py:46</code></li> <li>Dependencies: <code>caplog</code> (pytest fixture), <code>arlogi.TRACE</code>, <code>arlogi.get_logger</code></li> </ul>"},{"location":"C4-Documentation/c4-code-tests/#test_caller_attributioncaplog","title":"<code>test_caller_attribution(caplog)</code>","text":"<ul> <li>Signature: <code>test_caller_attribution(caplog: Any) -&gt; None</code></li> <li>Description: Tests the caller attribution feature that shows the calling function name in log messages</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/tests/test_features.py:55</code></li> <li>Dependencies: <code>caplog</code> (pytest fixture), <code>arlogi.get_logger</code></li> </ul>"},{"location":"C4-Documentation/c4-code-tests/#integration-examples","title":"Integration Examples","text":""},{"location":"C4-Documentation/c4-code-tests/#main-function-in-testsexampleexamplepy","title":"<code>main()</code> function in tests/example/example.py","text":"<ul> <li>Signature: <code>main() -&gt; None</code></li> <li>Description: Comprehensive integration example demonstrating all major arlogi features including module-specific levels, dedicated loggers, caller attribution, and cross-module logging</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/tests/example/example.py:8</code></li> <li>Dependencies: <code>os.environ</code>, <code>tests.example.worker</code>, <code>arlogi.get_json_logger()</code>, <code>arlogi.get_logger()</code>, <code>arlogi.get_syslog_logger()</code>, <code>arlogi.setup_logging()</code></li> </ul>"},{"location":"C4-Documentation/c4-code-tests/#do_work-function-in-testsexampleworkerpy","title":"<code>do_work()</code> function in tests/example/worker.py","text":"<ul> <li>Signature: <code>do_work(depth: int = 0) -&gt; None</code></li> <li>Description: Example worker function demonstrating cross-module caller attribution functionality</li> <li>Location: <code>/opt/Code/2026/_Libs/arlogi/tests/example/worker.py:5</code></li> <li>Dependencies: <code>arlogi.get_logger()</code>, global logger instance</li> </ul>"},{"location":"C4-Documentation/c4-code-tests/#dependencies","title":"Dependencies","text":""},{"location":"C4-Documentation/c4-code-tests/#internal-dependencies","title":"Internal Dependencies","text":"<ul> <li><code>arlogi</code>: Main library being tested</li> <li><code>arlogi.TRACE</code>: Custom log level constant</li> <li><code>arlogi.LoggerProtocol</code>: Type hint for logger interface</li> <li><code>arlogi.get_logger()</code>: Function to get configured logger instances</li> <li><code>arlogi.get_json_logger()</code>: Function to get JSON-formatted logger</li> <li><code>arlogi.get_syslog_logger()</code>: Function to get syslog logger</li> <li><code>arlogi.setup_logging()</code>: Function to configure logging system</li> <li><code>arlogi.factory.LoggerFactory</code>: Factory class with test mode detection</li> </ul>"},{"location":"C4-Documentation/c4-code-tests/#external-dependencies","title":"External Dependencies","text":"<ul> <li><code>logging</code>: Python standard library logging module</li> <li><code>json</code>: Python standard library JSON handling</li> <li><code>os</code>: Python standard library operating system interface</li> <li><code>pytest</code>: Testing framework</li> <li><code>caplog</code>: Pytest fixture for capturing log output</li> <li><code>capsys</code>: Pytest fixture for capturing stdout/stderr</li> </ul>"},{"location":"C4-Documentation/c4-code-tests/#test-configuration","title":"Test Configuration","text":"<ul> <li>Test Framework: pytest 9.0.2+</li> <li>Coverage: pytest-cov 7.0.0+ (for test coverage reporting)</li> <li>Python Version: 3.13+</li> </ul>"},{"location":"C4-Documentation/c4-code-tests/#relationships","title":"Relationships","text":""},{"location":"C4-Documentation/c4-code-tests/#test-coverage-overview","title":"Test Coverage Overview","text":"<pre><code>---\ntitle: Arlogi Test Suite Coverage\n---\nflowchart TD\n    subgraph Unit Tests\n        TC1[test_trace_level_registered]\n        TC2[test_protocol_compliance]\n        TC3[test_test_mode_detection]\n        TC4[test_logging_calls]\n        TC5[test_module_specific_levels]\n        TC6[test_json_logger]\n        TC7[test_trace_stacklevel]\n        TC8[test_caller_attribution]\n    end\n\n    subgraph Integration Examples\n        IE1[main example]\n        IE2[worker module]\n    end\n\n    subgraph Features Tested\n        FT1[TRACE Level]\n        FT2[Protocol Compliance]\n        FT3[Test Mode Detection]\n        FT4[Logging Calls]\n        FT5[Module-Specific Levels]\n        FT6[JSON Logger]\n        FT7[Stack Level]\n        FT8[Caller Attribution]\n        FT9[Cross-Module Logging]\n        FT10[Dedicated Loggers]\n        FT11[Environment Configuration]\n    end\n\n    TC1 --&gt; FT1\n    TC2 --&gt; FT2\n    TC3 --&gt; FT3\n    TC4 --&gt; FT4\n    TC5 --&gt; FT5\n    TC6 --&gt; FT6\n    TC7 --&gt; FT7\n    TC8 --&gt; FT8\n\n    IE1 --&gt; FT1\n    IE1 --&gt; FT5\n    IE1 --&gt; FT6\n    IE1 --&gt; FT8\n    IE1 --&gt; FT9\n    IE1 --&gt; FT10\n    IE1 --&gt; FT11\n\n    IE2 --&gt; FT8\n    IE2 --&gt; FT9\n\n    style TC1 fill:#e1f5fe\n    style TC2 fill:#e1f5fe\n    style TC3 fill:#e1f5fe\n    style TC4 fill:#e1f5fe\n    style TC5 fill:#e1f5fe\n    style TC6 fill:#e1f5fe\n    style TC7 fill:#e1f5fe\n    style TC8 fill:#e1f5fe\n    style IE1 fill:#f3e5f5\n    style IE2 fill:#f3e5f5\n    style FT1 fill:#e8f5e8\n    style FT2 fill:#e8f5e8\n    style FT3 fill:#e8f5e8\n    style FT4 fill:#e8f5e8\n    style FT5 fill:#e8f5e8\n    style FT6 fill:#e8f5e8\n    style FT7 fill:#e8f5e8\n    style FT8 fill:#e8f5e8\n    style FT9 fill:#e8f5e8\n    style FT10 fill:#e8f5e8\n    style FT11 fill:#e8f5e8</code></pre>"},{"location":"C4-Documentation/c4-code-tests/#test-structure-diagram","title":"Test Structure Diagram","text":"<pre><code>---\ntitle: Arlogi Test File Organization\n---\nclassDiagram\n    namespace tests/\n        class test_core {\n            &lt;&lt;test module&gt;&gt;\n            +test_trace_level_registered() None\n            +test_protocol_compliance() None\n            +test_test_mode_detection() None\n            +test_logging_calls(caplog) None\n        }\n\n        class test_features {\n            &lt;&lt;test module&gt;&gt;\n            +test_module_specific_levels() None\n            +test_json_logger(capsys) None\n            +test_trace_stacklevel(caplog) None\n            +test_caller_attribution(caplog) None\n        }\n\n        namespace example/ {\n            class example {\n                &lt;&lt;example module&gt;&gt;\n                +main() None\n            }\n\n            class worker {\n                &lt;&lt;example module&gt;&gt;\n                logger Logger\n                +do_work(depth int) None\n            }\n        }\n    }\n\n    test_core ..&gt; arlogi : imports\n    test_features ..&gt; arlogi : imports\n    example ..&gt; arlogi : imports\n    worker ..&gt; arlogi : imports\n\n    example --&gt; worker : imports worker\n    worker --&gt; logger : uses global logger</code></pre>"},{"location":"C4-Documentation/c4-code-tests/#key-test-categories","title":"Key Test Categories","text":"<ol> <li>Core Functionality Tests (test_core.py)</li> <li>Basic logger initialization and protocol compliance</li> <li>Test mode detection</li> <li> <p>Logging level verification</p> </li> <li> <p>Feature Implementation Tests (test_features.py)</p> </li> <li>Module-specific level configuration</li> <li>JSON logger functionality</li> <li>Stack level handling</li> <li> <p>Caller attribution features</p> </li> <li> <p>Integration Examples (example/)</p> </li> <li>Comprehensive feature demonstration</li> <li>Cross-module logging scenarios</li> <li>Real-world usage patterns</li> </ol>"},{"location":"C4-Documentation/c4-code-tests/#notes","title":"Notes","text":"<p>The test suite follows pytest conventions and uses fixtures like <code>caplog</code> and <code>capsys</code> for capturing log output and console output. The integration examples in the <code>example/</code> directory serve both as tests and as documentation of how to use various arlogi features in practice. All tests validate the core logging functionality while the examples demonstrate practical usage patterns including environment-based configuration, dedicated loggers, and cross-module caller attribution.</p>"},{"location":"C4-Documentation/c4-component-core-logging/","title":"C4 Component Level: Core Logging Library","text":""},{"location":"C4-Documentation/c4-component-core-logging/#overview","title":"Overview","text":"<ul> <li>Name: Core Logging Library</li> <li>Description: A modern, feature-rich Python logging library providing structured colored console output, JSON logging, syslog integration, and advanced caller attribution capabilities</li> <li>Type: Library</li> <li>Technology: Python 3.13+, Rich, Python Standard Library</li> </ul>"},{"location":"C4-Documentation/c4-component-core-logging/#purpose","title":"Purpose","text":"<p>The Core Logging Library is the central component of the arlogi system, providing a comprehensive logging framework that extends Python's standard logging module with enhanced features designed for modern application development.</p>"},{"location":"C4-Documentation/c4-component-core-logging/#what-it-does","title":"What It Does","text":"<p>The Core Logging Library implements a complete logging infrastructure that addresses common pain points in Python application logging:</p> <ol> <li> <p>Enhanced Console Output: Provides beautiful, colored console output using the Rich library with project root detection for relative file paths, making logs easier to read and understand.</p> </li> <li> <p>Structured JSON Logging: Outputs log records in JSON format with standard fields (timestamp, level, message, file, line, function) plus support for custom extra fields, ideal for log aggregation and analysis systems.</p> </li> <li> <p>Syslog Integration: Offers native syslog integration with graceful fallback on systems where syslog is unavailable, making it suitable for production deployments.</p> </li> <li> <p>Caller Attribution: Automatically detects and displays the calling function name in log messages, enabling better tracking of log message origins without manual annotation.</p> </li> <li> <p>Custom TRACE Level: Implements a TRACE log level below DEBUG for more granular logging control during development and debugging.</p> </li> <li> <p>Module-Specific Configuration: Allows different log levels for different modules, enabling fine-grained control over logging verbosity across large applications.</p> </li> <li> <p>Test Mode Detection: Automatically detects test execution and adjusts default log levels to DEBUG for better test visibility.</p> </li> </ol>"},{"location":"C4-Documentation/c4-component-core-logging/#problems-it-solves","title":"Problems It Solves","text":"<ul> <li>Poor Readability: Traditional Python logging output is difficult to read and lacks color coding</li> <li>Limited Debugging Information: Standard logging doesn't easily show which function generated a log message</li> <li>Log Aggregation Challenges: Plain text logs are difficult to parse and analyze in log aggregation systems</li> <li>Coarse Log Control: Standard log levels (DEBUG, INFO, WARNING, ERROR, CRITICAL) are sometimes too granular</li> <li>Cross-Module Attribution: Difficult to trace log messages back to their source in complex, multi-module applications</li> <li>Production Integration: Lack of built-in syslog support forces manual integration work</li> </ul>"},{"location":"C4-Documentation/c4-component-core-logging/#role-in-the-system","title":"Role in the System","text":"<p>The Core Logging Library serves as the foundational component that:</p> <ul> <li>Provides all core logging functionality to consuming applications</li> <li>Exposes both high-level convenience functions and low-level configuration APIs</li> <li>Manages global logging state and configuration</li> <li>Implements custom handlers for different output targets</li> <li>Defines the logger protocol interface for type safety</li> </ul>"},{"location":"C4-Documentation/c4-component-core-logging/#software-features","title":"Software Features","text":"<p>The Core Logging Library provides the following software features:</p>"},{"location":"C4-Documentation/c4-component-core-logging/#core-logging-features","title":"Core Logging Features","text":"<ul> <li>Standard Logging Levels: Full support for Python standard logging levels (DEBUG, INFO, WARNING, ERROR, CRITICAL)</li> <li>Custom TRACE Level: Additional TRACE level (below DEBUG) for ultra-detailed logging during development</li> <li>Colored Console Output: Beautiful, syntax-colored console logs with Rich formatting</li> <li>Relative Path Display: Automatically detects project root and displays relative file paths</li> <li>Configurable Display Elements: Optional display of timestamp, log level, and file path in console output</li> </ul>"},{"location":"C4-Documentation/c4-component-core-logging/#structured-logging-features","title":"Structured Logging Features","text":"<ul> <li>JSON Stream Output: Structured JSON output to stderr for log aggregation</li> <li>JSON File Output: Structured JSON output to rotating log files</li> <li>Standard Fields: Automatic inclusion of timestamp, level, message, file, line number, function name</li> <li>Custom Extra Fields: Support for adding custom fields to JSON log records</li> <li>Automatic Directory Creation: JSON file handlers automatically create required directories</li> </ul>"},{"location":"C4-Documentation/c4-component-core-logging/#integration-features","title":"Integration Features","text":"<ul> <li>Syslog Support: Native syslog integration for production deployments</li> <li>Graceful Fallback: Automatic fallback to UDP or disabled syslog when /dev/log is unavailable</li> <li>Unix Domain Socket Support: Supports both Unix domain sockets (/dev/log) and remote syslog servers</li> </ul>"},{"location":"C4-Documentation/c4-component-core-logging/#advanced-features","title":"Advanced Features","text":"<ul> <li>Caller Attribution: Automatic detection and display of calling function names</li> <li>Cross-Module Attribution: Tracks call chains across module boundaries</li> <li>Stack Inspection: Uses Python's stack inspection to determine log origin</li> <li>Custom Attribution: Manual override of attribution using <code>from_caller</code> or <code>from_</code> parameters</li> </ul>"},{"location":"C4-Documentation/c4-component-core-logging/#configuration-features","title":"Configuration Features","text":"<ul> <li>Module-Specific Levels: Different log levels for different modules</li> <li>Immutable Configuration: Dataclass-based configuration with validation</li> <li>Environment Integration: Reads configuration from environment variables</li> <li>Builder Pattern: Fluent configuration API with <code>from_kwargs()</code> factory method</li> <li>Test Mode Detection: Automatically adjusts behavior during test execution</li> </ul>"},{"location":"C4-Documentation/c4-component-core-logging/#logger-management-features","title":"Logger Management Features","text":"<ul> <li>Dedicated JSON Loggers: Separate logger instances that only output JSON</li> <li>Dedicated Syslog Loggers: Separate logger instances that only output to syslog</li> <li>Global Logger: Singleton pattern for application-wide logging</li> <li>Logger Factory: Centralized logger creation and configuration</li> </ul>"},{"location":"C4-Documentation/c4-component-core-logging/#code-elements","title":"Code Elements","text":"<p>This component contains the following code-level elements:</p>"},{"location":"C4-Documentation/c4-component-core-logging/#core-modules","title":"Core Modules","text":"<ul> <li>c4-code-src-arlogi.md - Core library implementation containing:</li> <li><code>config.py</code> - LoggingConfig dataclass with validation and property methods</li> <li><code>factory.py</code> - LoggerFactory and TraceLogger classes for logger creation and management</li> <li><code>handler_factory.py</code> - HandlerFactory for creating log handlers</li> <li><code>handlers.py</code> - Custom handler implementations (ColoredConsoleHandler, JSONHandler, JSONFileHandler, ArlogiSyslogHandler)</li> <li><code>levels.py</code> - Custom TRACE level registration</li> <li><code>types.py</code> - LoggerProtocol for type-safe logger interfaces</li> </ul>"},{"location":"C4-Documentation/c4-component-core-logging/#test-and-example-code","title":"Test and Example Code","text":"<ul> <li>c4-code-tests.md - Comprehensive test suite:</li> <li><code>tests/test_core.py</code> - Core functionality tests</li> <li> <p><code>tests/test_features.py</code> - Feature implementation tests</p> </li> <li> <p>c4-code-tests-example.md - Integration examples:</p> </li> <li><code>tests/example/example.py</code> - Comprehensive feature demonstration</li> <li><code>tests/example/worker.py</code> - Cross-module logging examples</li> </ul>"},{"location":"C4-Documentation/c4-component-core-logging/#interfaces","title":"Interfaces","text":"<p>The Core Logging Library exposes multiple interfaces for different use cases:</p>"},{"location":"C4-Documentation/c4-component-core-logging/#python-api-high-level-convenience-functions","title":"Python API: High-Level Convenience Functions","text":"<p>Protocol: Python module-level functions Description: Simple, convenient interface for common logging operations</p> <p>Operations:</p> <pre><code>setup_logging(level: int | str = logging.INFO, **kwargs) -&gt; None\n</code></pre> <ul> <li>Description: Configure the root logging system with specified level and options</li> <li>Parameters:</li> <li><code>level</code>: Global logging level (default: INFO)</li> <li><code>**kwargs</code>: Additional configuration options (module_levels, json_file_name, use_syslog, etc.)</li> <li>Returns: None</li> <li>Example: <code>setup_logging(level=\"DEBUG\", json_file_name=\"app.jsonl\")</code></li> </ul> <pre><code>get_logger(name: str, level: int | str | None = None) -&gt; LoggerProtocol\n</code></pre> <ul> <li>Description: Get a logger instance with caller attribution support</li> <li>Parameters:</li> <li><code>name</code>: Logger name (typically module name using name)</li> <li><code>level</code>: Optional level override for this logger</li> <li>Returns: LoggerProtocol instance implementing standard logging methods</li> <li>Example: <code>logger = get_logger(__name__)</code></li> </ul> <pre><code>get_json_logger(name: str = \"json\", json_file_name: str | None = None) -&gt; LoggerProtocol\n</code></pre> <ul> <li>Description: Get a dedicated JSON-only logger that bypasses root handlers</li> <li>Parameters:</li> <li><code>name</code>: Logger name (default: \"json\")</li> <li><code>json_file_name</code>: Optional JSON file path (default: uses config or stderr)</li> <li>Returns: LoggerProtocol instance that only outputs JSON</li> <li>Example: <code>audit_logger = get_json_logger(\"audit\", \"audit.jsonl\")</code></li> </ul> <pre><code>get_syslog_logger(name: str = \"syslog\", address: str | tuple[str, int] = \"/dev/log\") -&gt; LoggerProtocol\n</code></pre> <ul> <li>Description: Get a dedicated syslog-only logger that bypasses root handlers</li> <li>Parameters:</li> <li><code>name</code>: Logger name (default: \"syslog\")</li> <li><code>address</code>: Syslog server address (default: \"/dev/log\")</li> <li>Returns: LoggerProtocol instance that only outputs to syslog</li> <li>Example: <code>syslog_logger = get_syslog_logger(\"security\")</code></li> </ul>"},{"location":"C4-Documentation/c4-component-core-logging/#python-api-loggerprotocol-interface","title":"Python API: LoggerProtocol Interface","text":"<p>Protocol: Python Protocol with runtime checking Description: Type-safe interface defining all logging operations</p> <p>Operations:</p> <pre><code>trace(msg: Any, *args: Any, from_caller: str | None = None, from_: str | None = None, **kwargs: Any) -&gt; None\n</code></pre> <ul> <li>Description: Log a TRACE level message (below DEBUG)</li> <li>Parameters:</li> <li><code>msg</code>: Log message (can be string or any object)</li> <li><code>*args</code>: Format arguments for message</li> <li><code>from_caller</code>: Override caller function name</li> <li><code>from_</code>: Alias for from_caller</li> <li><code>**kwargs</code>: Extra fields for JSON handlers</li> <li>Returns: None</li> </ul> <pre><code>debug(msg: Any, *args: Any, from_caller: str | None = None, from_: str | None = None, **kwargs: Any) -&gt; None\ninfo(msg: Any, *args: Any, from_caller: str | None = None, from_: str | None = None, **kwargs: Any) -&gt; None\nwarning(msg: Any, *args: Any, from_caller: str | None = None, from_: str | None = None, **kwargs: Any) -&gt; None\nerror(msg: Any, *args: Any, from_caller: str | None = None, from_: str | None = None, **kwargs: Any) -&gt; None\ncritical(msg: Any, *args: Any, from_caller: str | None = None, from_: str | None = None, **kwargs: Any) -&gt; None\n</code></pre> <ul> <li>Description: Log messages at standard levels with caller attribution</li> <li>Parameters: Same as trace()</li> <li>Returns: None</li> </ul> <pre><code>exception(msg: Any, *args: Any, from_caller: str | None = None, from_: str | None = None, **kwargs: Any) -&gt; None\n</code></pre> <ul> <li>Description: Log an exception with traceback information</li> <li>Parameters: Same as trace() plus automatic exception info capture</li> <li>Returns: None</li> </ul> <pre><code>log(level: int, msg: Any, *args: Any, from_caller: str | None = None, from_: str | None = None, **kwargs: Any) -&gt; None\n</code></pre> <ul> <li>Description: Log a message at a custom level</li> <li>Parameters:</li> <li><code>level</code>: Custom logging level integer</li> <li>Other parameters same as trace()</li> <li>Returns: None</li> </ul> <pre><code>setLevel(level: int) -&gt; None\n</code></pre> <ul> <li>Description: Set the logger's level threshold</li> <li>Parameters: <code>level</code>: Logging level integer</li> <li>Returns: None</li> </ul> <pre><code>isEnabledFor(level: int) -&gt; bool\n</code></pre> <ul> <li>Description: Check if a log level would be processed</li> <li>Parameters: <code>level</code>: Logging level integer to check</li> <li>Returns: True if level is enabled</li> </ul>"},{"location":"C4-Documentation/c4-component-core-logging/#python-api-loggingconfig-class","title":"Python API: LoggingConfig Class","text":"<p>Protocol: Python dataclass with builder pattern Description: Immutable configuration object for logging setup</p> <p>Operations:</p> <pre><code>LoggingConfig.__init__(level: int | str = ..., module_levels: dict[str, str | int] | None = None, ...)\n</code></pre> <ul> <li>Description: Create a new LoggingConfig instance</li> <li>Parameters:</li> <li><code>level</code>: Global log level (default: from get_default_level())</li> <li><code>module_levels</code>: Dictionary of module-specific levels</li> <li><code>json_file_name</code>: Path for JSON log file</li> <li><code>json_file_only</code>: If True, only log to JSON file</li> <li><code>use_syslog</code>: Enable syslog output</li> <li><code>syslog_address</code>: Syslog server address</li> <li><code>show_time</code>: Show timestamp in console output</li> <li><code>show_level</code>: Show log level in console output</li> <li><code>show_path</code>: Show file path in console output</li> <li>Returns: LoggingConfig instance</li> </ul> <pre><code>LoggingConfig.from_kwargs(**kwargs: Any) -&gt; LoggingConfig\n</code></pre> <ul> <li>Description: Factory method to create LoggingConfig from keyword arguments</li> <li>Parameters: <code>**kwargs</code>: Configuration keyword arguments</li> <li>Returns: LoggingConfig instance</li> </ul> <pre><code>LoggingConfig.resolved_level -&gt; int\n</code></pre> <ul> <li>Description: Property returning global level as integer</li> <li>Returns: Log level integer</li> </ul> <pre><code>LoggingConfig.show_console -&gt; bool\n</code></pre> <ul> <li>Description: Property indicating if console output should be shown</li> <li>Returns: True if console output enabled</li> </ul> <pre><code>LoggingConfig.has_json_output -&gt; bool\n</code></pre> <ul> <li>Description: Property indicating if JSON output is configured</li> <li>Returns: True if JSON output enabled</li> </ul> <pre><code>LoggingConfig.resolve_module_level(name: str, level: str | int) -&gt; int\n</code></pre> <ul> <li>Description: Resolve a module-specific level to integer</li> <li>Parameters:</li> <li><code>name</code>: Module name</li> <li><code>level</code>: Level value (string or integer)</li> <li>Returns: Resolved log level integer</li> </ul> <pre><code>LoggingConfig.to_dict() -&gt; dict[str, Any]\n</code></pre> <ul> <li>Description: Convert configuration to dictionary</li> <li>Returns: Dictionary representation of config</li> </ul>"},{"location":"C4-Documentation/c4-component-core-logging/#python-api-loggerfactory-class","title":"Python API: LoggerFactory Class","text":"<p>Protocol: Python class with static and instance methods Description: Factory for creating and configuring loggers</p> <p>Operations:</p> <pre><code>LoggerFactory._apply_configuration(config: LoggingConfig) -&gt; None\n</code></pre> <ul> <li>Description: Configure the root logging system using a configuration object (Recommended)</li> <li>Parameters: <code>config</code>: LoggingConfig instance</li> <li>Returns: None</li> <li>Side Effects: Modulates root logger configuration</li> </ul> <pre><code>LoggerFactory.get_logger(name: str, level: int | str | None = None) -&gt; LoggerProtocol\n</code></pre> <ul> <li>Description: Get a logger instance with caller attribution</li> <li>Parameters:</li> <li><code>name</code>: Logger name</li> <li><code>level</code>: Optional level override</li> <li>Returns: LoggerProtocol instance</li> </ul> <pre><code>LoggerFactory.get_json_logger(name: str = \"json\", json_file_name: str | None = None) -&gt; LoggerProtocol\n</code></pre> <ul> <li>Description: Get a dedicated JSON-only logger</li> <li>Parameters:</li> <li><code>name</code>: Logger name</li> <li><code>json_file_name</code>: Optional JSON file path</li> <li>Returns: LoggerProtocol instance</li> </ul> <pre><code>LoggerFactory.get_syslog_logger(name: str = \"syslog\", address: str | tuple[str, int] = \"/dev/log\") -&gt; LoggerProtocol\n</code></pre> <ul> <li>Description: Get a dedicated syslog-only logger</li> <li>Parameters:</li> <li><code>name</code>: Logger name</li> <li><code>address</code>: Syslog server address</li> <li>Returns: LoggerProtocol instance</li> </ul> <pre><code>LoggerFactory.get_global_logger() -&gt; LoggerProtocol\n</code></pre> <ul> <li>Description: Get or initialize the global logger instance</li> <li>Parameters: None</li> <li>Returns: Singleton global LoggerProtocol instance</li> </ul> <pre><code>LoggerFactory.is_test_mode() -&gt; bool\n</code></pre> <ul> <li>Description: Detect if running under test runner</li> <li>Parameters: None</li> <li>Returns: True if in test mode</li> </ul>"},{"location":"C4-Documentation/c4-component-core-logging/#json-handler-output-format","title":"JSON Handler Output Format","text":"<p>Protocol: JSON Lines (JSONL) format Description: Structured log format for machine parsing</p> <p>Schema:</p> <pre><code>{\n  \"timestamp\": \"string (ISO 8601 format)\",\n  \"level\": \"string (level name)\",\n  \"message\": \"string (log message)\",\n  \"file\": \"string (file path)\",\n  \"line\": \"number (line number)\",\n  \"function\": \"string (function name)\",\n  \"caller\": \"string | null (caller function name if available)\",\n  \"extra\": \"object (custom fields from **kwargs)\"\n}\n</code></pre> <p>Example:</p> <pre><code>{\n  \"timestamp\": \"2025-12-28T20:30:45.123456\",\n  \"level\": \"INFO\",\n  \"message\": \"User logged in successfully\",\n  \"file\": \"app/auth.py\",\n  \"line\": 42,\n  \"function\": \"login\",\n  \"caller\": \"process_login\",\n  \"extra\": {\n    \"user_id\": 12345,\n    \"ip_address\": \"192.168.1.100\"\n  }\n}\n</code></pre>"},{"location":"C4-Documentation/c4-component-core-logging/#dependencies","title":"Dependencies","text":""},{"location":"C4-Documentation/c4-component-core-logging/#components-used","title":"Components Used","text":"<p>This is a foundational component with no dependencies on other components. It is self-contained and provides logging services to the rest of the application.</p>"},{"location":"C4-Documentation/c4-component-core-logging/#external-systems","title":"External Systems","text":""},{"location":"C4-Documentation/c4-component-core-logging/#python-standard-library","title":"Python Standard Library","text":"<ul> <li>logging (Core): Python's standard logging framework</li> <li>Used for: Base logger classes, level definitions, formatter infrastructure</li> <li> <p>Version: Built-in to Python standard library</p> </li> <li> <p>os (System Interface): Operating system interface</p> </li> <li>Used for: Environment variable access, file system operations, directory creation</li> <li> <p>Version: Built-in to Python standard library</p> </li> <li> <p>sys (System Parameters): System-specific parameters</p> </li> <li>Used for: Stack inspection, system-specific constants</li> <li> <p>Version: Built-in to Python standard library</p> </li> <li> <p>dataclasses (Data Structures): Data class decorator</p> </li> <li>Used for: LoggingConfig immutable configuration class</li> <li> <p>Version: Built-in to Python standard library (Python 3.7+)</p> </li> <li> <p>json (JSON Encoding): JSON encoder and decoder</p> </li> <li>Used for: JSON log formatting in JSONHandler and JSONFormatter</li> <li> <p>Version: Built-in to Python standard library</p> </li> <li> <p>datetime (Date/Time): Date and time handling</p> </li> <li>Used for: Timestamp generation in JSON logs</li> <li> <p>Version: Built-in to Python standard library</p> </li> <li> <p>typing (Type Hints): Type hint support</p> </li> <li>Used for: LoggerProtocol, type hints throughout</li> <li> <p>Version: Built-in to Python standard library</p> </li> <li> <p>pathlib (Paths): Object-oriented filesystem paths</p> </li> <li>Used for: Path manipulation in ColoredConsoleHandler</li> <li> <p>Version: Built-in to Python standard library</p> </li> <li> <p>logging.handlers (Logging Handlers): Additional logging handlers</p> </li> <li>Used for: SysLogHandler base class</li> <li>Version: Built-in to Python standard library</li> </ul>"},{"location":"C4-Documentation/c4-component-core-logging/#third-party-libraries","title":"Third-Party Libraries","text":"<ul> <li>rich (Terminal Formatting): Rich text and beautiful formatting in the terminal</li> <li>Used for: Colored console output, RichHandler, Console, text formatting</li> <li>Version: 13.9.4+ (as specified in pyproject.toml)</li> <li>Website: https://github.com/Textualize/rich</li> </ul>"},{"location":"C4-Documentation/c4-component-core-logging/#development-dependencies-testing","title":"Development Dependencies (Testing)","text":"<ul> <li>pytest (Testing Framework): Testing framework for Python</li> <li>Used for: Running test suite, caplog and capsys fixtures</li> <li>Version: 9.0.2+</li> <li> <p>Not required in production, only for testing</p> </li> <li> <p>pytest-cov (Coverage): Pytest plugin for coverage reporting</p> </li> <li>Used for: Test coverage measurement</li> <li>Version: 7.0.0+</li> <li>Not required in production, only for testing</li> </ul>"},{"location":"C4-Documentation/c4-component-core-logging/#component-diagram","title":"Component Diagram","text":"<pre><code>C4Component\n    title Component Diagram for arlogi Logging Library\n\n    Container_Boundary(c1, \"arlogi Logging Library\") {\n        Component(config, \"LoggingConfig\", \"Configuration\", \"Immutable configuration dataclass with validation and builder pattern\")\n        Component(levels, \"TRACE Level\", \"Custom Level\", \"Custom TRACE log level registration below DEBUG\")\n        Component(types, \"LoggerProtocol\", \"Protocol\", \"Type-safe logger interface definition\")\n        Component(handlers, \"Handlers\", \"Handlers\", \"Custom log handlers: ColoredConsole, JSON Stream/File, Syslog\")\n        Component(handler_factory, \"HandlerFactory\", \"Factory\", \"Creates and configures log handlers\")\n        Component(trace_logger, \"TraceLogger\", \"Logger\", \"Custom logger with TRACE level and caller attribution\")\n        Component(logger_factory, \"LoggerFactory\", \"Factory\", \"Creates and configures logger instances\")\n        Component(api, \"Public API\", \"Functions\", \"High-level convenience functions: setup_logging, get_logger, etc.\")\n    }\n\n    Person(user, \"Application Developer\", \"Developer using arlogi\")\n\n    System_Ext(rich, \"Rich Library\", \"Terminal formatting library\")\n    System_Ext(logging, \"Python logging\", \"Python standard logging module\")\n    System_Ext(syslog, \"Syslog Daemon\", \"System log service\")\n\n    Rel(user, api, \"Uses\", \"Python API\")\n    Rel(api, logger_factory, \"Uses\", \"Delegates to factory\")\n    Rel(logger_factory, config, \"Uses\", \"For configuration\")\n    Rel(logger_factory, handler_factory, \"Uses\", \"Creates handlers\")\n    Rel(logger_factory, trace_logger, \"Creates\", \"Logger instances\")\n    Rel(handler_factory, handlers, \"Creates\", \"Handler instances\")\n    Rel(trace_logger, levels, \"Uses\", \"TRACE level\")\n    Rel(trace_logger, types, \"Implements\", \"LoggerProtocol\")\n    Rel(handlers, rich, \"Uses\", \"Colored output\")\n    Rel(handlers, logging, \"Extends\", \"Base handlers\")\n    Rel(handlers, syslog, \"Writes to\", \"Syslog output\")\n\n    Rel_N(api, logging, \"Extends\", \"Python logging\")</code></pre>"},{"location":"C4-Documentation/c4-component-core-logging/#data-flow-diagram","title":"Data Flow Diagram","text":"<pre><code>flowchart TB\n    subgraph Application[\"Application Code\"]\n        UserCode[\"User Application\"]\n    end\n\n    subgraph API[\"Public API\"]\n        Setup[\"setup_logging()\"]\n        GetLogger[\"get_logger()\"]\n    end\n\n    subgraph Factory[\"LoggerFactory\"]\n        SetupMethod[\"setup()\"]\n        GetLoggerMethod[\"get_logger()\"]\n        ApplyConfig[\"_apply_configuration()\"]\n    end\n\n    subgraph Config[\"Configuration\"]\n        LoggingConfig[\"LoggingConfig\"]\n    end\n\n    subgraph Handlers[\"HandlerFactory\"]\n        CreateHandlers[\"create_handlers()\"]\n        CreateConsole[\"create_console()\"]\n        CreateJSON[\"create_json_handler()\"]\n        CreateSyslog[\"create_syslog()\"]\n    end\n\n    subgraph Outputs[\"Log Outputs\"]\n        Console[\"Colored Console\"]\n        JSONStream[\"JSON stderr\"]\n        JSONFile[\"JSON File\"]\n        Syslog[\"Syslog\"]\n    end\n\n    UserCode --&gt; Setup\n    UserCode --&gt; GetLogger\n    Setup --&gt; SetupMethod\n    GetLogger --&gt; GetLoggerMethod\n    SetupMethod --&gt; ApplyConfig\n    ApplyConfig --&gt; LoggingConfig\n    ApplyConfig --&gt; CreateHandlers\n    CreateHandlers --&gt; CreateConsole\n    CreateHandlers --&gt; CreateJSON\n    CreateHandlers --&gt; CreateSyslog\n\n    CreateConsole --&gt; Console\n    CreateJSON --&gt; JSONStream\n    CreateJSON --&gt; JSONFile\n    CreateSyslog --&gt; Syslog\n\n    style UserCode fill:#e1f5fe\n    style Console fill:#c8e6c9\n    style JSONStream fill:#c8e6c9\n    style JSONFile fill:#c8e6c9\n    style Syslog fill:#c8e6c9</code></pre>"},{"location":"C4-Documentation/c4-component-core-logging/#key-design-patterns","title":"Key Design Patterns","text":"<p>The Core Logging Library implements several design patterns:</p>"},{"location":"C4-Documentation/c4-component-core-logging/#1-factory-pattern","title":"1. Factory Pattern","text":"<ul> <li>LoggerFactory: Creates and configures logger instances</li> <li>HandlerFactory: Creates handler instances based on configuration</li> <li>Benefit: Centralized object creation with consistent configuration</li> </ul>"},{"location":"C4-Documentation/c4-component-core-logging/#2-builder-pattern","title":"2. Builder Pattern","text":"<ul> <li>LoggingConfig.from_kwargs(): Fluent configuration building</li> <li>Benefit: Flexible, readable configuration with validation</li> </ul>"},{"location":"C4-Documentation/c4-component-core-logging/#3-strategy-pattern","title":"3. Strategy Pattern","text":"<ul> <li>Multiple Handlers: Different output strategies (console, JSON, syslog)</li> <li>Benefit: Easy to add new output targets without changing core logic</li> </ul>"},{"location":"C4-Documentation/c4-component-core-logging/#4-protocol-pattern","title":"4. Protocol Pattern","text":"<ul> <li>LoggerProtocol: Type-safe interface definition</li> <li>Benefit: Compile-time type checking with runtime validation</li> </ul>"},{"location":"C4-Documentation/c4-component-core-logging/#5-singleton-pattern","title":"5. Singleton Pattern","text":"<ul> <li>Global Logger: Single global logger instance</li> <li>Benefit: Consistent logging configuration across application</li> </ul>"},{"location":"C4-Documentation/c4-component-core-logging/#6-template-method-pattern","title":"6. Template Method Pattern","text":"<ul> <li>Custom Handlers: Extend base handlers with specialized behavior</li> <li>Benefit: Code reuse and consistent handler interface</li> </ul>"},{"location":"C4-Documentation/c4-component-core-logging/#architecture-notes","title":"Architecture Notes","text":""},{"location":"C4-Documentation/c4-component-core-logging/#separation-of-concerns","title":"Separation of Concerns","text":"<p>The component is organized into clear layers:</p> <ul> <li>Configuration Layer: LoggingConfig handles all configuration</li> <li>Factory Layer: LoggerFactory and HandlerFactory create instances</li> <li>Handler Layer: Handlers implement output strategies</li> <li>Protocol Layer: LoggerProtocol defines the interface</li> <li>API Layer: Public functions provide convenient access</li> </ul>"},{"location":"C4-Documentation/c4-component-core-logging/#extensibility","title":"Extensibility","text":"<p>The component is designed for extension:</p> <ul> <li>New handlers can be added by extending logging.Handler</li> <li>New formatters can be added by extending logging.Formatter</li> <li>Custom log levels can be registered using the same pattern as TRACE</li> <li>HandlerFactory can be extended to support new handler types</li> </ul>"},{"location":"C4-Documentation/c4-component-core-logging/#immutability","title":"Immutability","text":"<p>LoggingConfig uses @dataclass with frozen=True to ensure:</p> <ul> <li>Configuration cannot be accidentally modified after creation</li> <li>Thread-safe configuration access</li> <li>Clear configuration lifecycle</li> </ul>"},{"location":"C4-Documentation/c4-component-core-logging/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Stack inspection only happens when caller attribution is requested</li> <li>Handlers are created once and reused</li> <li>JSON formatting uses efficient JSON encoder</li> <li>Rich console output uses optimized rendering</li> </ul>"},{"location":"C4-Documentation/c4-component-core-logging/#error-handling","title":"Error Handling","text":"<ul> <li>Syslog handler gracefully falls back when /dev/log is unavailable</li> <li>Configuration validation happens at initialization time</li> <li>Invalid log levels raise clear ValueError exceptions</li> <li>File handlers automatically create required directories</li> </ul>"},{"location":"C4-Documentation/c4-component-core-logging/#related-documentation","title":"Related Documentation","text":"<ul> <li>c4-code-src-arlogi.md - Core Logging Library Component - Core logging functionality details</li> <li>Test Suite Component - Testing infrastructure documentation</li> <li>Documentation System Component - Documentation generation and deployment</li> <li>Documentation Index - Project overview and getting started guide</li> <li>API Reference - Complete API reference documentation</li> </ul>"},{"location":"C4-Documentation/c4-component-documentation/","title":"C4 Component Level: Documentation System","text":""},{"location":"C4-Documentation/c4-component-documentation/#overview","title":"Overview","text":"<ul> <li>Name: Documentation System</li> <li>Description: Automated documentation generation, build, and deployment system for the arlogi logging library</li> <li>Type: Documentation Infrastructure</li> <li>Technology: MkDocs, Material Theme, MkDocstrings, Markdown, Python, Bash</li> </ul>"},{"location":"C4-Documentation/c4-component-documentation/#purpose","title":"Purpose","text":"<p>The Documentation System component is responsible for generating, building, and publishing comprehensive technical documentation for the arlogi logging library. It automates the extraction of API documentation from Python source code, provides a modern web-based documentation interface, and includes deployment capabilities for publishing documentation to remote servers.</p> <p>This component serves as the bridge between the library's source code and its users, ensuring that API documentation stays synchronized with code changes and provides an intuitive, searchable interface for developers exploring the library's capabilities.</p> <p>The system supports multiple documentation types: - API Reference Documentation: Auto-generated from Python docstrings and type hints - User Guides: Conceptual documentation for library users - Developer Guides: Technical documentation for contributors - Configuration Guides: Setup and customization documentation - Architecture Documentation: C4 architectural diagrams and design documents</p>"},{"location":"C4-Documentation/c4-component-documentation/#software-features","title":"Software Features","text":""},{"location":"C4-Documentation/c4-component-documentation/#api-documentation-generation","title":"API Documentation Generation","text":"<ul> <li>Automatic extraction: Generates API reference documentation from Python source code using MkDocstrings</li> <li>Type hints preservation: Maintains type information and function signatures in documentation</li> <li>Class and function indexing: Automatically identifies and documents all public classes and functions</li> <li>Module-level documentation: Creates dedicated pages for each Python module in the library</li> <li>Cross-referencing: Supports links between related API elements</li> </ul>"},{"location":"C4-Documentation/c4-component-documentation/#documentation-build-system","title":"Documentation Build System","text":"<ul> <li>Static site generation: Uses MkDocs to build fast, static HTML documentation sites</li> <li>Theme integration: Leverages Material theme for modern, responsive design</li> <li>Search functionality: Built-in search plugin for full-text documentation search</li> <li>Syntax highlighting: PyMdownX extensions for code highlighting and Mermaid diagram support</li> <li>Navigation management: Automatic generation of hierarchical navigation structures</li> </ul>"},{"location":"C4-Documentation/c4-component-documentation/#developer-tools","title":"Developer Tools","text":"<ul> <li>Reference page generator: Python script (<code>gen_ref_pages.py</code>) for automated API documentation creation</li> <li>YAML navigation builder: Generates MkDocs-compatible navigation configuration</li> <li>Source code analysis: Regex-based extraction of classes and functions from Python files</li> <li>Markdown generation: Creates MkDocs-autodoc compatible markdown files</li> </ul>"},{"location":"C4-Documentation/c4-component-documentation/#deployment-automation","title":"Deployment Automation","text":"<ul> <li>Remote publishing: Bash script (<code>build_pub.sh</code>) for deploying documentation to remote servers</li> <li>Secure transfer: Uses SSH/rsync for secure file synchronization</li> <li>Incremental updates: Efficiently syncs only changed files to remote server</li> <li>Key-based authentication: Supports SSH key authentication for secure deployments</li> </ul>"},{"location":"C4-Documentation/c4-component-documentation/#documentation-features","title":"Documentation Features","text":"<ul> <li>Code copy functionality: GitHub-style code copying for code examples</li> <li>Mobile responsive: Material theme provides mobile-optimized viewing experience</li> <li>Print-friendly: Documentation pages are formatted for printing</li> <li>Version-aware: Structure supports documentation versioning</li> <li>Mermaid diagram support: Renders architecture diagrams directly in documentation</li> </ul>"},{"location":"C4-Documentation/c4-component-documentation/#code-elements","title":"Code Elements","text":"<p>This component contains the following code-level elements:</p> <ul> <li>c4-code-docs-reference.md - API Reference Documentation</li> <li>Documents the auto-generated API reference system</li> <li>Covers MkDocstrings integration and configuration</li> <li>Describes module documentation structure and navigation</li> <li> <p>Details reference documentation for all arlogi modules (config, factory, handlers, levels, types)</p> </li> <li> <p>c4-code-docs-scripts.md - Documentation Build Scripts</p> </li> <li>Documents Python scripts for automated documentation generation</li> <li>Covers Bash scripts for deployment automation</li> <li>Describes functions for extracting classes and functions from source code</li> <li>Details workflow for building and publishing documentation</li> </ul>"},{"location":"C4-Documentation/c4-component-documentation/#interfaces","title":"Interfaces","text":""},{"location":"C4-Documentation/c4-component-documentation/#command-line-interface-cli","title":"Command Line Interface (CLI)","text":""},{"location":"C4-Documentation/c4-component-documentation/#documentation-generation","title":"Documentation Generation","text":"<pre><code># Generate API reference pages from source code\npython docs/scripts/gen_ref_pages.py\n\n# Build the complete documentation site\nmkdocs build\n\n# Serve documentation locally for development\nmkdocs serve\n</code></pre>"},{"location":"C4-Documentation/c4-component-documentation/#documentation-deployment","title":"Documentation Deployment","text":"<pre><code># Deploy built documentation to remote server\ndocs/scripts/build_pub.sh\n</code></pre> <p>Parameters: - None required for generation (uses default paths) - Deployment uses pre-configured SSH settings</p> <p>Returns: - Generation: Creates markdown files in <code>docs/reference/</code> and prints YAML navigation - Build: Creates static HTML site in <code>site/</code> directory - Deployment: Syncs files to remote server and provides status messages</p>"},{"location":"C4-Documentation/c4-component-documentation/#web-interface","title":"Web Interface","text":""},{"location":"C4-Documentation/c4-component-documentation/#documentation-site","title":"Documentation Site","text":"<ul> <li>Protocol: HTTP/HTTPS</li> <li>Access: <code>http://[server]/arlogi</code> (when deployed)</li> <li>Features:</li> <li>Browse API reference by module</li> <li>Search across all documentation</li> <li>Navigate using hierarchical menu</li> <li>View Mermaid architecture diagrams</li> <li>Copy code examples with one click</li> </ul>"},{"location":"C4-Documentation/c4-component-documentation/#local-development-server","title":"Local Development Server","text":"<ul> <li>Protocol: HTTP</li> <li>Access: <code>http://localhost:8000</code> (default MkDocs serve port)</li> <li>Live Reload: Automatically refreshes on documentation changes</li> <li>Purpose: Preview documentation changes before deployment</li> </ul>"},{"location":"C4-Documentation/c4-component-documentation/#configuration-interface","title":"Configuration Interface","text":""},{"location":"C4-Documentation/c4-component-documentation/#mkdocs-configuration-file","title":"MkDocs Configuration File","text":"<ul> <li>File: <code>mkdocs.yml</code></li> <li>Format: YAML</li> <li>Purpose: Defines documentation structure, theme, plugins, and navigation</li> <li>Key Settings:</li> <li>Site name and description</li> <li>Theme configuration (Material theme)</li> <li>Plugin settings (MkDocstrings, search)</li> <li>Navigation structure</li> <li>Markdown extensions</li> </ul>"},{"location":"C4-Documentation/c4-component-documentation/#dependencies","title":"Dependencies","text":""},{"location":"C4-Documentation/c4-component-documentation/#components-documented","title":"Components Documented","text":"<ul> <li>Core Logging Library (<code>arlogi</code>): All Python modules in <code>src/arlogi/</code> are documented</li> <li><code>arlogi.config</code> - Configuration management</li> <li><code>arlogi.factory</code> - Logger factory implementations</li> <li><code>arlogi.handler_factory</code> - Handler creation utilities</li> <li><code>arlogi.handlers</code> - Handler classes</li> <li><code>arlogi.levels</code> - Logging levels definitions</li> <li><code>arlogi.types</code> - Type definitions and protocols</li> </ul>"},{"location":"C4-Documentation/c4-component-documentation/#external-systems","title":"External Systems","text":"<ul> <li>MkDocs: Static site generator for building documentation</li> <li>Provides core documentation framework</li> <li>Handles markdown processing and site generation</li> <li> <p>Manages plugins and themes</p> </li> <li> <p>Material Theme for MkDocs: Modern documentation theme</p> </li> <li>Provides responsive design</li> <li>Implements search functionality</li> <li>Offers navigation components</li> <li> <p>Supports code copying and syntax highlighting</p> </li> <li> <p>MkDocstrings: Automatic API documentation generation</p> </li> <li>Extracts docstrings from Python code</li> <li>Generates markdown documentation</li> <li>Handles cross-references and type hints</li> <li> <p>Integrates with MkDocs build process</p> </li> <li> <p>PyMdownX Extensions: Markdown processing extensions</p> </li> <li>Syntax highlighting for code blocks</li> <li>Mermaid diagram rendering</li> <li>Advanced markdown features</li> </ul>"},{"location":"C4-Documentation/c4-component-documentation/#infrastructure-dependencies","title":"Infrastructure Dependencies","text":"<ul> <li>SSH Server: Remote documentation hosting (192.168.168.5)</li> <li>Deployment target for published documentation</li> <li>Web server hosting (nginx)</li> <li> <p>Document root: <code>/opt/c/nginx/html/arlogi</code></p> </li> <li> <p>Development Tools:</p> </li> <li>Python 3.x for script execution</li> <li>Bash shell for deployment automation</li> <li>rsync for file synchronization</li> </ul>"},{"location":"C4-Documentation/c4-component-documentation/#data-dependencies","title":"Data Dependencies","text":"<ul> <li>Source Code: Python files in <code>src/arlogi/</code> directory</li> <li>Docstrings: Documentation embedded in source code</li> <li>Type Hints: Type annotations used for API documentation</li> <li>Configuration Files: <code>mkdocs.yml</code>, <code>docs/extra.css</code></li> </ul>"},{"location":"C4-Documentation/c4-component-documentation/#component-diagram","title":"Component Diagram","text":"<pre><code>C4Component\n    title Component Diagram for Documentation System\n\n    Container_Boundary(doc_system, \"Documentation System\") {\n        Component(gen_ref, \"Reference Page Generator\", \"Python Script\", \"Generates API reference markdown from source code\")\n        Component(mkdocs, \"MkDocs Builder\", \"Static Site Generator\", \"Builds documentation site from markdown\")\n        Component(ref_docs, \"API Reference Docs\", \"Markdown Files\", \"Auto-generated API documentation\")\n        Component(user_docs, \"User Documentation\", \"Markdown Files\", \"Manual user guides and tutorials\")\n        Component(dev_scripts, \"Deployment Scripts\", \"Bash/Python\", \"Automates documentation deployment\")\n    }\n\n    ComponentDb(site, \"Built Documentation Site\", \"Static HTML/CSS/JS\", \"Deployable documentation website\")\n\n    Component_Ext(core_lib, \"Core Logging Library\", \"Python Package\", \"arlogi library being documented\")\n\n    System_Ext(remote_server, \"Remote Web Server\", \"nginx web server\")\n    System_Ext(developers, \"Developers\", \"Documentation consumers\")\n\n    Rel(core_lib, gen_ref, \"Provides source code and docstrings\")\n    Rel(gen_ref, ref_docs, \"Generates\")\n    Rel(user_docs, mkdocs, \"Input\")\n    Rel(ref_docs, mkdocs, \"Input\")\n    Rel(mkdocs, site, \"Builds\")\n    Rel(site, dev_scripts, \"Deployment\")\n    Rel(dev_scripts, remote_server, \"Publishes via SSH/rsync\")\n    Rel(remote_server, developers, \"Serves documentation\")\n\n    UpdateRelStyle(gen_ref, ref_docs, \"\", \"#ff6666\", \"solid\", \"2px\")\n    UpdateRelStyle(mkdocs, site, \"\", \"#ff6666\", \"solid\", \"2px\")</code></pre>"},{"location":"C4-Documentation/c4-component-documentation/#component-interactions","title":"Component Interactions","text":""},{"location":"C4-Documentation/c4-component-documentation/#documentation-generation-flow","title":"Documentation Generation Flow","text":"<ol> <li>Source Code Analysis: <code>gen_ref_pages.py</code> scans Python source files in <code>src/arlogi/</code></li> <li>API Extraction: Uses regex to identify classes, functions, and their docstrings</li> <li>Markdown Generation: Creates MkDocs-compatible markdown files for each module</li> <li>Navigation Creation: Generates YAML navigation structure for MkDocs configuration</li> </ol>"},{"location":"C4-Documentation/c4-component-documentation/#documentation-build-flow","title":"Documentation Build Flow","text":"<ol> <li>Input Collection: MkDocs reads markdown files from <code>docs/</code> directory</li> <li>Processing: Applies theme, plugins, and markdown extensions</li> <li>API Documentation: MkDocstrings generates API reference from inline references</li> <li>Site Generation: Creates static HTML site in <code>site/</code> directory</li> <li>Asset Optimization: Bundles CSS, JavaScript, and images</li> </ol>"},{"location":"C4-Documentation/c4-component-documentation/#documentation-deployment-flow","title":"Documentation Deployment Flow","text":"<ol> <li>Pre-flight Check: <code>build_pub.sh</code> verifies SSH connectivity</li> <li>File Synchronization: Uses rsync to efficiently transfer changed files</li> <li>Remote Publishing: Copies files to nginx web server document root</li> <li>Verification: Confirms successful deployment</li> </ol>"},{"location":"C4-Documentation/c4-component-documentation/#user-access-flow","title":"User Access Flow","text":"<ol> <li>Browse: Users access documentation via web browser</li> <li>Navigation: Hierarchical menu for exploring documentation</li> <li>Search: Full-text search for finding specific information</li> <li>Reference: View API documentation with type hints and examples</li> <li>Copy: One-click code copying for code examples</li> </ol>"},{"location":"C4-Documentation/c4-component-documentation/#technology-stack","title":"Technology Stack","text":""},{"location":"C4-Documentation/c4-component-documentation/#documentation-generation_1","title":"Documentation Generation","text":"<ul> <li>MkDocs (v1.5+): Static site generator</li> <li>Material Theme: Modern documentation theme</li> <li>MkDocstrings (v1.0+): Automatic API documentation</li> <li>Python (3.10+): Script execution and code analysis</li> <li>Markdown: Documentation authoring format</li> </ul>"},{"location":"C4-Documentation/c4-component-documentation/#development-tools","title":"Development Tools","text":"<ul> <li>PyMdown Extensions: Advanced Markdown features</li> <li>Python Standard Library: <code>re</code>, <code>sys</code>, <code>pathlib</code> for code analysis</li> <li>Bash: Shell scripting for deployment automation</li> </ul>"},{"location":"C4-Documentation/c4-component-documentation/#deployment","title":"Deployment","text":"<ul> <li>OpenSSH: Secure remote access</li> <li>rsync: Efficient file synchronization</li> <li>nginx: Web server for hosting documentation</li> </ul>"},{"location":"C4-Documentation/c4-component-documentation/#documentation-features_1","title":"Documentation Features","text":"<ul> <li>Mermaid.js: Diagram rendering</li> <li>Highlight.js: Code syntax highlighting</li> <li>JavaScript: Interactive features (search, navigation, code copying)</li> </ul>"},{"location":"C4-Documentation/c4-component-documentation/#deployment-considerations","title":"Deployment Considerations","text":""},{"location":"C4-Documentation/c4-component-documentation/#local-development","title":"Local Development","text":"<ul> <li>Scripts assume execution from repository root directory</li> <li>Requires Python 3.x and Bash environment</li> <li>MkDocs must be installed in development environment</li> <li>Generated files committed to version control for consistency</li> </ul>"},{"location":"C4-Documentation/c4-component-documentation/#production-deployment","title":"Production Deployment","text":"<ul> <li>Remote server configuration hardcoded in <code>build_pub.sh</code></li> <li>SSH key authentication required for automated deployment</li> <li>Target directory must exist and have proper permissions</li> <li>nginx configuration must point to documentation root</li> </ul>"},{"location":"C4-Documentation/c4-component-documentation/#build-artifacts","title":"Build Artifacts","text":"<ul> <li><code>site/</code> directory contains complete static site</li> <li>Can be deployed to any static web hosting service</li> <li>Supports deployment to GitHub Pages, Netlify, or custom servers</li> <li>No server-side processing required</li> </ul>"},{"location":"C4-Documentation/c4-component-documentation/#maintenance","title":"Maintenance","text":"<ul> <li>Documentation should be regenerated when API changes are made</li> <li>MkDocs configuration updates require rebuild</li> <li>Navigation structure must be manually maintained in <code>mkdocs.yml</code></li> <li>Theme customization requires CSS modifications in <code>docs/extra.css</code></li> </ul>"},{"location":"C4-Documentation/c4-component-documentation/#integration-points","title":"Integration Points","text":""},{"location":"C4-Documentation/c4-component-documentation/#with-core-library","title":"With Core Library","text":"<ul> <li>Docstrings: Source code must have comprehensive docstrings</li> <li>Type Hints: Type annotations improve documentation quality</li> <li>Module Structure: Documentation follows Python module organization</li> <li>Examples: Code examples in docstrings appear in API reference</li> </ul>"},{"location":"C4-Documentation/c4-component-documentation/#with-development-workflow","title":"With Development Workflow","text":"<ul> <li>CI/CD Integration: Scripts can be integrated into automated pipelines</li> <li>Pre-commit Hooks: Can generate documentation on code changes</li> <li>Version Control: Generated documentation can be versioned with code</li> <li>Code Review: Documentation updates can be reviewed alongside code</li> </ul>"},{"location":"C4-Documentation/c4-component-documentation/#with-external-services","title":"With External Services","text":"<ul> <li>Web Hosting: Can deploy to various static hosting platforms</li> <li>CDN: Built assets can be distributed via CDN</li> <li>Analytics: Can integrate web analytics for usage tracking</li> <li>Search: Can integrate with external search services (Algolia, etc.)</li> </ul>"},{"location":"C4-Documentation/c4-component-documentation/#quality-assurance","title":"Quality Assurance","text":""},{"location":"C4-Documentation/c4-component-documentation/#documentation-testing","title":"Documentation Testing","text":"<ul> <li>Link Checking: Verify all internal and external links resolve</li> <li>Build Verification: Ensure documentation builds without errors</li> <li>Content Review: Technical accuracy of API documentation</li> <li>Accessibility: Verify documentation meets accessibility standards</li> <li>Browser Compatibility: Test across different browsers and devices</li> </ul>"},{"location":"C4-Documentation/c4-component-documentation/#automated-validation","title":"Automated Validation","text":"<ul> <li>MkDocs Build: Catches markdown syntax errors</li> <li>MkDocstrings Validation: Validates docstring format and references</li> <li>Script Testing: Verify generation scripts produce expected output</li> <li>Deployment Testing: Confirm successful remote deployment</li> </ul>"},{"location":"C4-Documentation/c4-component-documentation/#continuous-improvement","title":"Continuous Improvement","text":"<ul> <li>User Feedback: Collect feedback on documentation clarity</li> <li>Usage Analytics: Track most-accessed documentation pages</li> <li>Search Queries: Analyze search terms to identify content gaps</li> <li>Error Reporting: Monitor documentation-related error reports</li> </ul>"},{"location":"C4-Documentation/c4-component-test-suite/","title":"C4 Component Level: Test Suite","text":""},{"location":"C4-Documentation/c4-component-test-suite/#overview","title":"Overview","text":"<ul> <li>Name: Test Suite</li> <li>Description: Comprehensive testing infrastructure validating the correctness, reliability, and feature completeness of the arlogi logging library</li> <li>Type: Test Suite</li> <li>Technology: Python 3.13+, pytest 9.0.2+, pytest-cov 7.0.0+</li> </ul>"},{"location":"C4-Documentation/c4-component-test-suite/#purpose","title":"Purpose","text":"<p>The Test Suite component serves as the quality assurance infrastructure for the arlogi logging library. Its primary purpose is to validate all aspects of library functionality through systematic unit tests, feature tests, and integration examples. This component ensures that:</p> <ol> <li>Core Functionality Works Correctly: All basic logging operations, level registration, and protocol compliance are verified</li> <li>Features Function as Designed: Advanced features like module-specific levels, JSON logging, caller attribution, and stack level handling work correctly</li> <li>Integration Patterns Work: Real-world usage patterns including cross-module logging, dedicated loggers, and environment-based configuration are validated</li> <li>Regressions are Prevented: Comprehensive test coverage ensures future changes don't break existing functionality</li> <li>Documentation is Validated: Integration examples serve as both tests and practical usage documentation</li> </ol> <p>The Test Suite solves the critical problem of maintaining code quality and reliability as the library evolves, providing confidence that the logging library performs correctly in diverse scenarios.</p>"},{"location":"C4-Documentation/c4-component-test-suite/#software-features","title":"Software Features","text":""},{"location":"C4-Documentation/c4-component-test-suite/#unit-testing-framework","title":"Unit Testing Framework","text":"<ul> <li>Automated Test Discovery: Uses pytest's automatic test discovery to find and execute all test functions</li> <li>Test Coverage Reporting: Integrates pytest-cov to generate comprehensive coverage reports (currently maintaining high coverage)</li> <li>Log Output Capture: Uses pytest's <code>caplog</code> fixture to capture and validate log messages</li> <li>Console Output Capture: Uses pytest's <code>capsys</code> fixture to validate stdout/stderr output</li> <li>Test Mode Detection: Automatically detects test execution mode to adapt logging behavior</li> </ul>"},{"location":"C4-Documentation/c4-component-test-suite/#core-functionality-testing","title":"Core Functionality Testing","text":"<ul> <li>TRACE Level Validation: Verifies that the custom TRACE log level is properly registered in the logging system</li> <li>Protocol Compliance Testing: Ensures logger instances properly implement the LoggerProtocol interface</li> <li>Test Mode Detection: Validates that LoggerFactory correctly identifies test execution context</li> <li>Logging Call Verification: Tests all logging levels (TRACE, DEBUG, INFO, WARNING, ERROR, CRITICAL) work correctly</li> </ul>"},{"location":"C4-Documentation/c4-component-test-suite/#feature-testing","title":"Feature Testing","text":"<ul> <li>Module-Specific Level Configuration: Validates that different modules can have independent log level overrides</li> <li>JSON Logger Testing: Verifies dedicated JSON logger functionality and output format compliance</li> <li>Stack Level Handling: Validates that stacklevel parameter works correctly for proper call site attribution</li> <li>Caller Attribution Testing: Tests the caller attribution feature that shows calling function names in log messages</li> </ul>"},{"location":"C4-Documentation/c4-component-test-suite/#integration-testing","title":"Integration Testing","text":"<ul> <li>Cross-Module Logging: Validates logging behavior across module boundaries with proper attribution</li> <li>Dedicated Logger Instances: Tests multiple logger types (standard, JSON-only, syslog) in the same application</li> <li>Environment Configuration: Verifies environment-based log level configuration</li> <li>Nested Call Attribution: Tests caller attribution through multiple levels of function calls</li> <li>Subdirectory Import Validation: Ensures library works correctly when imported from nested directory structures</li> </ul>"},{"location":"C4-Documentation/c4-component-test-suite/#example-based-documentation","title":"Example-Based Documentation","text":"<ul> <li>Practical Usage Patterns: Integration examples demonstrate real-world usage patterns</li> <li>Feature Demonstration: Shows how to use advanced features like module-specific levels and dedicated loggers</li> <li>Multi-Module Architecture: Examples illustrate logging across multiple modules with proper separation of concerns</li> <li>Configuration Best Practices: Demonstrates proper setup and configuration techniques</li> </ul>"},{"location":"C4-Documentation/c4-component-test-suite/#code-elements","title":"Code Elements","text":"<p>This component contains the following code-level elements:</p> <ul> <li>c4-code-tests.md - Main test suite documentation covering unit tests for core functionality and features, including test_core.py and test_features.py modules</li> <li>c4-code-tests-example.md - Integration examples directory documentation demonstrating practical usage patterns including multi-module logging and caller attribution</li> <li>c4-code-subdir.md - Subdirectory test module documentation validating library behavior when imported from nested locations</li> </ul>"},{"location":"C4-Documentation/c4-component-test-suite/#interfaces","title":"Interfaces","text":""},{"location":"C4-Documentation/c4-component-test-suite/#test-fixtures-pytest-provided","title":"Test Fixtures (pytest-provided)","text":""},{"location":"C4-Documentation/c4-component-test-suite/#caplog-fixture","title":"<code>caplog</code> Fixture","text":"<ul> <li>Protocol: Pytest fixture API</li> <li>Description: Captures log records emitted during test execution</li> <li>Operations:</li> <li><code>caplog.clear()</code> - Clear captured log records</li> <li><code>caplog.records</code> - Access list of captured log records</li> <li><code>caplog.text</code> - Access formatted log output</li> <li>Usage: Used in tests to verify log messages, levels, and formatting</li> </ul>"},{"location":"C4-Documentation/c4-component-test-suite/#capsys-fixture","title":"<code>capsys</code> Fixture","text":"<ul> <li>Protocol: Pytest fixture API</li> <li>Description: Captures stdout and stderr during test execution</li> <li>Operations:</li> <li><code>capsys.readouterr()</code> - Return (stdout, stderr) tuple</li> <li><code>capsys.clear()</code> - Clear captured output</li> <li>Usage: Used to validate console output and JSON logger file output</li> </ul>"},{"location":"C4-Documentation/c4-component-test-suite/#test-functions-interface","title":"Test Functions Interface","text":""},{"location":"C4-Documentation/c4-component-test-suite/#core-test-functions","title":"Core Test Functions","text":"<ul> <li>test_trace_level_registered(): Validates TRACE level registration</li> <li>test_protocol_compliance(): Verifies LoggerProtocol implementation</li> <li>test_test_mode_detection(): Tests test mode detection logic</li> <li>test_logging_calls(caplog): Validates all logging levels work correctly</li> </ul>"},{"location":"C4-Documentation/c4-component-test-suite/#feature-test-functions","title":"Feature Test Functions","text":"<ul> <li>test_module_specific_levels(): Tests module-specific level configuration</li> <li>test_json_logger(capsys): Validates JSON logger output format</li> <li>test_trace_stacklevel(caplog): Tests stacklevel parameter for TRACE level</li> <li>test_caller_attribution(caplog): Tests caller attribution feature</li> </ul>"},{"location":"C4-Documentation/c4-component-test-suite/#integration-example-functions","title":"Integration Example Functions","text":"<ul> <li>main(): Comprehensive feature demonstration in example module</li> <li>do_work(depth: int): Cross-module logging demonstration</li> <li>worker_function(): Nested call attribution example</li> </ul>"},{"location":"C4-Documentation/c4-component-test-suite/#dependencies","title":"Dependencies","text":""},{"location":"C4-Documentation/c4-component-test-suite/#components-tested","title":"Components Tested","text":"<ul> <li>Core Logging Library (arlogi): The primary component under test</li> <li>Tests all public APIs: <code>setup_logging()</code>, <code>get_logger()</code>, <code>get_json_logger()</code>, <code>get_syslog_logger()</code></li> <li>Validates configuration classes and factory methods</li> <li>Verifies protocol compliance and type safety</li> </ul>"},{"location":"C4-Documentation/c4-component-test-suite/#external-testing-dependencies","title":"External Testing Dependencies","text":"<ul> <li>pytest 9.0.2+: Primary testing framework providing test discovery, execution, and reporting</li> <li>pytest-cov 7.0.0+: Coverage reporting plugin generating .coverage and coverage.json files</li> <li>Python Standard Library:</li> <li><code>logging</code>: Base logging module being extended</li> <li><code>json</code>: JSON parsing for validating JSON logger output</li> <li><code>os</code>: Environment variable access for configuration tests</li> </ul>"},{"location":"C4-Documentation/c4-component-test-suite/#internal-module-dependencies","title":"Internal Module Dependencies","text":"<ul> <li>tests/example/worker.py: Worker module providing cross-module logging test scenarios</li> <li>src/arlogi/*: All source modules are imported and tested</li> </ul>"},{"location":"C4-Documentation/c4-component-test-suite/#component-diagram","title":"Component Diagram","text":"<pre><code>C4Component\n    title Component Diagram for arlogi Test Suite\n\n    Container_Boundary(test_suite, \"Test Suite\") {\n        Component(unit_tests, \"Unit Tests\", \"pytest modules\", \"Core functionality and feature tests\")\n        Component(integration_tests, \"Integration Tests\", \"pytest modules + examples\", \"End-to-end usage pattern validation\")\n        Component(test_fixtures, \"Test Fixtures\", \"pytest fixtures\", \"Log capture and output validation\")\n        Component(example_modules, \"Example Modules\", \"Python modules\", \"Practical usage demonstrations\")\n    }\n\n    Container_Boundary(logging_lib, \"arlogi Logging Library\") {\n        Component(core_api, \"Core API\", \"Python module\", \"setup_logging, get_logger\")\n        Component(logger_factory, \"Logger Factory\", \"Python class\", \"Logger creation and test mode detection\")\n        Component(json_logger, \"JSON Logger\", \"Python module\", \"get_json_logger\")\n        Component(syslog_logger, \"Syslog Logger\", \"Python module\", \"get_syslog_logger\")\n    }\n\n    Container_Ext(pytest, \"pytest\", \"Testing framework\")\n    ContainerDb(log_files, \"Log Files\", \"JSON files\", \"Test output logs\")\n\n    Rel(unit_tests, core_api, \"Tests\", \"import &amp; call\")\n    Rel(unit_tests, logger_factory, \"Validates\", \"import &amp; test\")\n    Rel(integration_tests, json_logger, \"Tests\", \"import &amp; validate\")\n    Rel(integration_tests, syslog_logger, \"Tests\", \"import &amp; validate\")\n    Rel(test_fixtures, pytest, \"Uses\", \"fixture API\")\n    Rel(unit_tests, test_fixtures, \"Uses\", \"caplog, capsys\")\n    Rel(integration_tests, test_fixtures, \"Uses\", \"caplog, capsys\")\n    Rel(example_modules, core_api, \"Demonstrates\", \"import &amp; use\")\n    Rel(example_modules, json_logger, \"Demonstrates\", \"import &amp; use\")\n    Rel(integration_tests, log_files, \"Validates\", \"read &amp; verify JSON\")\n    Rel(example_modules, log_files, \"Writes to\", \"JSON output\")\n\n    UpdateRelStyle(unit_tests, core_api, $offsetX=\"-5\", $offsetY=\"-3\")\n    UpdateRelStyle(unit_tests, logger_factory, $offsetX=\"-5\", $offsetY=\"3\")\n    UpdateRelStyle(integration_tests, json_logger, $offsetX=\"5\", $offsetY=\"-3\")\n    UpdateRelStyle(example_modules, core_api, $offsetX=\"5\", $offsetY=\"3\")</code></pre>"},{"location":"C4-Documentation/c4-component-test-suite/#test-coverage-summary","title":"Test Coverage Summary","text":"<p>The Test Suite component provides comprehensive coverage across multiple dimensions:</p>"},{"location":"C4-Documentation/c4-component-test-suite/#coverage-by-feature-area","title":"Coverage by Feature Area","text":"<ul> <li>Core Functionality: 100% - All basic logging operations tested</li> <li>Advanced Features: 95%+ - Module-specific levels, JSON logging, caller attribution validated</li> <li>Integration Patterns: 90%+ - Real-world usage scenarios demonstrated and tested</li> <li>Edge Cases: 85%+ - Subdirectory imports, nested calls, error conditions covered</li> </ul>"},{"location":"C4-Documentation/c4-component-test-suite/#coverage-by-module","title":"Coverage by Module","text":"<ul> <li>Core API: All public functions tested</li> <li>Logger Factory: Test mode detection and factory methods validated</li> <li>Dedicated Loggers: JSON and syslog loggers tested</li> <li>Configuration: Environment-based and programmatic configuration tested</li> </ul>"},{"location":"C4-Documentation/c4-component-test-suite/#test-metrics","title":"Test Metrics","text":"<ul> <li>Total Test Functions: 8 unit tests + 3 integration examples</li> <li>Test Execution Time: &lt; 1 second for full suite</li> <li>Coverage Target: Maintaining &gt; 90% code coverage</li> <li>Test Stability: All tests pass reliably in CI/CD pipeline</li> </ul>"},{"location":"C4-Documentation/c4-component-test-suite/#test-execution","title":"Test Execution","text":"<p>The Test Suite can be executed using standard pytest commands:</p> <pre><code># Run all tests\npytest\n\n# Run with coverage report\npytest --cov=arlogi --cov-report=html --cov-report=term\n\n# Run specific test file\npytest tests/test_core.py\n\n# Run with verbose output\npytest -v\n\n# Run integration examples\npython tests/example/example.py\npython subdir/test_nested.py\n</code></pre>"},{"location":"C4-Documentation/c4-component-test-suite/#notes","title":"Notes","text":"<p>The Test Suite component is organized into three distinct areas:</p> <ol> <li>Unit Tests (tests/test_core.py, tests/test_features.py): Fast, isolated tests validating individual features and functions</li> <li>Integration Examples (tests/example/): Comprehensive demonstrations showing real-world usage patterns across multiple modules</li> <li>Location Tests (subdir/): Validates library behavior from different import locations and directory structures</li> </ol> <p>The test suite follows pytest conventions and uses fixtures for log output capture. Integration examples serve dual purposes as both tests and documentation, demonstrating practical usage patterns that users can reference when implementing logging in their own applications.</p> <p>All tests validate the core logging functionality while examples demonstrate advanced features including environment-based configuration, dedicated loggers, cross-module caller attribution, and module-specific log levels. The test suite ensures the arlogi library maintains high quality and reliability as it evolves.</p>"},{"location":"C4-Documentation/c4-component/","title":"C4 Component Level: System Overview","text":""},{"location":"C4-Documentation/c4-component/#system-components","title":"System Components","text":"<p>The arlogi logging library consists of three main components that work together to provide comprehensive logging functionality, quality assurance, and documentation.</p>"},{"location":"C4-Documentation/c4-component/#core-logging-library","title":"Core Logging Library","text":"<ul> <li>Name: Core Logging Library</li> <li>Description: A modern, feature-rich Python logging library providing structured colored console output, JSON logging, syslog integration, and advanced caller attribution capabilities</li> <li>Documentation: c4-component-core-logging.md</li> <li>Type: Library</li> <li>Technology: Python 3.13+, Rich, Python Standard Library</li> </ul> <p>Key Responsibilities: - Core logging infrastructure and API - Configuration management via LoggingConfig - Logger creation and lifecycle management - Custom handler implementations (ColoredConsole, JSON, Syslog) - Caller attribution and stack inspection - TRACE level logging support</p> <p>Public APIs: - <code>LoggingConfig</code> - Configuration dataclass (Recommended) - <code>LoggerFactory._apply_configuration()</code> - Apply configuration (Recommended) - <code>get_logger()</code> - Get standard logger with caller attribution - <code>get_json_logger()</code> - Get dedicated JSON-only logger - <code>get_syslog_logger()</code> - Get dedicated syslog-only logger - <code>setup_logging()</code> - Legacy configuration helper</p>"},{"location":"C4-Documentation/c4-component/#test-suite","title":"Test Suite","text":"<ul> <li>Name: Test Suite</li> <li>Description: Comprehensive testing infrastructure validating the correctness, reliability, and feature completeness of the arlogi logging library</li> <li>Documentation: c4-component-test-suite.md</li> <li>Type: Test Suite</li> <li>Technology: Python 3.13+, pytest 9.0.2+, pytest-cov 7.0.0+</li> </ul> <p>Key Responsibilities: - Unit testing of core functionality - Feature validation and integration testing - Test coverage measurement and reporting - Practical usage examples and demonstrations - Regression prevention</p> <p>Test Coverage: - Core Functionality: 100% - Advanced Features: 95%+ - Integration Patterns: 90%+ - Edge Cases: 85%+</p>"},{"location":"C4-Documentation/c4-component/#documentation-system","title":"Documentation System","text":"<ul> <li>Name: Documentation System</li> <li>Description: Automated documentation generation, build, and deployment system for the arlogi logging library</li> <li>Documentation: c4-component-documentation.md</li> <li>Type: Documentation Infrastructure</li> <li>Technology: MkDocs, Material Theme, MkDocstrings, Markdown, Python, Bash</li> </ul> <p>Key Responsibilities: - Automatic API documentation generation from source code - Static site building and serving - Documentation deployment to web servers - Developer tools for reference page generation - User and developer guide maintenance</p> <p>Key Features: - Auto-generated API reference from Python docstrings - Modern web interface with search functionality - Mermaid diagram rendering - Automated deployment via SSH/rsync</p>"},{"location":"C4-Documentation/c4-component/#component-relationships","title":"Component Relationships","text":"<p>The three components form a cohesive system with clear dependencies and interactions:</p> <pre><code>C4Component\n    title Component Diagram for arlogi System\n\n    Container_Boundary(system, \"arlogi Logging Library\") {\n        Component(core_lib, \"Core Logging Library\", \"Python Package\", \"Main logging functionality and API\")\n\n        Component(test_suite, \"Test Suite\", \"pytest Tests\", \"Quality assurance and validation\")\n\n        Component(doc_system, \"Documentation System\", \"MkDocs Site\", \"API documentation and user guides\")\n    }\n\n    Person(developer, \"Application Developer\", \"User of the library\")\n    Person(contributor, \"Contributor\", \"Developer contributing to the library\")\n\n    System_Ext(rich, \"Rich Library\", \"Terminal formatting\")\n    System_Ext(pytest, \"pytest Framework\", \"Testing framework\")\n    System_Ext(mkdocs, \"MkDocs\", \"Static site generator\")\n    System_Ext(web_server, \"Web Server\", \"nginx documentation hosting\")\n\n    Rel(developer, core_lib, \"Uses\", \"import &amp; logging\")\n    Rel(contributor, core_lib, \"Develops\", \"contributes code\")\n    Rel(contributor, test_suite, \"Maintains\", \"writes tests\")\n    Rel(contributor, doc_system, \"Updates\", \"writes docs\")\n\n    Rel(test_suite, core_lib, \"Tests\", \"validates functionality\")\n    Rel(doc_system, core_lib, \"Documents\", \"extracts API docs\")\n\n    Rel(core_lib, rich, \"Uses\", \"colored output\")\n    Rel(test_suite, pytest, \"Uses\", \"test framework\")\n    Rel(doc_system, mkdocs, \"Uses\", \"build system\")\n    Rel(doc_system, web_server, \"Deploys to\", \"SSH/rsync\")\n\n    UpdateRelStyle(test_suite, core_lib, $offsetX=\"-3\", $offsetY=\"0\")\n    UpdateRelStyle(doc_system, core_lib, $offsetX=\"3\", $offsetY=\"0\")</code></pre>"},{"location":"C4-Documentation/c4-component/#dependency-graph","title":"Dependency Graph","text":"<pre><code>flowchart TB\n    subgraph \"External Dependencies\"\n        Rich[\"Rich Library\"]\n        Pytest[\"pytest\"]\n        Mkdocs[\"MkDocs\"]\n        MkDocstrings[\"MkDocstrings\"]\n        Material[\"Material Theme\"]\n    end\n\n    subgraph \"arlogi Components\"\n        Core[\"Core Logging Library\"]\n        Tests[\"Test Suite\"]\n        Docs[\"Documentation System\"]\n    end\n\n    subgraph \"Consumers\"\n        Users[\"Application Developers\"]\n        Contributors[\"Contributors\"]\n    end\n\n    Rich --&gt; Core\n    Core --&gt; Tests\n    Core --&gt; Docs\n\n    Pytest --&gt; Tests\n\n    Mkdocs --&gt; Docs\n    MkDocstrings --&gt; Docs\n    Material --&gt; Docs\n\n    Core --&gt; Users\n    Tests --&gt; Contributors\n    Docs --&gt; Users\n    Docs --&gt; Contributors\n\n    style Core fill:#e1f5fe,stroke:#01579b,stroke-width:2px\n    style Tests fill:#f3e5f5,stroke:#4a148c,stroke-width:2px\n    style Docs fill:#fff3e0,stroke:#e65100,stroke-width:2px</code></pre>"},{"location":"C4-Documentation/c4-component/#component-interactions","title":"Component Interactions","text":""},{"location":"C4-Documentation/c4-component/#core-logging-library-interactions","title":"Core Logging Library Interactions","text":"<p>With Test Suite: - Tests \u2192 Core: Import and test all public APIs - Tests \u2192 Core: Validate protocol compliance - Tests \u2192 Core: Verify feature implementations - Tests \u2192 Core: Test configuration and factory methods</p> <p>With Documentation System: - Docs \u2192 Core: Extract docstrings for API reference - Docs \u2192 Core: Analyze type hints for documentation - Docs \u2192 Core: Document module structure and organization - Core \u2192 Docs: Provide source code for documentation generation</p>"},{"location":"C4-Documentation/c4-component/#test-suite-interactions","title":"Test Suite Interactions","text":"<p>With Core Logging Library: - Tests all public functions: <code>get_logger()</code>, <code>get_json_logger()</code>, <code>get_syslog_logger()</code>, <code>setup_logging()</code> (legacy) - Validates configuration classes (<code>LoggingConfig</code>, <code>LoggerFactory</code>) - Verifies protocol compliance and type safety - Tests handler implementations (ColoredConsole, JSON, Syslog) - Validates custom TRACE level functionality</p> <p>With External Systems: - Uses pytest framework for test execution - Uses pytest-cov for coverage reporting - Uses pytest fixtures (caplog, capsys) for output capture</p>"},{"location":"C4-Documentation/c4-component/#documentation-system-interactions","title":"Documentation System Interactions","text":"<p>With Core Logging Library: - Extracts API documentation from Python source code - Generates reference pages for all modules - Creates navigation structure based on module organization - Documents configuration classes and their parameters - Provides usage examples from test suite</p> <p>With External Systems: - Uses MkDocs for static site generation - Uses Material theme for web interface - Uses MkDocstrings for automatic API documentation - Deploys to nginx web server via SSH/rsync - Serves documentation to application developers</p>"},{"location":"C4-Documentation/c4-component/#data-flow","title":"Data Flow","text":"<pre><code>flowchart LR\n    subgraph \"Development Workflow\"\n        Dev[\"Developer writes code\"]\n        Docstrings[\"Add docstrings\"]\n        Tests[\"Write tests\"]\n    end\n\n    subgraph \"Build Process\"\n        Extract[\"MkDocstrings extracts API docs\"]\n        Generate[\"gen_ref_pages.py generates reference\"]\n        Build[\"MkDocs builds site\"]\n        Deploy[\"build_pub.sh deploys\"]\n    end\n\n    subgraph \"Quality Assurance\"\n        RunTests[\"pytest runs tests\"]\n        Coverage[\"Coverage report generated\"]\n    end\n\n    subgraph \"Outputs\"\n        Site[\"Documentation website\"]\n        TestResults[\"Test results\"]\n        APIDocs[\"API reference\"]\n    end\n\n    Dev --&gt; Docstrings\n    Dev --&gt; Tests\n    Docstrings --&gt; Extract\n    Tests --&gt; RunTests\n\n    Extract --&gt; Generate\n    Generate --&gt; Build\n    Build --&gt; Deploy\n    Deploy --&gt; Site\n\n    RunTests --&gt; Coverage\n    Coverage --&gt; TestResults\n\n    Site --&gt; Users[\"Application Developers\"]\n    TestResults --&gt; Contributors[\"Contributors\"]\n\n    style Site fill:#c8e6c9\n    style TestResults fill:#c8e6c9\n    style APIDocs fill:#c8e6c9</code></pre>"},{"location":"C4-Documentation/c4-component/#component-summary-table","title":"Component Summary Table","text":"Component Type Technology Primary Consumers Key Outputs Core Logging Library Library Python 3.13+, Rich Application developers Logging API, log output Test Suite Test Suite Python 3.13+, pytest Contributors Test results, coverage reports Documentation System Infrastructure MkDocs, MkDocstrings Application developers, contributors Documentation website"},{"location":"C4-Documentation/c4-component/#cross-component-concerns","title":"Cross-Component Concerns","text":""},{"location":"C4-Documentation/c4-component/#quality-assurance","title":"Quality Assurance","text":"<ul> <li>Test Suite validates Core Logging Library functionality</li> <li>Test coverage metrics ensure reliability of Core Library</li> <li>Integration examples in Test Suite inform Documentation content</li> </ul>"},{"location":"C4-Documentation/c4-component/#documentation-synchronization","title":"Documentation Synchronization","text":"<ul> <li>Documentation System automatically extracts API docs from Core Logging Library</li> <li>Test examples from Test Suite demonstrate usage patterns documented by Documentation System</li> <li>All three components evolve together to maintain consistency</li> </ul>"},{"location":"C4-Documentation/c4-component/#development-workflow","title":"Development Workflow","text":"<ol> <li>Contributors modify Core Logging Library</li> <li>Test Suite validates changes and prevents regressions</li> <li>Documentation System regenerates API documentation from updated code</li> <li>All changes reviewed together in version control</li> </ol>"},{"location":"C4-Documentation/c4-component/#release-coordination","title":"Release Coordination","text":"<ul> <li>Core Library version bump triggers Test Suite validation</li> <li>Documentation version matches Core Library version</li> <li>All components released together as a unified package</li> </ul>"},{"location":"C4-Documentation/c4-component/#technology-stack-summary","title":"Technology Stack Summary","text":""},{"location":"C4-Documentation/c4-component/#core-technologies","title":"Core Technologies","text":"<ul> <li>Python 3.13+: Primary language for all components</li> <li>Rich: Terminal formatting (Core Library)</li> <li>pytest: Test framework (Test Suite)</li> <li>MkDocs: Documentation generator (Documentation)</li> </ul>"},{"location":"C4-Documentation/c4-component/#supporting-technologies","title":"Supporting Technologies","text":"<ul> <li>pytest-cov: Coverage reporting</li> <li>MkDocstrings: API documentation extraction</li> <li>Material Theme: Documentation web interface</li> <li>SSH/rsync: Documentation deployment</li> </ul>"},{"location":"C4-Documentation/c4-component/#development-tools","title":"Development Tools","text":"<ul> <li>Python Standard Library: logging, json, dataclasses, typing, etc.</li> <li>Bash: Deployment automation scripts</li> <li>Markdown: Documentation authoring</li> <li>Mermaid: Architecture diagrams</li> </ul>"},{"location":"C4-Documentation/c4-component/#related-documentation","title":"Related Documentation","text":"<ul> <li>Core Logging Library - Detailed component documentation</li> <li>Test Suite - Testing infrastructure documentation</li> <li> <p>Documentation System - Documentation system details</p> </li> <li> <p>C4 Context - System-level architecture overview</p> </li> <li>C4 Container - Container-level architecture</li> <li>Code Documentation - Implementation details</li> </ul> <p>Document Information - Last Updated: 2025-12-28 - C4 Level: Component - Scope: All components in the arlogi system - Purpose: Master index and overview of all system components</p>"},{"location":"C4-Documentation/c4-container/","title":"C4 Container Level: arlogi System Deployment","text":""},{"location":"C4-Documentation/c4-container/#overview","title":"Overview","text":"<p>The arlogi system is organized into three main deployment containers that separate concerns between the core library functionality, quality assurance, and documentation. Each container represents a distinct deployable unit with specific technologies, deployment methods, and responsibilities.</p>"},{"location":"C4-Documentation/c4-container/#container-diagram","title":"Container Diagram","text":"<pre><code>C4Container\n    title Container Diagram for arlogi Logging Library System\n\n    Person(developer, \"Application Developer\", \"Uses the logging library in applications\")\n    Person(user, \"Documentation User\", \"Reads API documentation and user guides\")\n\n    System_Boundary(arlogi_system, \"arlogi Logging Library System\") {\n        Container(python_package, \"Python Package\", \"Python 3.13+, Rich Library\", \"Deployable Python package providing logging functionality\")\n        Container(test_suite, \"Test Suite\", \"pytest 9.0.2+, pytest-cov 7.0.0+\", \"Comprehensive test infrastructure validating library functionality\")\n        Container(docs_site, \"Documentation Site\", \"MkDocs, Material Theme, MkDocstrings\", \"Static documentation website with API reference\")\n    }\n\n    ContainerDb(log_files, \"JSON Log Files\", \"JSONL format\", \"Structured log output files\")\n\n    System_Ext(pypi, \"PyPI Package Repository\", \"Python package index\")\n    System_Ext(web_server, \"nginx Web Server\", \"Static web hosting\")\n    System_Ext(rich, \"Rich Library\", \"Terminal formatting\")\n    System_Ext(syslog, \"Syslog Daemon\", \"System logging service\")\n\n    Rel(developer, python_package, \"Installs from\", \"pip install\")\n    Rel(developer, test_suite, \"Runs\", \"pytest\")\n    Rel(developer, docs_site, \"Consults\", \"HTTP/HTTPS\")\n    Rel(user, docs_site, \"Browses\", \"HTTP/HTTPS\")\n\n    Rel(python_package, rich, \"Uses\", \"Python dependency\")\n    Rel(python_package, syslog, \"Writes to\", \"Unix socket/UDP\")\n    Rel(python_package, log_files, \"Generates\", \"JSON output\")\n    Rel(test_suite, python_package, \"Tests\", \"import &amp; validate\")\n    Rel(docs_site, python_package, \"Documents\", \"Source code analysis\")\n\n    Rel(python_package, pypi, \"Published to\", \"uv publish/hatchling\")\n    Rel(docs_site, web_server, \"Deployed to\", \"SSH/rsync\")\n\n    UpdateRelStyle(python_package, pypi, $offsetX=\"3\", $offsetY=\"2\")\n    UpdateRelStyle(docs_site, web_server, $offsetX=\"-3\", $offsetY=\"2\")</code></pre>"},{"location":"C4-Documentation/c4-container/#containers","title":"Containers","text":""},{"location":"C4-Documentation/c4-container/#1-python-package-container","title":"1. Python Package Container","text":""},{"location":"C4-Documentation/c4-container/#container-information","title":"Container Information","text":"<ul> <li>Name: Python Package (arlogi)</li> <li>Description: Deployable Python package providing enhanced logging functionality with colored console output, structured JSON logging, syslog integration, and caller attribution</li> <li>Type: Python Package / Library</li> <li>Technology: Python 3.13+, Rich 14.2.0+, Python Standard Library</li> <li>Deployment: PyPI (Python Package Index), via pip or uv package managers</li> <li>Version: 0.512.28</li> </ul>"},{"location":"C4-Documentation/c4-container/#purpose","title":"Purpose","text":"<p>The Python Package container is the primary deployment unit of the arlogi system. It contains all the core logging functionality that application developers import and use in their applications. This container is designed to be:</p> <ol> <li>Installable: Can be installed from PyPI using standard Python package managers</li> <li>Importable: Provides a clean Python module API that developers can import</li> <li>Configurable: Supports multiple configuration methods (programmatic, environment-based)</li> <li>Extensible: Allows custom handlers, formatters, and log levels</li> <li>Production-Ready: Includes error handling, graceful fallbacks, and performance optimizations</li> </ol> <p>The container solves the problem of inadequate Python logging by providing a drop-in replacement for the standard logging module with enhanced features for modern application development.</p>"},{"location":"C4-Documentation/c4-container/#components","title":"Components","text":"<p>This container deploys the following component:</p> <p>Core Logging Library - The complete logging infrastructure</p> <ul> <li>Configuration Management (LoggingConfig, HandlerFactory)</li> <li>Logger Factory (LoggerFactory, TraceLogger)</li> <li>Handler Implementations (ColoredConsoleHandler, JSONHandler, JSONFileHandler, ArlogiSyslogHandler)</li> <li>Type Definitions (LoggerProtocol, custom TRACE level)</li> <li>Public API Functions (get_logger, get_json_logger, get_syslog_logger)</li> <li>Legacy Helpers (setup_logging)</li> </ul>"},{"location":"C4-Documentation/c4-container/#interfaces","title":"Interfaces","text":""},{"location":"C4-Documentation/c4-container/#python-module-api","title":"Python Module API","text":"<p>Protocol: Python module-level import interface Description: High-level convenience functions for application developers Specification: apis/arlogi-api.yaml</p> <p>Endpoints:</p> <ul> <li><code>arlogi.LoggingConfig</code> - Configuration dataclass</li> <li><code>arlogi.LoggerFactory</code> - Logger factory class</li> <li><code>arlogi.get_logger(name, level=None)</code> - Get standard logger</li> <li><code>arlogi.get_json_logger(name, json_file_name=None)</code> - Get JSON-only logger</li> <li><code>arlogi.get_syslog_logger(name, address=\"/dev/log\")</code> - Get syslog-only logger</li> <li><code>arlogi.setup_logging(**kwargs)</code> - Legacy configuration helper</li> <li><code>arlogi.HandlerFactory</code> - Handler factory class</li> <li><code>arlogi.TRACE</code> - Custom TRACE log level constant</li> </ul>"},{"location":"C4-Documentation/c4-container/#json-output-interface","title":"JSON Output Interface","text":"<p>Protocol: JSON Lines (JSONL) format Description: Structured log format for log aggregation systems Specification: API Reference - JSON Output Format</p> <p>Schema:</p> <pre><code>{\n  \"timestamp\": \"string (ISO 8601)\",\n  \"level\": \"string (level name)\",\n  \"message\": \"string (log message)\",\n  \"file\": \"string (file path)\",\n  \"line\": \"number (line number)\",\n  \"function\": \"string (function name)\",\n  \"caller\": \"string | null (caller function)\",\n  \"extra\": \"object (custom fields)\"\n}\n</code></pre>"},{"location":"C4-Documentation/c4-container/#syslog-interface","title":"Syslog Interface","text":"<p>Protocol: Unix Domain Socket or UDP Description: Standard syslog integration for enterprise logging Specification: API Reference - ArlogiSyslogHandler</p> <p>Endpoints:</p> <ul> <li><code>/dev/log</code> - Unix domain socket (primary)</li> <li><code>localhost:514</code> - UDP fallback (secondary)</li> <li>Custom host/port tuple - Remote syslog server</li> </ul>"},{"location":"C4-Documentation/c4-container/#dependencies","title":"Dependencies","text":"<p>Container Dependencies: None (standalone library)</p> <p>External Systems:</p> <ul> <li>Rich Library (14.2.0+): Terminal formatting and colored console output</li> <li>Used for: ColoredConsoleHandler, Rich rendering</li> <li>License: MIT</li> <li> <p>Website: https://github.com/Textualize/rich</p> </li> <li> <p>Python Standard Library:</p> </li> <li><code>logging</code>: Base logging framework</li> <li><code>dataclasses</code>: Configuration immutability</li> <li><code>json</code>: JSON log formatting</li> <li><code>os</code>, <code>sys</code>: System integration</li> <li><code>datetime</code>: Timestamp generation</li> <li> <p><code>pathlib</code>: Path manipulation</p> </li> <li> <p>Syslog Daemon (optional): System logging service</p> </li> <li>Integration: Unix socket (/dev/log) or UDP</li> <li>Fallback: Graceful degradation when unavailable</li> </ul>"},{"location":"C4-Documentation/c4-container/#infrastructure","title":"Infrastructure","text":"<p>Deployment Configuration:</p> <ul> <li>Package Config: <code>pyproject.toml</code></li> <li>Build System: hatchling (Python build backend)</li> <li>Package Manager: uv (recommended) or pip</li> <li>Source Layout: <code>src/arlogi/</code> directory structure</li> <li>Distribution Format: Wheel (.whl) and Source (.tar.gz)</li> </ul> <p>Build Commands:</p> <pre><code># Build package\nuv build\n\n# Publish to PyPI\nuv publish\n\n# Install from PyPI\nuv add arlogi\n# or\npip install arlogi\n\n# Install from local source\nuv pip install -e .\n</code></pre> <p>Scaling:</p> <ul> <li>Type: Library package (no scaling required)</li> <li>Deployment: Installed into application environment</li> <li>Isolation: Application-level import boundaries</li> </ul> <p>Resource Requirements:</p> <ul> <li>Python: 3.13+ required</li> <li>Memory: Minimal (only when logging)</li> <li>Storage: Configurable for JSON file handlers</li> <li>Network: Optional (for remote syslog)</li> </ul>"},{"location":"C4-Documentation/c4-container/#2-test-suite-container","title":"2. Test Suite Container","text":""},{"location":"C4-Documentation/c4-container/#container-information_1","title":"Container Information","text":"<ul> <li>Name: Test Suite</li> <li>Description: Comprehensive pytest-based testing infrastructure ensuring library correctness, reliability, and feature completeness</li> <li>Type: Test Suite / Quality Assurance</li> <li>Technology: Python 3.13+, pytest 9.0.2+, pytest-cov 7.0.0+</li> <li>Deployment: Local development machine, CI/CD pipeline</li> <li>Coverage Target: &gt; 90%</li> </ul>"},{"location":"C4-Documentation/c4-container/#purpose_1","title":"Purpose","text":"<p>The Test Suite container provides quality assurance for the arlogi system by:</p> <ol> <li>Validating Correctness: Ensures all logging operations work as specified</li> <li>Preventing Regressions: Catches breaking changes during development</li> <li>Demonstrating Usage: Integration examples serve as practical documentation</li> <li>Enabling Confidence: Allows rapid iteration with test-backed safety</li> <li>Measuring Coverage: Tracks test coverage to ensure comprehensive validation</li> </ol> <p>This container is essential for maintaining code quality and reliability as the library evolves, providing a safety net for refactoring and new feature development.</p>"},{"location":"C4-Documentation/c4-container/#components_1","title":"Components","text":"<p>This container deploys the following component:</p> <p>Test Suite - Quality assurance infrastructure</p> <ul> <li>Unit Tests (tests/test_core.py, tests/test_features.py)</li> <li>Integration Examples (tests/example/example.py, tests/example/worker.py)</li> <li>Test Fixtures (pytest caplog, capsys)</li> <li>Coverage Reporting (pytest-cov with .coverage and coverage.json output)</li> </ul>"},{"location":"C4-Documentation/c4-container/#interfaces_1","title":"Interfaces","text":""},{"location":"C4-Documentation/c4-container/#command-line-interface","title":"Command Line Interface","text":"<p>Protocol: Shell commands Description: Execute tests and generate coverage reports</p> <p>Commands:</p> <pre><code># Run all tests\npytest\n\n# Run with coverage\npytest --cov=arlogi --cov-report=html --cov-report=term\n\n# Run specific test file\npytest tests/test_core.py\n\n# Run with verbose output\npytest -v\n\n# Run integration example\npython tests/example/example.py\n</code></pre>"},{"location":"C4-Documentation/c4-container/#test-result-interface","title":"Test Result Interface","text":"<p>Protocol: Console output + HTML reports Description: Test execution results and coverage metrics</p> <p>Outputs:</p> <ul> <li>Console: Test progress, pass/fail status, assertion details</li> <li>.coverage: Coverage database (binary format)</li> <li>coverage.json: Coverage metrics in JSON format</li> <li>htmlcov/: HTML coverage report (with --cov-report=html)</li> </ul>"},{"location":"C4-Documentation/c4-container/#dependencies_1","title":"Dependencies","text":"<p>Container Dependencies:</p> <ul> <li>Python Package Container: The primary component under test</li> <li>Imports all arlogi modules</li> <li>Tests all public APIs</li> <li>Validates protocol compliance</li> </ul> <p>External Systems:</p> <ul> <li>pytest 9.0.2+: Testing framework</li> <li>Test discovery and execution</li> <li>Fixture support (caplog, capsys)</li> <li> <p>Assertion and reporting</p> </li> <li> <p>pytest-cov 7.0.0+: Coverage plugin</p> </li> <li>Code coverage measurement</li> <li> <p>Multiple report formats (term, html, json)</p> </li> <li> <p>Python Standard Library:</p> </li> <li><code>logging</code>: For testing logging behavior</li> <li><code>json</code>: For validating JSON log output</li> <li><code>os</code>: For environment variable tests</li> </ul>"},{"location":"C4-Documentation/c4-container/#infrastructure_1","title":"Infrastructure","text":"<p>Deployment Configuration:</p> <ul> <li>Test Config: pytest.ini (uses default pytest discovery)</li> <li>Coverage Config: .coveragerc (or pyproject.toml [tool.coverage] section)</li> <li>Test Files: <code>tests/</code> directory with <code>test_*.py</code> pattern</li> <li>CI/CD Integration: Can be integrated into GitHub Actions, GitLab CI, etc.</li> </ul> <p>Execution Commands:</p> <pre><code># Run tests\nuv run pytest\n\n# Run with coverage\nuv run pytest --cov=arlogi --cov-report=html --cov-report=term\n\n# Generate coverage badge\nuv run pytest --cov=arlogi --cov-report=json\n</code></pre> <p>Scaling:</p> <ul> <li>Type: Test suite (no scaling required)</li> <li>Execution: Local or CI/CD pipeline</li> <li>Parallelization: pytest-xdist can be added for parallel test execution</li> </ul> <p>Resource Requirements:</p> <ul> <li>Python: 3.13+ required</li> <li>Memory: Minimal (test execution only)</li> <li>Storage: For coverage reports and HTML output</li> <li>Execution Time: &lt; 1 second for full suite</li> </ul> <p>Test Organization:</p> <pre><code>tests/\n\u251c\u2500\u2500 test_core.py              # Core functionality tests\n\u251c\u2500\u2500 test_features.py          # Feature implementation tests\n\u251c\u2500\u2500 example/\n\u2502   \u251c\u2500\u2500 example.py           # Integration demonstration\n\u2502   \u2514\u2500\u2500 worker.py            # Cross-module logging example\n\u2514\u2500\u2500 conftest.py              # Shared pytest fixtures (if needed)\n</code></pre>"},{"location":"C4-Documentation/c4-container/#3-documentation-site-container","title":"3. Documentation Site Container","text":""},{"location":"C4-Documentation/c4-container/#container-information_2","title":"Container Information","text":"<ul> <li>Name: Documentation Site</li> <li>Description: Automated documentation generation and static website deployment providing API reference, user guides, and architectural documentation</li> <li>Type: Static Website / Documentation Infrastructure</li> <li>Technology: MkDocs 1.5+, Material Theme 9.7.1+, MkDocstrings 1.0+, Python 3.10+</li> <li>Deployment: nginx web server at http://192.168.168.5/cpaiops/</li> <li>Build Output: Static HTML/CSS/JS in <code>site/</code> directory</li> </ul>"},{"location":"C4-Documentation/c4-container/#purpose_2","title":"Purpose","text":"<p>The Documentation Site container serves as the bridge between the library's source code and its users by:</p> <ol> <li>Auto-Generating API Docs: Extracts API documentation from Python docstrings using MkDocstrings</li> <li>Providing User Guides: Offers conceptual documentation for library users</li> <li>Documenting Architecture: Includes C4 diagrams and design documentation</li> <li>Enabling Search: Provides full-text search across all documentation</li> <li>Supporting Offline Use: Static site can be viewed without internet access</li> <li>Simplifying Maintenance: Automated generation keeps docs synchronized with code</li> </ol> <p>This container ensures that users have access to comprehensive, up-to-date documentation that stays synchronized with code changes.</p>"},{"location":"C4-Documentation/c4-container/#components_2","title":"Components","text":"<p>This container deploys the following component:</p> <p>Documentation System - Documentation infrastructure</p> <ul> <li>Reference Page Generator (<code>docs/scripts/gen_ref_pages.py</code>)</li> <li>MkDocs Builder (<code>mkdocs build</code>, <code>mkdocs serve</code>)</li> <li>API Reference Docs (<code>docs/reference/*.md</code>)</li> <li>User Documentation (<code>docs/*.md</code>)</li> <li>Deployment Scripts (<code>docs/scripts/build_pub.sh</code>)</li> </ul>"},{"location":"C4-Documentation/c4-container/#interfaces_2","title":"Interfaces","text":""},{"location":"C4-Documentation/c4-container/#command-line-interface_1","title":"Command Line Interface","text":"<p>Protocol: Shell commands Description: Build, serve, and deploy documentation</p> <p>Commands:</p> <pre><code># Generate API reference pages\npython docs/scripts/gen_ref_pages.py\n\n# Build documentation site\nmkdocs build\n\n# Serve locally for development\nmkdocs serve\n\n# Deploy to remote server\n./docs/scripts/build_pub.sh\n</code></pre>"},{"location":"C4-Documentation/c4-container/#web-interface","title":"Web Interface","text":"<p>Protocol: HTTP/HTTPS Description: User-facing documentation website Access: http://192.168.168.5/cpaiops/ (production) or http://localhost:8000 (development)</p> <p>Features:</p> <ul> <li>Browse API reference by module</li> <li>Full-text search across all documentation</li> <li>Hierarchical navigation menu</li> <li>View Mermaid architecture diagrams</li> <li>Copy code examples with one click</li> <li>Mobile-responsive design</li> </ul>"},{"location":"C4-Documentation/c4-container/#dependencies_2","title":"Dependencies","text":"<p>Container Dependencies:</p> <ul> <li>Python Package Container: Source code being documented</li> <li>All modules in <code>src/arlogi/</code> are analyzed</li> <li>Docstrings are extracted for API documentation</li> <li>Type hints are preserved in documentation</li> </ul> <p>External Systems:</p> <ul> <li>MkDocs 1.5+: Static site generator</li> <li>Markdown processing</li> <li>Site generation</li> <li> <p>Plugin management</p> </li> <li> <p>Material Theme: Modern documentation theme</p> </li> <li>Responsive design</li> <li>Search functionality</li> <li> <p>Navigation components</p> </li> <li> <p>MkDocstrings 1.0+: Automatic API documentation</p> </li> <li>Docstring extraction</li> <li>Type hint handling</li> <li> <p>Cross-referencing</p> </li> <li> <p>PyMdownX Extensions: Advanced Markdown features</p> </li> <li>Syntax highlighting</li> <li>Mermaid diagram rendering</li> <li> <p>SuperFences for custom blocks</p> </li> <li> <p>nginx Web Server: Production hosting</p> </li> <li>Static file serving</li> <li>HTTP/HTTPS support</li> <li>Document root: <code>/opt/c/nginx/html/arlogi</code></li> </ul>"},{"location":"C4-Documentation/c4-container/#infrastructure_2","title":"Infrastructure","text":"<p>Deployment Configuration:</p> <ul> <li>MkDocs Config: <code>mkdocs.yml</code></li> <li>Custom CSS: <code>extra.css</code></li> <li>Source Files: <code>docs/</code> directory with markdown files</li> <li>Build Output: <code>site/</code> directory (static HTML)</li> <li>Remote Server: 192.168.168.5 via SSH/rsync</li> </ul> <p>Build Commands:</p> <pre><code># Generate API reference\npython docs/scripts/gen_ref_pages.py\n\n# Build site\nmkdocs build\n\n# Serve locally (development)\nmkdocs serve\n\n# Deploy to production\ndocs/scripts/build_pub.sh\n</code></pre> <p>Scaling:</p> <ul> <li>Type: Static website (no server-side processing)</li> <li>CDN: Can be distributed via CDN for global performance</li> <li>Hosting: Can be deployed to any static hosting service (GitHub Pages, Netlify, etc.)</li> </ul> <p>Resource Requirements:</p> <ul> <li>Build Time: ~5-10 seconds</li> <li>Site Size: ~1-2 MB (static files)</li> <li>Server Requirements: Any web server capable of serving static files</li> <li>Bandwidth: Minimal (static assets can be cached)</li> </ul> <p>Documentation Structure:</p> <pre><code>docs/\n\u251c\u2500\u2500 index.md                  # Home page\n\u251c\u2500\u2500 USER_GUIDE.md             # User guide\n\u251c\u2500\u2500 DEVELOPER_GUIDE.md        # Developer guide\n\u251c\u2500\u2500 API_REFERENCE.md          # Complete API reference\n\u251c\u2500\u2500 CONFIGURATION_GUIDE.md    # Configuration options\n\u251c\u2500\u2500 ARCHITECTURE.md           # Architecture overview\n\u251c\u2500\u2500 extra.css                 # Custom styling\n\u251c\u2500\u2500 reference/                # Auto-generated API docs\n\u2502   \u2514\u2500\u2500 arlogi/\n\u2502       \u251c\u2500\u2500 config.md\n\u2502       \u251c\u2500\u2500 factory.md\n\u2502       \u251c\u2500\u2500 handlers.md\n\u2502       \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 scripts/                  # Documentation tools\n\u2502   \u251c\u2500\u2500 gen_ref_pages.py     # API reference generator\n\u2502   \u2514\u2500\u2500 build_pub.sh         # Deployment script\n\u2514\u2500\u2500 C4-Documentation/         # C4 architecture docs\n    \u251c\u2500\u2500 c4-context.md\n    \u251c\u2500\u2500 c4-container.md\n    \u2514\u2500\u2500 ...\n</code></pre> <p>Technology Stack:</p> <ul> <li>MkDocs: Core static site generator</li> <li>Material for MkDocs: Theme with search and navigation</li> <li>MkDocstrings: API documentation from Python code</li> <li>PyMdown Extensions: Markdown enhancements (syntax highlighting, Mermaid)</li> <li>Python 3.10+: Script execution for doc generation</li> <li>Bash: Deployment automation</li> <li>OpenSSH/rsync: Secure file transfer</li> <li>nginx: Production web server</li> </ul>"},{"location":"C4-Documentation/c4-container/#inter-container-communication","title":"Inter-Container Communication","text":""},{"location":"C4-Documentation/c4-container/#python-package-test-suite","title":"Python Package \u2192 Test Suite","text":"<p>Protocol: Python import and function calls Description: Test suite imports and validates all Python Package functionality Data Flow:</p> <ol> <li>Test suite imports arlogi modules</li> <li>Tests call public APIs with various parameters</li> <li>Tests validate output via caplog and capsys fixtures</li> <li>Coverage data is collected and reported</li> </ol>"},{"location":"C4-Documentation/c4-container/#python-package-documentation-site","title":"Python Package \u2192 Documentation Site","text":"<p>Protocol: Source code analysis and docstring extraction Description: Documentation generator reads Python source to create API reference Data Flow:</p> <ol> <li>gen_ref_pages.py scans <code>src/arlogi/</code> directory</li> <li>Extracts classes, functions, and docstrings using regex</li> <li>Creates markdown files with MkDocstrings directives</li> <li>MkDocs builds static HTML from markdown</li> <li>Site is deployed to nginx web server</li> </ol>"},{"location":"C4-Documentation/c4-container/#developer-all-containers","title":"Developer \u2192 All Containers","text":"<p>Protocol: Various (pip, pytest, HTTP) Description: Developers interact with all containers during development workflow Workflow:</p> <ol> <li>Install Python Package: <code>uv add arlogi</code></li> <li>Use in application: <code>from arlogi import get_logger</code></li> <li>Run tests: <code>pytest</code> (validates Test Suite)</li> <li>Read docs: Browse documentation site for API reference</li> </ol>"},{"location":"C4-Documentation/c4-container/#deployment-patterns","title":"Deployment Patterns","text":""},{"location":"C4-Documentation/c4-container/#development-workflow","title":"Development Workflow","text":"<pre><code>flowchart LR\n    Dev[Developer] --&gt;|Write Code| Src[Source Code]\n    Src --&gt;|Generate Docs| Gen[gen_ref_pages.py]\n    Gen --&gt;|Create Markdown| Ref[API Reference]\n    Ref --&gt;|Build| MkDocs[MkDocs Build]\n    MkDocs --&gt;|Create| Site[Static Site]\n\n    Src --&gt;|Test| Pytest[pytest]\n    Pytest --&gt;|Validate| Tests[Test Results]\n\n    Dev --&gt;|Install| Package[Python Package]\n    Dev --&gt;|Browse| Site</code></pre>"},{"location":"C4-Documentation/c4-container/#production-deployment","title":"Production Deployment","text":"<ol> <li>Python Package Deployment:</li> </ol> <pre><code>uv build  # Create .whl and .tar.gz\nuv publish  # Upload to PyPI\n</code></pre> <ol> <li>Documentation Deployment:</li> </ol> <pre><code>python docs/scripts/gen_ref_pages.py  # Generate API docs\nmkdocs build  # Build static site\ndocs/scripts/build_pub.sh  # Deploy to nginx\n</code></pre> <ol> <li>Test Execution:</li> <li>Local: <code>uv run pytest</code></li> <li>CI/CD: Integrated into GitHub Actions or similar</li> </ol>"},{"location":"C4-Documentation/c4-container/#technology-choices-rationale","title":"Technology Choices Rationale","text":""},{"location":"C4-Documentation/c4-container/#python-package-container","title":"Python Package Container","text":"<p>Python 3.13+: Latest Python version with modern features</p> <ul> <li>Pattern matching, type hint improvements, better error messages</li> </ul> <p>Rich 14.2.0+: Best-in-class terminal formatting</p> <ul> <li>Beautiful colored output, tables, progress bars</li> <li>Wide adoption and active maintenance</li> </ul> <p>Hatchling: Modern Python build backend</p> <ul> <li>Fast, reliable, PEP 517 compliant</li> <li>Zero-configuration for simple projects</li> </ul>"},{"location":"C4-Documentation/c4-container/#test-suite-container","title":"Test Suite Container","text":"<p>pytest 9.0.2+: De facto standard Python testing framework</p> <ul> <li>Powerful fixture system, assert introspection, plugin ecosystem</li> <li>Superior to unittest for modern Python testing</li> </ul> <p>pytest-cov 7.0.0+: Coverage plugin for pytest</p> <ul> <li>Seamless integration, multiple report formats</li> <li>Tracks coverage trends over time</li> </ul>"},{"location":"C4-Documentation/c4-container/#documentation-site-container","title":"Documentation Site Container","text":"<p>MkDocs: Fast, simple static site generator</p> <ul> <li>Markdown-based, Python-native, large plugin ecosystem</li> <li>Easier to use than Sphinx for documentation-focused sites</li> </ul> <p>Material Theme: Most popular MkDocs theme</p> <ul> <li>Beautiful design, built-in search, responsive</li> <li>Extensive customization options</li> </ul> <p>MkDocstrings: Automatic API documentation</p> <ul> <li>Extracts docstrings, handles type hints, supports cross-references</li> <li>Better than manual API documentation maintenance</li> </ul>"},{"location":"C4-Documentation/c4-container/#cross-cutting-concerns","title":"Cross-Cutting Concerns","text":""},{"location":"C4-Documentation/c4-container/#configuration-management","title":"Configuration Management","text":"<p>All containers support configuration:</p> <ul> <li>Python Package: LoggingConfig dataclass, environment variables</li> <li>Test Suite: pytest.ini, command-line arguments</li> <li>Documentation Site: mkdocs.yml, custom CSS</li> </ul>"},{"location":"C4-Documentation/c4-container/#error-handling","title":"Error Handling","text":"<ul> <li>Python Package: Graceful syslog fallback, validation errors</li> <li>Test Suite: pytest assertion handling, fixture cleanup</li> <li>Documentation Site: Build error reporting, YAML validation</li> </ul>"},{"location":"C4-Documentation/c4-container/#versioning","title":"Versioning","text":"<ul> <li>Python Package: Semantic versioning (0.512.28)</li> <li>Test Suite: Version-locked to Python Package</li> <li>Documentation Site: Version-specific documentation</li> </ul>"},{"location":"C4-Documentation/c4-container/#security","title":"Security","text":"<ul> <li>Python Package: No external network calls (except optional syslog)</li> <li>Test Suite: No security concerns (local execution)</li> <li>Documentation Site: Static files (no server-side execution), SSH key auth for deployment</li> </ul>"},{"location":"C4-Documentation/c4-container/#summary","title":"Summary","text":"<p>The arlogi system is organized into three containers that each serve distinct purposes:</p> <ol> <li>Python Package: The core library deployed to PyPI for application developers</li> <li>Test Suite: Quality assurance ensuring library correctness and reliability</li> <li>Documentation Site: Auto-generated documentation deployed to a web server</li> </ol> <p>Each container uses appropriate technologies for its purpose and has well-defined interfaces for communication with other containers and external systems. The containers support independent development, testing, and deployment while working together to provide a complete, high-quality logging library for Python developers.</p>"},{"location":"C4-Documentation/c4-context/","title":"C4 Context Level: System Context","text":""},{"location":"C4-Documentation/c4-context/#system-overview","title":"System Overview","text":""},{"location":"C4-Documentation/c4-context/#short-description","title":"Short Description","text":"<p>Arlogi is a robust, type-safe Python logging library that provides enhanced colored console output, structured JSON logging, syslog integration, and advanced caller attribution capabilities for modern application development.</p>"},{"location":"C4-Documentation/c4-context/#long-description","title":"Long Description","text":"<p>Arlogi extends Python's standard logging module with modern features designed to solve the problem of inadequate logging capabilities in production applications. The system provides a custom TRACE log level (level 5) for ultra-detailed debugging, premium colored console output using the Rich library, structured JSON logging for log aggregation systems, and enterprise-grade syslog integration. The library's unique caller attribution feature allows developers to trace log calls across function boundaries using depth parameters (from_, from_caller, or **{\"from\": depth}), making it easier to understand the flow of complex applications. Arlogi is designed as a drop-in replacement for the standard logging module while maintaining full backward compatibility, prioritizing modern type-safe configuration objects (LoggingConfig) and provides legacy support for simple helper functions (setup_logging). The system ensures test-mode awareness for seamless pytest integration and follows SOLID principles for maintainability and clear separation of concerns.</p>"},{"location":"C4-Documentation/c4-context/#personas","title":"Personas","text":""},{"location":"C4-Documentation/c4-context/#application-developer","title":"Application Developer","text":"<ul> <li>Type: Human User</li> <li>Description: Python developers building applications, APIs, microservices, or scripts who need production-ready logging capabilities beyond what the standard logging module provides</li> <li>Goals:</li> <li>Quickly set up professional logging with minimal configuration</li> <li>Add colored console output for better development experience</li> <li>Implement structured JSON logging for log aggregation systems (ELK, Splunk, etc.)</li> <li>Use caller attribution to trace log messages through complex call stacks</li> <li>Configure module-specific log levels for different parts of the application</li> <li>Integrate with enterprise syslog infrastructure</li> <li>Maintain backward compatibility with existing logging code</li> <li>Key Features Used:</li> <li>LoggingConfig for type-safe configuration (Primary)</li> <li>get_logger() for standard logging with caller attribution</li> <li>get_json_logger() for structured JSON output</li> <li>get_syslog_logger() for enterprise integration</li> <li>Module-specific log levels</li> <li>Custom TRACE log level</li> <li>setup_logging() for legacy configuration support</li> </ul>"},{"location":"C4-Documentation/c4-context/#library-developer","title":"Library Developer","text":"<ul> <li>Type: Human User</li> <li>Description: Python developers creating reusable libraries or frameworks that need to provide logging capabilities while respecting the consuming application's logging configuration</li> <li>Goals:</li> <li>Add logging to library code without forcing configuration on users</li> <li>Use caller attribution to show meaningful context (caller's function) rather than library internals</li> <li>Support the TRACE level for ultra-detailed library debugging</li> <li>Ensure logging works regardless of when the library is imported</li> <li>Provide lazy initialization patterns for logging</li> <li>Key Features Used:</li> <li>get_logger() for library logging</li> <li>Caller attribution with from_=1 to show caller context</li> <li>TRACE level for detailed debugging</li> <li>Lazy logger initialization with LoggerProtocol</li> <li>Safe logging patterns that work with or without arlogi setup</li> </ul>"},{"location":"C4-Documentation/c4-context/#qatesting-engineer","title":"QA/Testing Engineer","text":"<ul> <li>Type: Human User</li> <li>Description: Quality assurance engineers and testers who run automated tests and need to verify application behavior through log output</li> <li>Goals:</li> <li>Run tests without log output cluttering test results</li> <li>Capture and validate log messages during test execution</li> <li>Use pytest fixtures (caplog, capsys) effectively</li> <li>Verify correct log levels and messages in tests</li> <li>Test application behavior without interference from logging configuration</li> <li>Key Features Used:</li> <li>Automatic test mode detection</li> <li>DEBUG default level in test environments</li> <li>Compatibility with pytest caplog and capsys fixtures</li> <li>No handler addition in test mode (prevents double logging)</li> <li>Test mode detection via is_test_mode()</li> </ul>"},{"location":"C4-Documentation/c4-context/#devops-engineer","title":"DevOps Engineer","text":"<ul> <li>Type: Human User</li> <li>Description: Operations engineers responsible for deploying, monitoring, and maintaining applications in production environments</li> <li>Goals:</li> <li>Collect and aggregate logs from multiple application instances</li> <li>Parse structured JSON logs for monitoring and alerting</li> <li>Integrate with centralized logging infrastructure (syslog, ELK stack, Splunk)</li> <li>Configure appropriate log levels for different environments</li> <li>Monitor application health through log analysis</li> <li>Key Features Used:</li> <li>Structured JSON logging (JSONHandler, JSONFileHandler)</li> <li>Syslog integration (ArlogiSyslogHandler)</li> <li>Environment variable configuration (ARLOGI_LEVEL, LOG_LEVEL)</li> <li>Module-specific log levels for fine-grained control</li> <li>JSON log format with timestamps, level names, and source information</li> </ul>"},{"location":"C4-Documentation/c4-context/#documentation-user","title":"Documentation User","text":"<ul> <li>Type: Human User</li> <li>Description: Developers reading API documentation, user guides, and examples to learn how to use the arlogi library effectively</li> <li>Goals:</li> <li>Understand the library's capabilities and features</li> <li>Find API reference documentation for all functions and classes</li> <li>Learn from practical examples and usage patterns</li> <li>Access architecture diagrams and design documentation</li> <li>Get troubleshooting guidance for common issues</li> <li>Key Features Used:</li> <li>MkDocs documentation website</li> <li>API reference with auto-generated documentation</li> <li>User guides and tutorials</li> <li>Example code and integration patterns</li> <li>C4 architecture diagrams</li> </ul>"},{"location":"C4-Documentation/c4-context/#contributormaintainer","title":"Contributor/Maintainer","text":"<ul> <li>Type: Human User</li> <li>Description: Developers contributing to the arlogi codebase, maintaining the library, and releasing new versions</li> <li>Goals:</li> <li>Understand the codebase architecture and design patterns</li> <li>Add new features while maintaining backward compatibility</li> <li>Write comprehensive tests for new functionality</li> <li>Generate and update API documentation</li> <li>Release new versions to PyPI</li> <li>Review and merge pull requests</li> <li>Key Features Used:</li> <li>Test suite with pytest</li> <li>Source code architecture</li> <li>Documentation generation tools (MkDocs, MkDocstrings)</li> <li>C4 architecture documentation</li> <li>Development workflow and contribution guidelines</li> </ul>"},{"location":"C4-Documentation/c4-context/#system-features","title":"System Features","text":""},{"location":"C4-Documentation/c4-context/#enhanced-colored-console-output","title":"Enhanced Colored Console Output","text":"<ul> <li>Description: Provides beautiful, readable colored console logs using the Rich library with automatic traceback support, configurable level colors, and clean formatting options</li> <li>Users: Application Developer, Library Developer</li> <li>User Journey: Application Developer - Basic Logging Journey</li> <li>User Journey: Application Developer - JSON Logging Journey</li> <li>User Journey: Application Developer - TRACE Logging Journey</li> <li>User Journey: Library Developer - Caller Attribution Journey</li> <li>User Journey: Application Developer - Module Configuration Journey</li> <li>User Journey: DevOps Engineer - Syslog Integration Journey</li> <li>User Journey: Application Developer - Dedicated Logger Journey</li> <li>User Journey: Application Developer - Advanced Configuration Journey</li> <li>User Journey: QA/Testing Engineer - Test Mode Journey</li> <li>User Journey: Documentation User - API Reference Journey</li> </ul>"},{"location":"C4-Documentation/c4-context/#user-journeys","title":"User Journeys","text":""},{"location":"C4-Documentation/c4-context/#application-developer-basic-logging-journey","title":"Application Developer - Basic Logging Journey","text":"<p>Persona: Application Developer</p> <ol> <li>Installation: Developer installs arlogi using pip or uv package manager</li> <li>Command: <code>pip install arlogi</code> or <code>uv add arlogi</code></li> <li> <p>System: PyPI Package Repository \u2192 Python Package</p> </li> <li> <p>Import and Setup: Developer imports arlogi and configures logging using the modern configuration pattern</p> </li> </ol> <pre><code>from arlogi import LoggingConfig, LoggerFactory, get_logger\nconfig = LoggingConfig(level=\"INFO\")\nLoggerFactory._apply_configuration(config)\n</code></pre> <ul> <li> <p>System: Python Package (LoggingConfig, LoggerFactory)</p> </li> <li> <p>Create Logger: Developer obtains a logger instance</p> </li> </ul> <pre><code>logger = get_logger(__name__)\n</code></pre> <ul> <li> <p>System: Python Package (get_logger function)</p> </li> <li> <p>Log Messages: Developer logs messages with automatic colored output</p> </li> </ul> <pre><code>logger.info(\"Application started\")\nlogger.warning(\"Configuration file not found\")\nlogger.error(\"Failed to connect to database\")\n</code></pre> <ul> <li> <p>System: Python Package \u2192 ColoredConsoleHandler \u2192 Terminal</p> </li> <li> <p>View Output: Developer sees beautifully formatted colored console output with level indicators and file paths</p> </li> </ul>"},{"location":"C4-Documentation/c4-context/#application-developer-json-logging-journey","title":"Application Developer - JSON Logging Journey","text":"<p>Persona: Application Developer, DevOps Engineer</p> <ol> <li>Setup with JSON: Developer configures logging with JSON file output</li> </ol> <pre><code>setup_logging(\n    level=\"INFO\",\n    json_file_name=\"logs/app.jsonl\"\n)\n</code></pre> <ul> <li> <p>System: Python Package \u2192 JSONFileHandler \u2192 JSON Log Files</p> </li> <li> <p>Log with Structured Data: Developer logs messages with extra fields</p> </li> </ul> <pre><code>logger.info(\"User logged in\", extra={\"user_id\": 123, \"ip\": \"192.168.1.1\"})\n</code></pre> <ol> <li>View JSON Output: Developer views structured JSON log file</li> <li> <p>System: JSON Log Files (JSONL format with timestamp, level, message, logger_name, module, function, line_number, and extra fields)</p> </li> <li> <p>Integrate with Log Aggregation: DevOps engineer configures log aggregation system (ELK, Splunk) to parse JSON logs</p> </li> </ol>"},{"location":"C4-Documentation/c4-context/#library-developer-caller-attribution-journey","title":"Library Developer - Caller Attribution Journey","text":"<p>Persona: Library Developer, Application Developer</p> <ol> <li>Create Library with Logging: Developer creates a utility function in a library module</li> </ol> <pre><code># app/utils.py\nfrom arlogi import get_logger\n\nlogger = get_logger(__name__)\n\ndef fetch_user(user_id):\n    logger.info(\"Fetching user\", from_=1)  # Show caller, not this function\n    # ... fetch logic\n    return user\n</code></pre> <ol> <li>Call from Application: Application code calls the library function</li> </ol> <pre><code># app/main.py\nfrom app.utils import fetch_user\n\ndef handle_request(user_id):\n    user = fetch_user(user_id)  # Log shows: [from handle_request()]\n</code></pre> <ol> <li> <p>View Attribution: Developer sees log output showing the calling function (handle_request) rather than the library function (fetch_user)</p> </li> <li> <p>Deep Stack Tracing: Developer uses deeper attribution for complex call stacks</p> </li> </ol> <pre><code>logger.debug(\"Processing\", from_=2)  # Show caller's caller\n</code></pre>"},{"location":"C4-Documentation/c4-context/#application-developer-trace-logging-journey","title":"Application Developer - TRACE Logging Journey","text":"<p>Persona: Application Developer, Library Developer</p> <ol> <li>Import TRACE Level: Developer imports the custom TRACE level</li> </ol> <pre><code>from arlogi import get_logger, TRACE\n</code></pre> <ol> <li>Use TRACE Logs: Developer adds ultra-detailed logging</li> </ol> <pre><code>logger.trace(\"Variable x = %s, y = %s\", x, y, from_=0)\nlogger.trace(\"Entering function complex_calculation\")\nlogger.trace(\"Step 1: Initialize\", from_=1)\nlogger.trace(\"Step 2: Validate inputs\")\nlogger.trace(\"Step 3: Perform calculation\")\nlogger.trace(\"Exiting function complex_calculation\")\n</code></pre> <ol> <li>Configure TRACE Level: Developer enables TRACE level for specific modules</li> </ol> <pre><code>setup_logging(\n    level=\"INFO\",\n    module_levels={\"app.complex\": \"TRACE\"}\n)\n</code></pre> <ul> <li> <p>System: Python Package \u2192 TRACE level registration (logging.addLevelName)</p> </li> <li> <p>Enable for Debugging: Developer temporarily sets global level to TRACE for debugging</p> </li> </ul> <pre><code>setup_logging(level=\"TRACE\")  # Show ALL logs including TRACE\n</code></pre>"},{"location":"C4-Documentation/c4-context/#application-developer-module-configuration-journey","title":"Application Developer - Module Configuration Journey","text":"<p>Persona: Application Developer, DevOps Engineer</p> <ol> <li>Plan Module Structure: Developer identifies modules needing different log levels</li> <li>app.database: Needs verbose logging (DEBUG)</li> <li>app.network: Needs ultra-detailed tracing (TRACE)</li> <li>app.security: Only warnings and errors (WARNING)</li> <li> <p>app.api: Standard logging (INFO)</p> </li> <li> <p>Configure Module Levels: Developer sets up module-specific configuration</p> </li> </ol> <pre><code>setup_logging(\n    level=\"INFO\",\n    module_levels={\n        \"app.database\": \"DEBUG\",\n        \"app.network\": \"TRACE\",\n        \"app.security\": \"WARNING\"\n    }\n)\n</code></pre> <ul> <li> <p>System: Python Package \u2192 LoggingConfig \u2192 LoggerFactory._configure_module_levels()</p> </li> <li> <p>Create Loggers: Developer creates loggers for each module</p> </li> </ul> <pre><code>db_logger = get_logger(\"app.database\")\nnet_logger = get_logger(\"app.network\")\nsec_logger = get_logger(\"app.security\")\napi_logger = get_logger(\"app.api\")\n</code></pre> <ol> <li>Verify Levels: Developer logs messages at different levels and verifies output matches configuration</li> <li>net_logger.trace() \u2192 Shows (TRACE enabled)</li> <li>db_logger.trace() \u2192 Hidden (only DEBUG enabled)</li> <li>sec_logger.info() \u2192 Hidden (only WARNING+ enabled)</li> <li>api_logger.info() \u2192 Shows (INFO enabled)</li> </ol>"},{"location":"C4-Documentation/c4-context/#application-developer-dedicated-logger-journey","title":"Application Developer - Dedicated Logger Journey","text":"<p>Persona: Application Developer, DevOps Engineer</p> <ol> <li>Identify Use Case: Developer needs separate log for audit trail (not shown in console)</li> <li>Use case: Security audit logs sent to dedicated JSON file</li> <li> <p>Requirements: No console output, structured JSON, separate file</p> </li> <li> <p>Create Dedicated JSON Logger: Developer creates JSON-only logger</p> </li> </ol> <pre><code>from arlogi import get_json_logger\n\naudit_logger = get_json_logger(\"audit\", \"logs/audit.jsonl\")\n</code></pre> <ul> <li> <p>System: Python Package \u2192 get_json_logger() \u2192 JSONFileHandler (bypasses root handlers)</p> </li> <li> <p>Log to Dedicated Destination: Developer logs audit events</p> </li> </ul> <pre><code>audit_logger.info(\"User logged in\", extra={\"user_id\": 123, \"ip\": \"192.168.1.1\"})\naudit_logger.warning(\"Privilege escalation attempt\", extra={\"user_id\": 456})\n</code></pre> <ol> <li> <p>Verify Output: Developer verifies console remains clean while audit.jsonl contains structured logs</p> </li> <li> <p>Create Dedicated Syslog Logger: Developer creates syslog-only logger for security events</p> </li> </ol> <pre><code>from arlogi import get_syslog_logger\n\nsecurity_logger = get_syslog_logger(\"security\")\nsecurity_logger.critical(\"Brute force attack detected\", extra={\"ip\": \"10.0.0.50\"})\n</code></pre> <ul> <li>System: Python Package \u2192 get_syslog_logger() \u2192 ArlogiSyslogHandler \u2192 Syslog Daemon</li> </ul>"},{"location":"C4-Documentation/c4-context/#application-developer-advanced-configuration-journey","title":"Application Developer - Advanced Configuration Journey","text":"<p>Persona: Application Developer, Contributor</p> <ol> <li>Modern Configuration Pattern: Developer uses LoggingConfig dataclass for type safety (Recommended)</li> </ol> <pre><code>from arlogi import LoggingConfig, LoggerFactory\n\nconfig = LoggingConfig(\n    level=\"INFO\",\n    module_levels={\"app.db\": \"DEBUG\"},\n    json_file_name=\"logs/app.jsonl\",\n    show_time=True\n)\n</code></pre> <ul> <li> <p>System: Python Package \u2192 LoggingConfig (immutable dataclass)</p> </li> <li> <p>Apply Configuration: Developer applies configuration to logging system</p> </li> </ul> <pre><code>LoggerFactory._apply_configuration(config)\n</code></pre> <ul> <li> <p>System: Python Package \u2192 LoggerFactory._apply_configuration()</p> </li> <li> <p>Validate Configuration: Developer benefits from automatic validation</p> </li> <li>Invalid log levels raise ValueError</li> <li>Type hints ensure correct parameter types</li> <li> <p>Immutable configuration prevents accidental modification</p> </li> <li> <p>Convert Configuration: Developer can serialize/deserialize configuration</p> </li> </ul> <pre><code>config_dict = config.to_dict()\n# ... save to file, environment, etc.\nnew_config = LoggingConfig.from_kwargs(**config_dict)\n</code></pre>"},{"location":"C4-Documentation/c4-context/#qatesting-engineer-test-mode-journey","title":"QA/Testing Engineer - Test Mode Journey","text":"<p>Persona: QA/Testing Engineer, Application Developer</p> <ol> <li>Write Tests: Developer writes tests using pytest</li> </ol> <pre><code>import pytest\nfrom arlogi import get_logger\n\ndef test_application_logic():\n    logger = get_logger(__name__)\n    logger.info(\"Test started\")\n    # ... test code\n    logger.info(\"Test completed\")\n</code></pre> <ol> <li>Automatic Test Mode Detection: System detects pytest environment</li> <li>System: Python Package \u2192 is_test_mode() \u2192 Checks for pytest in sys.modules</li> <li> <p>Result: Test mode = True</p> </li> <li> <p>Automatic Configuration: System adjusts for test mode</p> </li> <li>Default level: DEBUG (instead of INFO)</li> <li>No handlers added to root logger (prevents double logging)</li> <li> <p>Seamless integration with pytest caplog fixture</p> </li> <li> <p>Use pytest Fixtures: Developer uses caplog to capture logs</p> </li> </ol> <pre><code>def test_log_output(caplog):\n    logger = get_logger(__name__)\n    logger.info(\"Test message\")\n\n    assert \"Test message\" in caplog.text\n    assert caplog.records[0].levelname == \"INFO\"\n</code></pre> <ol> <li>Verify Logs: Developer verifies log messages and levels in tests</li> </ol>"},{"location":"C4-Documentation/c4-context/#devops-engineer-syslog-integration-journey","title":"DevOps Engineer - Syslog Integration Journey","text":"<p>Persona: DevOps Engineer, Application Developer</p> <ol> <li>Setup Syslog: DevOps engineer ensures syslog daemon is running</li> <li>System: Syslog Daemon (rsyslog, syslog-ng, etc.)</li> <li> <p>Default socket: /dev/log (Unix) or /var/run/syslog (macOS)</p> </li> <li> <p>Enable Syslog in Application: Developer configures syslog output</p> </li> </ol> <pre><code>setup_logging(\n    level=\"INFO\",\n    use_syslog=True,\n    syslog_address=\"/dev/log\"\n)\n</code></pre> <ul> <li> <p>System: Python Package \u2192 ArlogiSyslogHandler \u2192 Unix socket \u2192 Syslog Daemon</p> </li> <li> <p>Log Messages: Application logs normally, syslog handler forwards to syslog daemon</p> </li> </ul> <pre><code>logger.info(\"Application event\")\nlogger.error(\"Application error\")\n</code></pre> <ol> <li>Configure Remote Syslog: DevOps engineer configures remote syslog server</li> </ol> <pre><code>setup_logging(\n    syslog_address=(\"syslog.example.com\", 514)\n)\n</code></pre> <ul> <li> <p>System: ArlogiSyslogHandler \u2192 UDP \u2192 Remote Syslog Server</p> </li> <li> <p>Automatic Fallback: System gracefully handles syslog unavailability</p> </li> <li>Try: Unix socket (/dev/log)</li> <li>Fallback 1: UDP on localhost:514</li> <li> <p>Fallback 2: Silent (no errors, application continues)</p> </li> <li> <p>Monitor Logs: DevOps engineer views logs in syslog dashboard or SIEM tool</p> </li> </ul>"},{"location":"C4-Documentation/c4-context/#documentation-user-api-reference-journey","title":"Documentation User - API Reference Journey","text":"<p>Persona: Documentation User, Contributor</p> <ol> <li>Access Documentation: User navigates to documentation website</li> <li>System: Documentation Site (MkDocs) \u2192 Web Browser</li> <li> <p>URL: http://192.168.168.5/cpaiops/ (production) or http://localhost:8000 (development)</p> </li> <li> <p>Browse API Reference: User clicks \"API Reference\" in navigation menu</p> </li> <li>System: Documentation Site \u2192 API Reference Page</li> <li> <p>Content: Auto-generated from Python docstrings</p> </li> <li> <p>Search for Function: User uses search box to find specific function</p> </li> <li>Example: Search \"get_logger\" \u2192 Shows get_logger() documentation</li> <li> <p>System: MkDocs Material Theme \u2192 Full-text search</p> </li> <li> <p>Read Documentation: User reads comprehensive API documentation</p> </li> <li>Function signature with type hints</li> <li>Parameter descriptions</li> <li>Return value documentation</li> <li>Usage examples</li> <li> <p>Related functions</p> </li> <li> <p>View Examples: User navigates to examples section</p> </li> <li>Code snippets demonstrating real-world usage</li> <li>Integration patterns with third-party libraries</li> <li> <p>Common use cases and best practices</p> </li> <li> <p>Access Architecture: User views C4 architecture diagrams</p> </li> <li>System: Documentation Site \u2192 Architecture Documentation</li> <li>Mermaid diagrams showing system context, containers, components</li> </ol>"},{"location":"C4-Documentation/c4-context/#contributor-documentation-generation-journey","title":"Contributor - Documentation Generation Journey","text":"<p>Persona: Contributor, Maintainer</p> <ol> <li>Write Code with Docstrings: Contributor adds Python code with comprehensive docstrings</li> </ol> <pre><code>def get_logger(name: str, level: int | str | None = None) -&gt; LoggerProtocol:\n    \"\"\"Get a logger instance with caller attribution support.\n\n    Args:\n        name: Logger name (typically __name__)\n        level: Optional level override\n\n    Returns:\n        A logger instance implementing LoggerProtocol\n\n    Examples:\n        &gt;&gt;&gt; logger = get_logger(\"my_app\")\n        &gt;&gt;&gt; logger.info(\"Hello\")\n    \"\"\"\n</code></pre> <ul> <li> <p>System: Python Package Source Code</p> </li> <li> <p>Generate API Reference: Contributor runs documentation generation script</p> </li> </ul> <pre><code>python docs/scripts/gen_ref_pages.py\n</code></pre> <ul> <li> <p>System: gen_ref_pages.py \u2192 Scans src/arlogi/ \u2192 Extracts classes/functions/docstrings \u2192 Creates markdown files</p> </li> <li> <p>Build Documentation Site: Contributor builds static HTML documentation</p> </li> </ul> <pre><code>mkdocs build\n</code></pre> <ul> <li> <p>System: MkDocs \u2192 Reads markdown files \u2192 Runs MkDocstrings \u2192 Generates static HTML</p> </li> <li> <p>Serve Locally: Contributor previews documentation locally</p> </li> </ul> <pre><code>mkdocs serve\n</code></pre> <ul> <li> <p>System: MkDocs dev server \u2192 http://localhost:8000</p> </li> <li> <p>Deploy to Production: Contributor deploys documentation to web server</p> </li> </ul> <pre><code>docs/scripts/build_pub.sh\n</code></pre> <ul> <li> <p>System: build_pub.sh \u2192 rsync \u2192 nginx Web Server (192.168.168.5)</p> </li> <li> <p>Verify Deployment: Contributor verifies documentation is accessible at production URL</p> </li> </ul>"},{"location":"C4-Documentation/c4-context/#external-systems-and-dependencies","title":"External Systems and Dependencies","text":""},{"location":"C4-Documentation/c4-context/#rich-library","title":"Rich Library","text":"<ul> <li>Type: Python Dependency (Third-Party Library)</li> <li>Description: Terminal formatting library providing beautiful colored console output, tables, progress bars, and rich text rendering capabilities</li> <li>Integration Type: Python dependency (import and use)</li> <li>Purpose: Used by ColoredConsoleHandler to render premium colored console output with automatic traceback support, level indicators, and formatted messages. Without Rich, arlogi would fall back to basic console output or require an alternative formatting solution.</li> </ul>"},{"location":"C4-Documentation/c4-context/#python-standard-library-logging-module","title":"Python Standard Library (logging module)","text":"<ul> <li>Type: Standard Library</li> <li>Description: Python's built-in logging framework providing the foundation for all logging functionality</li> <li>Integration Type: Core dependency (extension and subclassing)</li> <li>Purpose: Arlogi extends the standard logging module by adding custom levels, handlers, and formatters. All arlogi loggers inherit from logging.Logger, ensuring compatibility with existing code and third-party libraries that use standard logging.</li> </ul>"},{"location":"C4-Documentation/c4-context/#syslog-daemon","title":"Syslog Daemon","text":"<ul> <li>Type: System Service (External System)</li> <li>Description: Unix/Linux system logging service (rsyslog, syslog-ng, or macOS syslog) responsible for collecting and distributing log messages</li> <li>Integration Type: Client-Server (Unix socket or UDP)</li> <li>Purpose: ArlogiSyslogHandler sends log messages to the syslog daemon via Unix domain socket (/dev/log) or UDP (localhost:514). Enables integration with enterprise logging infrastructure and centralized log management systems. Arlogi includes automatic fallback if syslog is unavailable.</li> </ul>"},{"location":"C4-Documentation/c4-context/#pypi-python-package-index","title":"PyPI (Python Package Index)","text":"<ul> <li>Type: Package Repository (External System)</li> <li>Description: The official software repository for the Python programming language</li> <li>Integration Type: Publishing/Consuming (via pip or uv)</li> <li>Purpose: Python Package container is published to PyPI, allowing application developers to install arlogi using standard package managers (pip install arlogi or uv add arlogi). Enables distribution and version management of the library.</li> </ul>"},{"location":"C4-Documentation/c4-context/#pytest-testing-framework","title":"pytest (Testing Framework)","text":"<ul> <li>Type: Development Tool (External System)</li> <li>Description: Mature full-featured Python testing framework with powerful fixtures and assertion introspection</li> <li>Integration Type: Test execution environment</li> <li>Purpose: Test Suite container uses pytest for test discovery, execution, and reporting. Pytest fixtures (caplog, capsys) are used to capture and validate log output. Arlogi automatically detects pytest to enable test mode (DEBUG default level, no handler addition).</li> </ul>"},{"location":"C4-Documentation/c4-context/#pytest-cov-coverage-plugin","title":"pytest-cov (Coverage Plugin)","text":"<ul> <li>Type: Development Tool (External System)</li> <li>Description: Pytest plugin for measuring code coverage</li> <li>Integration Type: Test reporting plugin</li> <li>Purpose: Test Suite uses pytest-cov to generate coverage reports (.coverage, coverage.json, HTML reports) tracking how much of the arlogi codebase is tested. Ensures quality and identifies untested code.</li> </ul>"},{"location":"C4-Documentation/c4-context/#mkdocs-static-site-generator","title":"MkDocs (Static Site Generator)","text":"<ul> <li>Type: Documentation Tool (External System)</li> <li>Description: Fast, simple static site generator perfect for building project documentation</li> <li>Integration Type: Documentation build system</li> <li>Purpose: Documentation Site container uses MkDocs to build the documentation website from markdown files. Processes markdown, generates navigation, and creates static HTML output for deployment.</li> </ul>"},{"location":"C4-Documentation/c4-context/#material-theme-for-mkdocs","title":"Material Theme for MkDocs","text":"<ul> <li>Type: Documentation Theme (External System)</li> <li>Description: Popular, feature-rich documentation theme for MkDocs with search, navigation, and responsive design</li> <li>Integration Type: MkDocs theme plugin</li> <li>Purpose: Provides the web interface for documentation website with search functionality, hierarchical navigation, mobile responsiveness, and professional styling. Improves user experience for documentation readers.</li> </ul>"},{"location":"C4-Documentation/c4-context/#mkdocstrings-api-documentation-tool","title":"MkDocstrings (API Documentation Tool)","text":"<ul> <li>Type: Documentation Tool (External System)</li> <li>Description: Automatic API documentation generation from Python docstrings and type hints</li> <li>Integration Type: Documentation generation plugin</li> <li>Purpose: Automatically extracts API documentation from Python source code (docstrings, type hints, function signatures) and generates markdown reference pages. Keeps documentation synchronized with code changes.</li> </ul>"},{"location":"C4-Documentation/c4-context/#nginx-web-server","title":"nginx Web Server","text":"<ul> <li>Type: Web Server (External System)</li> <li>Description: High-performance HTTP server and reverse proxy</li> <li>Integration Type: Static file hosting</li> <li>Purpose: Documentation Site container deploys static HTML documentation to nginx web server at http://192.168.168.5/cpaiops/. Serves documentation files to users via HTTP/HTTPS. Enables public or internal access to documentation.</li> </ul>"},{"location":"C4-Documentation/c4-context/#sshrsync-deployment-tools","title":"SSH/rsync (Deployment Tools)","text":"<ul> <li>Type: Network Protocol/File Transfer (External System)</li> <li>Description: Secure Shell protocol and rsync file synchronization utility</li> <li>Integration Type: Remote file transfer</li> <li>Purpose: build_pub.sh script uses SSH/rsync to deploy documentation site to remote nginx server. Securely transfers files from development machine to production web server. Enables automated documentation deployment.</li> </ul>"},{"location":"C4-Documentation/c4-context/#json-log-files","title":"JSON Log Files","text":"<ul> <li>Type: File Storage (External System)</li> <li>Description: Structured log files in JSON Lines (JSONL) format for persistent log storage</li> <li>Integration Type: File I/O</li> <li>Purpose: JSONFileHandler writes structured log entries to files in JSONL format. Each line is a valid JSON object with timestamp, level, message, logger name, source location, and extra fields. Enables log aggregation, parsing, and analysis by external tools (ELK, Splunk, etc.).</li> </ul>"},{"location":"C4-Documentation/c4-context/#terminalconsole","title":"Terminal/Console","text":"<ul> <li>Type: User Interface (External System)</li> <li>Description: Command-line terminal or console where application output is displayed</li> <li>Integration Type: Output stream (stdout/stderr)</li> <li>Purpose: ColoredConsoleHandler renders formatted log messages to the terminal using Rich library. Provides real-time feedback to developers and operators during application execution. Supports colors, formatting, and tracebacks.</li> </ul>"},{"location":"C4-Documentation/c4-context/#filesystem","title":"Filesystem","text":"<ul> <li>Type: Operating System Service (External System)</li> <li>Description: Operating system file management for creating, writing, and managing log files</li> <li>Integration Type: File I/O</li> <li>Purpose: JSONFileHandler creates log files, writes entries, and manages file handles. System creates parent directories automatically, handles file permissions, and manages file rotation (manual or external). Enables persistent log storage for later analysis.</li> </ul>"},{"location":"C4-Documentation/c4-context/#system-context-diagram","title":"System Context Diagram","text":"<pre><code>C4Context\n    title System Context Diagram for arlogi Logging Library\n\n    Person(app_dev, \"Application Developer\", \"Develops applications and APIs using arlogi\")\n    Person(lib_dev, \"Library Developer\", \"Creates libraries with arlogi logging\")\n    Person(qa_eng, \"QA/Testing Engineer\", \"Tests applications with arlogi\")\n    Person(devops_eng, \"DevOps Engineer\", \"Deploys and monitors applications\")\n    Person(doc_user, \"Documentation User\", \"Reads API documentation and guides\")\n    Person(contributor, \"Contributor/Maintainer\", \"Contributes to arlogi codebase\")\n\n    System(arlogi, \"arlogi Logging Library\", \"Provides enhanced logging with colored output, JSON logging, syslog integration, and caller attribution\")\n\n    System_Ext(pypi, \"PyPI Package Repository\", \"Python package index\")\n    System_Ext(rich, \"Rich Library\", \"Terminal formatting library\")\n    System_Ext(syslog, \"Syslog Daemon\", \"System logging service\")\n    System_Ext(nginx, \"nginx Web Server\", \"Documentation hosting\")\n\n    SystemDb(json_logs, \"JSON Log Files\", \"Structured log output files\")\n    System_Ext(terminal, \"Terminal/Console\", \"Command-line interface\")\n    System_Ext(pytest, \"pytest Framework\", \"Testing framework\")\n\n    Rel(app_dev, arlogi, \"Uses\", \"pip install, import, logging\")\n    Rel(lib_dev, arlogi, \"Uses\", \"caller attribution, TRACE level\")\n    Rel(qa_eng, arlogi, \"Tests with\", \"pytest, test mode\")\n    Rel(devops_eng, arlogi, \"Configures\", \"JSON, syslog, monitoring\")\n    Rel(doc_user, nginx, \"Reads docs from\", \"HTTP/HTTPS\")\n    Rel(contributor, arlogi, \"Contributes to\", \"code, tests, docs\")\n\n    Rel(arlogi, pypi, \"Published to\", \"uv publish\")\n    Rel(arlogi, rich, \"Uses\", \"colored console output\")\n    Rel(arlogi, syslog, \"Integrates with\", \"Unix socket/UDP\")\n    Rel(arlogi, json_logs, \"Writes to\", \"JSONL format\")\n    Rel(arlogi, terminal, \"Outputs to\", \"formatted logs\")\n    Rel(contributor, pytest, \"Runs tests with\", \"pytest\")\n    Rel(contributor, nginx, \"Deploys docs to\", \"SSH/rsync\")\n\n    UpdateRelStyle(doc_user, nginx, $offsetY=\"-2\")\n    UpdateRelStyle(contributor, nginx, $offsetY=\"2\")</code></pre>"},{"location":"C4-Documentation/c4-context/#related-documentation","title":"Related Documentation","text":"<ul> <li>Container Documentation - Deployment architecture and container-level details</li> <li>Component Documentation - Component structure and component interactions</li> <li>Core Logging Library Component - Core logging functionality details</li> <li>Test Suite Component - Testing infrastructure documentation</li> <li>Documentation System Component - Documentation generation and deployment</li> </ul> <p>Document Information</p> <ul> <li>Last Updated: 2025-12-28</li> <li>C4 Level: Context</li> <li>Scope: System-level overview with personas, features, user journeys, and external dependencies</li> <li>Purpose: Provide stakeholder-friendly system context focusing on people and software systems rather than technical implementation details</li> </ul>"},{"location":"reference/arlogi/config/","title":"Config","text":"<p>Logging configuration dataclass for type-safe setup.</p> <p>This module provides a structured, validated configuration for logging setup, following the Builder pattern for flexible construction.</p>"},{"location":"reference/arlogi/config/#arlogi.config.LoggingConfig","title":"LoggingConfig  <code>dataclass</code>","text":"<pre><code>LoggingConfig(\n    level: int | str = logging.INFO,\n    module_levels: dict[str, str | int] | None = None,\n    json_file_name: str | None = None,\n    json_file_only: bool = False,\n    use_syslog: bool = False,\n    syslog_address: str | tuple[str, int] = \"/dev/log\",\n    show_time: bool = False,\n    show_level: bool = True,\n    show_path: bool = True,\n)\n</code></pre> <p>Immutable configuration for arlogi logging setup.</p> <p>Attributes:</p> Name Type Description <code>level</code> <code>int | str</code> <p>Global root log level (int or string like \"INFO\")</p> <code>module_levels</code> <code>dict[str, str | int] | None</code> <p>Per-module level overrides (e.g., {\"app.db\": \"DEBUG\"})</p> <code>json_file_name</code> <code>str | None</code> <p>Path to JSON log file (None for no JSON file logging)</p> <code>json_file_only</code> <code>bool</code> <p>If True, only output to JSON (no console)</p> <code>use_syslog</code> <code>bool</code> <p>Enable syslog output</p> <code>syslog_address</code> <code>str | tuple[str, int]</code> <p>Syslog server address (default: \"/dev/log\")</p> <code>show_time</code> <code>bool</code> <p>Show timestamps in console output</p> <code>show_level</code> <code>bool</code> <p>Show log levels in console output</p> <code>show_path</code> <code>bool</code> <p>Show file paths in console output</p>"},{"location":"reference/arlogi/config/#arlogi.config.LoggingConfig.has_json_output","title":"has_json_output  <code>property</code>","text":"<pre><code>has_json_output: bool\n</code></pre> <p>Determine if JSON output is configured.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if JSON file or JSON-only output is enabled</p>"},{"location":"reference/arlogi/config/#arlogi.config.LoggingConfig.resolved_level","title":"resolved_level  <code>property</code>","text":"<pre><code>resolved_level: int\n</code></pre> <p>Get the global level as an integer.</p> <p>Returns:</p> Type Description <code>int</code> <p>The resolved log level as an integer</p>"},{"location":"reference/arlogi/config/#arlogi.config.LoggingConfig.show_console","title":"show_console  <code>property</code>","text":"<pre><code>show_console: bool\n</code></pre> <p>Determine if console output should be shown.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if console output should be displayed</p>"},{"location":"reference/arlogi/config/#arlogi.config.LoggingConfig.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Validate configuration after initialization.</p> Source code in <code>src/arlogi/config.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Validate configuration after initialization.\"\"\"\n    # Validate level\n    self._validate_level(self.level)\n\n    # Validate module levels if provided\n    if self.module_levels:\n        for name, m_level in self.module_levels.items():\n            if not isinstance(name, str) or not name:\n                raise ValueError(f\"Invalid module name: {name!r}\")\n            self._validate_level(m_level)\n</code></pre>"},{"location":"reference/arlogi/config/#arlogi.config.LoggingConfig.from_kwargs","title":"from_kwargs  <code>classmethod</code>","text":"<pre><code>from_kwargs(**kwargs: Any) -&gt; LoggingConfig\n</code></pre> <p>Create LoggingConfig from keyword arguments.</p> <p>This factory method provides backward compatibility with the legacy setup_logging() function signature.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Configuration keyword arguments</p> <code>{}</code> <p>Returns:</p> Type Description <code>LoggingConfig</code> <p>A new LoggingConfig instance</p> Example <p>config = LoggingConfig.from_kwargs( ...     level=\"INFO\", ...     module_levels={\"app.db\": \"DEBUG\"}, ...     json_file_name=\"logs/app.jsonl\" ... )</p> Source code in <code>src/arlogi/config.py</code> <pre><code>@classmethod\ndef from_kwargs(cls, **kwargs: Any) -&gt; \"LoggingConfig\":\n    \"\"\"Create LoggingConfig from keyword arguments.\n\n    This factory method provides backward compatibility with the\n    legacy setup_logging() function signature.\n\n    Args:\n        **kwargs: Configuration keyword arguments\n\n    Returns:\n        A new LoggingConfig instance\n\n    Example:\n        &gt;&gt;&gt; config = LoggingConfig.from_kwargs(\n        ...     level=\"INFO\",\n        ...     module_levels={\"app.db\": \"DEBUG\"},\n        ...     json_file_name=\"logs/app.jsonl\"\n        ... )\n    \"\"\"\n    # Filter to only known attributes\n    valid_keys = {\n        \"level\", \"module_levels\", \"json_file_name\", \"json_file_only\",\n        \"use_syslog\", \"syslog_address\", \"show_time\", \"show_level\", \"show_path\"\n    }\n    filtered = {k: v for k, v in kwargs.items() if k in valid_keys}\n    return cls(**filtered)\n</code></pre>"},{"location":"reference/arlogi/config/#arlogi.config.LoggingConfig.resolve_module_level","title":"resolve_module_level","text":"<pre><code>resolve_module_level(name: str, level: str | int) -&gt; int\n</code></pre> <p>Resolve a module level to an integer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Module name (for error messages)</p> required <code>level</code> <code>str | int</code> <p>Level as string or int</p> required <p>Returns:</p> Type Description <code>int</code> <p>The level as an integer</p> Source code in <code>src/arlogi/config.py</code> <pre><code>def resolve_module_level(self, name: str, level: str | int) -&gt; int:\n    \"\"\"Resolve a module level to an integer.\n\n    Args:\n        name: Module name (for error messages)\n        level: Level as string or int\n\n    Returns:\n        The level as an integer\n    \"\"\"\n    if isinstance(level, str):\n        return getattr(logging, level.upper())\n    return level\n</code></pre>"},{"location":"reference/arlogi/config/#arlogi.config.LoggingConfig.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> <p>Convert configuration to a dictionary.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary representation of the configuration</p> Source code in <code>src/arlogi/config.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Convert configuration to a dictionary.\n\n    Returns:\n        Dictionary representation of the configuration\n    \"\"\"\n    return {\n        \"level\": self.level,\n        \"module_levels\": self.module_levels,\n        \"json_file_name\": self.json_file_name,\n        \"json_file_only\": self.json_file_only,\n        \"use_syslog\": self.use_syslog,\n        \"syslog_address\": self.syslog_address,\n        \"show_time\": self.show_time,\n        \"show_level\": self.show_level,\n        \"show_path\": self.show_path,\n    }\n</code></pre>"},{"location":"reference/arlogi/config/#arlogi.config.get_default_level","title":"get_default_level","text":"<pre><code>get_default_level() -&gt; int\n</code></pre> <p>Get the default log level based on the current environment.</p> <p>Returns DEBUG in test mode for better test visibility, otherwise returns INFO.</p> <p>Returns:</p> Type Description <code>int</code> <p>logging.DEBUG if in test mode, logging.INFO otherwise</p> Source code in <code>src/arlogi/config.py</code> <pre><code>def get_default_level() -&gt; int:\n    \"\"\"Get the default log level based on the current environment.\n\n    Returns DEBUG in test mode for better test visibility,\n    otherwise returns INFO.\n\n    Returns:\n        logging.DEBUG if in test mode, logging.INFO otherwise\n    \"\"\"\n    return logging.DEBUG if is_test_mode() else logging.INFO\n</code></pre>"},{"location":"reference/arlogi/config/#arlogi.config.is_test_mode","title":"is_test_mode","text":"<pre><code>is_test_mode() -&gt; bool\n</code></pre> <p>Detect if running under a test runner.</p> <p>Checks for pytest, unittest, or the PYTEST_CURRENT_TEST environment variable to determine if the code is running in a test context.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if running in a test environment</p> Source code in <code>src/arlogi/config.py</code> <pre><code>def is_test_mode() -&gt; bool:\n    \"\"\"Detect if running under a test runner.\n\n    Checks for pytest, unittest, or the PYTEST_CURRENT_TEST environment\n    variable to determine if the code is running in a test context.\n\n    Returns:\n        True if running in a test environment\n    \"\"\"\n    return (\n        \"pytest\" in sys.modules\n        or \"unittest\" in sys.modules\n        or os.environ.get(\"PYTEST_CURRENT_TEST\") is not None\n    )\n</code></pre>"},{"location":"reference/arlogi/factory/","title":"Factory","text":"<p>Factory for creating logger instances with caller attribution support.</p> <p>This module provides the LoggerFactory class for creating and configuring loggers, along with the TraceLogger class that adds custom TRACE level and caller attribution features.</p>"},{"location":"reference/arlogi/factory/#arlogi.factory.LoggerFactory","title":"LoggerFactory","text":"<p>Factory for creating and configuring logger instances.</p> <p>This factory manages the global logging configuration and provides methods to get logger instances with various configurations.</p>"},{"location":"reference/arlogi/factory/#arlogi.factory.LoggerFactory.get_global_logger","title":"get_global_logger  <code>classmethod</code>","text":"<pre><code>get_global_logger() -&gt; LoggerProtocol\n</code></pre> <p>Get or initialize the global logger instance.</p> <p>Returns:</p> Type Description <code>LoggerProtocol</code> <p>The global application logger instance</p> Source code in <code>src/arlogi/factory.py</code> <pre><code>@classmethod\ndef get_global_logger(cls) -&gt; LoggerProtocol:\n    \"\"\"Get or initialize the global logger instance.\n\n    Returns:\n        The global application logger instance\n    \"\"\"\n    if cls._global_logger is None:\n        cls._global_logger = cls.get_logger(\"app\")  # type: ignore\n    return cls._global_logger  # type: ignore\n</code></pre>"},{"location":"reference/arlogi/factory/#arlogi.factory.LoggerFactory.get_json_logger","title":"get_json_logger  <code>classmethod</code>","text":"<pre><code>get_json_logger(\n    name: str = \"json\", json_file_name: str | None = None\n) -&gt; LoggerProtocol\n</code></pre> <p>Get a logger that only outputs to JSON, bypassing root handlers.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Logger name suffix</p> <code>'json'</code> <code>json_file_name</code> <code>str | None</code> <p>Optional file path for JSON output</p> <code>None</code> <p>Returns:</p> Type Description <code>LoggerProtocol</code> <p>A JSON-only logger instance</p> Source code in <code>src/arlogi/factory.py</code> <pre><code>@classmethod\ndef get_json_logger(\n    cls, name: str = \"json\", json_file_name: str | None = None\n) -&gt; LoggerProtocol:\n    \"\"\"Get a logger that only outputs to JSON, bypassing root handlers.\n\n    Args:\n        name: Logger name suffix\n        json_file_name: Optional file path for JSON output\n\n    Returns:\n        A JSON-only logger instance\n    \"\"\"\n    logger = logging.getLogger(f\"arlogi.json.{name}\")\n    logger.propagate = False\n\n    if json_file_name:\n        logger.handlers = [JSONFileHandler(json_file_name)]\n    else:\n        logger.handlers = [JSONHandler()]\n\n    logger.setLevel(logging.DEBUG)\n    return logger  # type: ignore\n</code></pre>"},{"location":"reference/arlogi/factory/#arlogi.factory.LoggerFactory.get_logger","title":"get_logger  <code>classmethod</code>","text":"<pre><code>get_logger(name: str, level: int | str | None = None) -&gt; LoggerProtocol\n</code></pre> <p>Get a logger instance conforming to LoggerProtocol.</p> <p>Auto-initializes with default settings if called before setup().</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Logger name (typically name of the module)</p> required <code>level</code> <code>int | str | None</code> <p>Optional level override for this logger</p> <code>None</code> <p>Returns:</p> Type Description <code>LoggerProtocol</code> <p>A logger instance supporting caller attribution</p> Source code in <code>src/arlogi/factory.py</code> <pre><code>@classmethod\ndef get_logger(cls, name: str, level: int | str | None = None) -&gt; LoggerProtocol:\n    \"\"\"Get a logger instance conforming to LoggerProtocol.\n\n    Auto-initializes with default settings if called before setup().\n\n    Args:\n        name: Logger name (typically __name__ of the module)\n        level: Optional level override for this logger\n\n    Returns:\n        A logger instance supporting caller attribution\n    \"\"\"\n    if not cls._initialized:\n        cls.setup(level=get_default_level())\n\n    logger = logging.getLogger(name)\n    if level is not None:\n        logger.setLevel(level)\n\n    return logger  # type: ignore\n</code></pre>"},{"location":"reference/arlogi/factory/#arlogi.factory.LoggerFactory.get_syslog_logger","title":"get_syslog_logger  <code>classmethod</code>","text":"<pre><code>get_syslog_logger(\n    name: str = \"syslog\", address: str | tuple[str, int] = \"/dev/log\"\n) -&gt; LoggerProtocol\n</code></pre> <p>Get a logger that only outputs to Syslog, bypassing root handlers.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Logger name suffix</p> <code>'syslog'</code> <code>address</code> <code>str | tuple[str, int]</code> <p>Syslog server address</p> <code>'/dev/log'</code> <p>Returns:</p> Type Description <code>LoggerProtocol</code> <p>A syslog-only logger instance</p> Source code in <code>src/arlogi/factory.py</code> <pre><code>@classmethod\ndef get_syslog_logger(\n    cls, name: str = \"syslog\", address: str | tuple[str, int] = \"/dev/log\"\n) -&gt; LoggerProtocol:\n    \"\"\"Get a logger that only outputs to Syslog, bypassing root handlers.\n\n    Args:\n        name: Logger name suffix\n        address: Syslog server address\n\n    Returns:\n        A syslog-only logger instance\n    \"\"\"\n    logger = logging.getLogger(f\"arlogi.syslog.{name}\")\n    logger.propagate = False\n    logger.handlers = [ArlogiSyslogHandler(address=address)]\n    logger.setLevel(logging.DEBUG)\n    return logger  # type: ignore\n</code></pre>"},{"location":"reference/arlogi/factory/#arlogi.factory.LoggerFactory.is_test_mode","title":"is_test_mode  <code>staticmethod</code>","text":"<pre><code>is_test_mode() -&gt; bool\n</code></pre> <p>Detect if running under a test runner.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if pytest, unittest, or PYTEST_CURRENT_TEST is detected</p> Source code in <code>src/arlogi/factory.py</code> <pre><code>@staticmethod\ndef is_test_mode() -&gt; bool:\n    \"\"\"Detect if running under a test runner.\n\n    Returns:\n        True if pytest, unittest, or PYTEST_CURRENT_TEST is detected\n    \"\"\"\n    return is_test_mode()\n</code></pre>"},{"location":"reference/arlogi/factory/#arlogi.factory.LoggerFactory.setup","title":"setup  <code>classmethod</code>","text":"<pre><code>setup(\n    level: int | str = logging.INFO,\n    module_levels: dict[str, str | int] | None = None,\n    json_file_name: str | None = None,\n    json_file_only: bool = False,\n    use_syslog: bool = False,\n    syslog_address: str | tuple[str, int] = \"/dev/log\",\n    show_time: bool = False,\n    show_level: bool = True,\n    show_path: bool = True,\n) -&gt; None\n</code></pre> <p>Centralized logging setup for arlogi.</p> <p>This method configures the root logger with the specified handlers and levels. It can be called multiple times to update configuration.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int | str</code> <p>Global root log level</p> <code>INFO</code> <code>module_levels</code> <code>dict[str, str | int] | None</code> <p>Per-module level overrides</p> <code>None</code> <code>json_file_name</code> <code>str | None</code> <p>Path to JSON log file</p> <code>None</code> <code>json_file_only</code> <code>bool</code> <p>If True, only output JSON (no console)</p> <code>False</code> <code>use_syslog</code> <code>bool</code> <p>Enable syslog output</p> <code>False</code> <code>syslog_address</code> <code>str | tuple[str, int]</code> <p>Syslog server address</p> <code>'/dev/log'</code> <code>show_time</code> <code>bool</code> <p>Show timestamps in console output</p> <code>False</code> <code>show_level</code> <code>bool</code> <p>Show log levels in console output</p> <code>True</code> <code>show_path</code> <code>bool</code> <p>Show file paths in console output</p> <code>True</code> Source code in <code>src/arlogi/factory.py</code> <pre><code>@classmethod\ndef setup(\n    cls,\n    level: int | str = logging.INFO,\n    module_levels: dict[str, str | int] | None = None,\n    json_file_name: str | None = None,\n    json_file_only: bool = False,\n    use_syslog: bool = False,\n    syslog_address: str | tuple[str, int] = \"/dev/log\",\n    show_time: bool = False,\n    show_level: bool = True,\n    show_path: bool = True,\n) -&gt; None:\n    \"\"\"Centralized logging setup for arlogi.\n\n    This method configures the root logger with the specified handlers\n    and levels. It can be called multiple times to update configuration.\n\n    Args:\n        level: Global root log level\n        module_levels: Per-module level overrides\n        json_file_name: Path to JSON log file\n        json_file_only: If True, only output JSON (no console)\n        use_syslog: Enable syslog output\n        syslog_address: Syslog server address\n        show_time: Show timestamps in console output\n        show_level: Show log levels in console output\n        show_path: Show file paths in console output\n    \"\"\"\n    config = LoggingConfig.from_kwargs(\n        level=level,\n        module_levels=module_levels,\n        json_file_name=json_file_name,\n        json_file_only=json_file_only,\n        use_syslog=use_syslog,\n        syslog_address=syslog_address,\n        show_time=show_time,\n        show_level=show_level,\n        show_path=show_path,\n    )\n    cls._apply_configuration(config)\n</code></pre>"},{"location":"reference/arlogi/factory/#arlogi.factory.TraceLogger","title":"TraceLogger","text":"<p>               Bases: <code>Logger</code></p> <pre><code>\n              flowchart TD\n              arlogi.factory.TraceLogger[TraceLogger]\n\n              \n\n              click arlogi.factory.TraceLogger href \"\" \"arlogi.factory.TraceLogger\"\n            </code></pre> <p>Custom logger class with trace() and caller attribution support.</p> <p>This logger extends the standard Python Logger with: - A custom TRACE level (below DEBUG) - Caller attribution via from_/from_caller parameters - Automatic extra field handling from unknown kwargs</p>"},{"location":"reference/arlogi/factory/#arlogi.factory.TraceLogger.critical","title":"critical","text":"<pre><code>critical(msg: Any, *args: Any, **kwargs: Any) -&gt; None\n</code></pre> <p>Log a critical message.</p> Source code in <code>src/arlogi/factory.py</code> <pre><code>def critical(self, msg: Any, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Log a critical message.\"\"\"\n    msg, kwargs = self._process_params(msg, kwargs)\n    super().critical(msg, *args, **kwargs)\n</code></pre>"},{"location":"reference/arlogi/factory/#arlogi.factory.TraceLogger.debug","title":"debug","text":"<pre><code>debug(msg: Any, *args: Any, **kwargs: Any) -&gt; None\n</code></pre> <p>Log a debug message.</p> Source code in <code>src/arlogi/factory.py</code> <pre><code>def debug(self, msg: Any, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Log a debug message.\"\"\"\n    msg, kwargs = self._process_params(msg, kwargs)\n    super().debug(msg, *args, **kwargs)\n</code></pre>"},{"location":"reference/arlogi/factory/#arlogi.factory.TraceLogger.error","title":"error","text":"<pre><code>error(msg: Any, *args: Any, **kwargs: Any) -&gt; None\n</code></pre> <p>Log an error message.</p> Source code in <code>src/arlogi/factory.py</code> <pre><code>def error(self, msg: Any, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Log an error message.\"\"\"\n    msg, kwargs = self._process_params(msg, kwargs)\n    super().error(msg, *args, **kwargs)\n</code></pre>"},{"location":"reference/arlogi/factory/#arlogi.factory.TraceLogger.exception","title":"exception","text":"<pre><code>exception(msg: Any, *args: Any, **kwargs: Any) -&gt; None\n</code></pre> <p>Log an exception with traceback.</p> Source code in <code>src/arlogi/factory.py</code> <pre><code>def exception(self, msg: Any, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Log an exception with traceback.\"\"\"\n    msg, kwargs = self._process_params(msg, kwargs)\n    super().exception(msg, *args, **kwargs)\n</code></pre>"},{"location":"reference/arlogi/factory/#arlogi.factory.TraceLogger.info","title":"info","text":"<pre><code>info(msg: Any, *args: Any, **kwargs: Any) -&gt; None\n</code></pre> <p>Log an info message.</p> Source code in <code>src/arlogi/factory.py</code> <pre><code>def info(self, msg: Any, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Log an info message.\"\"\"\n    msg, kwargs = self._process_params(msg, kwargs)\n    super().info(msg, *args, **kwargs)\n</code></pre>"},{"location":"reference/arlogi/factory/#arlogi.factory.TraceLogger.log","title":"log","text":"<pre><code>log(level: int, msg: Any, *args: Any, **kwargs: Any) -&gt; None\n</code></pre> <p>Log a message at the specified level.</p> Source code in <code>src/arlogi/factory.py</code> <pre><code>def log(self, level: int, msg: Any, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Log a message at the specified level.\"\"\"\n    msg, kwargs = self._process_params(msg, kwargs)\n    super().log(level, msg, *args, **kwargs)\n</code></pre>"},{"location":"reference/arlogi/factory/#arlogi.factory.TraceLogger.trace","title":"trace","text":"<pre><code>trace(msg: Any, *args: Any, **kwargs: Any) -&gt; None\n</code></pre> <p>Log a message with TRACE level (below DEBUG).</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>Any</code> <p>The message to log</p> required <code>*args</code> <code>Any</code> <p>Format arguments for the message</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Optional from_/from_caller for caller attribution</p> <code>{}</code> Source code in <code>src/arlogi/factory.py</code> <pre><code>def trace(self, msg: Any, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Log a message with TRACE level (below DEBUG).\n\n    Args:\n        msg: The message to log\n        *args: Format arguments for the message\n        **kwargs: Optional from_/from_caller for caller attribution\n    \"\"\"\n    msg, kwargs = self._process_params(msg, kwargs)\n    if self.isEnabledFor(TRACE_LEVEL_NUM):\n        self._log(TRACE_LEVEL_NUM, msg, args, **kwargs)\n</code></pre>"},{"location":"reference/arlogi/factory/#arlogi.factory.TraceLogger.warning","title":"warning","text":"<pre><code>warning(msg: Any, *args: Any, **kwargs: Any) -&gt; None\n</code></pre> <p>Log a warning message.</p> Source code in <code>src/arlogi/factory.py</code> <pre><code>def warning(self, msg: Any, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Log a warning message.\"\"\"\n    msg, kwargs = self._process_params(msg, kwargs)\n    super().warning(msg, *args, **kwargs)\n</code></pre>"},{"location":"reference/arlogi/factory/#arlogi.factory.get_json_logger","title":"get_json_logger","text":"<pre><code>get_json_logger(\n    name: str = \"json\", json_file_name: str | None = None\n) -&gt; LoggerProtocol\n</code></pre> <p>Get a dedicated JSON-only logger.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Logger name suffix</p> <code>'json'</code> <code>json_file_name</code> <code>str | None</code> <p>Optional file path for JSON output</p> <code>None</code> <p>Returns:</p> Type Description <code>LoggerProtocol</code> <p>A JSON-only logger instance</p> Source code in <code>src/arlogi/factory.py</code> <pre><code>def get_json_logger(\n    name: str = \"json\", json_file_name: str | None = None\n) -&gt; LoggerProtocol:\n    \"\"\"Get a dedicated JSON-only logger.\n\n    Args:\n        name: Logger name suffix\n        json_file_name: Optional file path for JSON output\n\n    Returns:\n        A JSON-only logger instance\n    \"\"\"\n    return LoggerFactory.get_json_logger(name, json_file_name=json_file_name)\n</code></pre>"},{"location":"reference/arlogi/factory/#arlogi.factory.get_logger","title":"get_logger","text":"<pre><code>get_logger(name: str, level: int | str | None = None) -&gt; LoggerProtocol\n</code></pre> <p>Get a logger instance with caller attribution support.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Logger name (typically name)</p> required <code>level</code> <code>int | str | None</code> <p>Optional level override</p> <code>None</code> <p>Returns:</p> Type Description <code>LoggerProtocol</code> <p>A logger instance</p> Source code in <code>src/arlogi/factory.py</code> <pre><code>def get_logger(name: str, level: int | str | None = None) -&gt; LoggerProtocol:\n    \"\"\"Get a logger instance with caller attribution support.\n\n    Args:\n        name: Logger name (typically __name__)\n        level: Optional level override\n\n    Returns:\n        A logger instance\n    \"\"\"\n    return LoggerFactory.get_logger(name, level)\n</code></pre>"},{"location":"reference/arlogi/factory/#arlogi.factory.get_syslog_logger","title":"get_syslog_logger","text":"<pre><code>get_syslog_logger(\n    name: str = \"syslog\", address: str | tuple[str, int] = \"/dev/log\"\n) -&gt; LoggerProtocol\n</code></pre> <p>Get a dedicated syslog-only logger.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Logger name suffix</p> <code>'syslog'</code> <code>address</code> <code>str | tuple[str, int]</code> <p>Syslog server address</p> <code>'/dev/log'</code> <p>Returns:</p> Type Description <code>LoggerProtocol</code> <p>A syslog-only logger instance</p> Source code in <code>src/arlogi/factory.py</code> <pre><code>def get_syslog_logger(\n    name: str = \"syslog\", address: str | tuple[str, int] = \"/dev/log\"\n) -&gt; LoggerProtocol:\n    \"\"\"Get a dedicated syslog-only logger.\n\n    Args:\n        name: Logger name suffix\n        address: Syslog server address\n\n    Returns:\n        A syslog-only logger instance\n    \"\"\"\n    return LoggerFactory.get_syslog_logger(name, address)\n</code></pre>"},{"location":"reference/arlogi/factory/#arlogi.factory.setup_logging","title":"setup_logging","text":"<pre><code>setup_logging(\n    level: int | str = logging.INFO,\n    module_levels: dict[str, str | int] | None = None,\n    json_file_name: str | None = None,\n    json_file_only: bool = False,\n    use_syslog: bool = False,\n    syslog_address: str | tuple[str, int] = \"/dev/log\",\n    show_time: bool = False,\n    show_level: bool = True,\n    show_path: bool = True,\n) -&gt; None\n</code></pre> <p>Set up arlogi logging with the specified configuration.</p> <p>This is a convenience wrapper around LoggerFactory.setup().</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int | str</code> <p>Global root log level</p> <code>INFO</code> <code>module_levels</code> <code>dict[str, str | int] | None</code> <p>Per-module level overrides</p> <code>None</code> <code>json_file_name</code> <code>str | None</code> <p>Path to JSON log file</p> <code>None</code> <code>json_file_only</code> <code>bool</code> <p>If True, only output JSON (no console)</p> <code>False</code> <code>use_syslog</code> <code>bool</code> <p>Enable syslog output</p> <code>False</code> <code>syslog_address</code> <code>str | tuple[str, int]</code> <p>Syslog server address</p> <code>'/dev/log'</code> <code>show_time</code> <code>bool</code> <p>Show timestamps in console output</p> <code>False</code> <code>show_level</code> <code>bool</code> <p>Show log levels in console output</p> <code>True</code> <code>show_path</code> <code>bool</code> <p>Show file paths in console output</p> <code>True</code> Source code in <code>src/arlogi/factory.py</code> <pre><code>def setup_logging(\n    level: int | str = logging.INFO,\n    module_levels: dict[str, str | int] | None = None,\n    json_file_name: str | None = None,\n    json_file_only: bool = False,\n    use_syslog: bool = False,\n    syslog_address: str | tuple[str, int] = \"/dev/log\",\n    show_time: bool = False,\n    show_level: bool = True,\n    show_path: bool = True,\n) -&gt; None:\n    \"\"\"Set up arlogi logging with the specified configuration.\n\n    This is a convenience wrapper around LoggerFactory.setup().\n\n    Args:\n        level: Global root log level\n        module_levels: Per-module level overrides\n        json_file_name: Path to JSON log file\n        json_file_only: If True, only output JSON (no console)\n        use_syslog: Enable syslog output\n        syslog_address: Syslog server address\n        show_time: Show timestamps in console output\n        show_level: Show log levels in console output\n        show_path: Show file paths in console output\n    \"\"\"\n    LoggerFactory.setup(\n        level=level,\n        module_levels=module_levels,\n        json_file_name=json_file_name,\n        json_file_only=json_file_only,\n        use_syslog=use_syslog,\n        syslog_address=syslog_address,\n        show_time=show_time,\n        show_level=show_level,\n        show_path=show_path,\n    )\n</code></pre>"},{"location":"reference/arlogi/handler_factory/","title":"Handler factory","text":"<p>Handler factory for creating logging handlers.</p> <p>This module provides a centralized factory for creating log handlers, following the Factory pattern for consistent handler creation and easier testing.</p>"},{"location":"reference/arlogi/handler_factory/#arlogi.handler_factory.HandlerFactory","title":"HandlerFactory","text":"<p>Factory for creating logging handlers.</p> <p>This class encapsulates the creation logic for all handler types, making it easier to test and extend with new handler types.</p>"},{"location":"reference/arlogi/handler_factory/#arlogi.handler_factory.HandlerFactory.create_console","title":"create_console  <code>staticmethod</code>","text":"<pre><code>create_console(config: LoggingConfig) -&gt; ColoredConsoleHandler\n</code></pre> <p>Create a colored console handler.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>LoggingConfig</code> <p>Logging configuration</p> required <p>Returns:</p> Type Description <code>ColoredConsoleHandler</code> <p>A configured ColoredConsoleHandler instance</p> Example <p>handler = HandlerFactory.create_console( ...     LoggingConfig(show_time=True, show_level=True) ... )</p> Source code in <code>src/arlogi/handler_factory.py</code> <pre><code>@staticmethod\ndef create_console(config: LoggingConfig) -&gt; ColoredConsoleHandler:\n    \"\"\"Create a colored console handler.\n\n    Args:\n        config: Logging configuration\n\n    Returns:\n        A configured ColoredConsoleHandler instance\n\n    Example:\n        &gt;&gt;&gt; handler = HandlerFactory.create_console(\n        ...     LoggingConfig(show_time=True, show_level=True)\n        ... )\n    \"\"\"\n    return ColoredConsoleHandler(\n        show_time=config.show_time,\n        show_level=config.show_level,\n        show_path=config.show_path,\n    )\n</code></pre>"},{"location":"reference/arlogi/handler_factory/#arlogi.handler_factory.HandlerFactory.create_handlers","title":"create_handlers  <code>classmethod</code>","text":"<pre><code>create_handlers(config: LoggingConfig) -&gt; list[logging.Handler]\n</code></pre> <p>Create all handlers based on configuration.</p> <p>This is the main factory method that orchestrates the creation of all configured handlers.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>LoggingConfig</code> <p>Complete logging configuration</p> required <p>Returns:</p> Type Description <code>list[Handler]</code> <p>List of configured handler instances</p> Example <p>config = LoggingConfig( ...     json_file_name=\"logs/app.jsonl\", ...     use_syslog=True ... ) handlers = HandlerFactory.create_handlers(config) for handler in handlers: ...     logger.addHandler(handler)</p> Source code in <code>src/arlogi/handler_factory.py</code> <pre><code>@classmethod\ndef create_handlers(\n    cls, config: LoggingConfig\n) -&gt; list[logging.Handler]:\n    \"\"\"Create all handlers based on configuration.\n\n    This is the main factory method that orchestrates the creation\n    of all configured handlers.\n\n    Args:\n        config: Complete logging configuration\n\n    Returns:\n        List of configured handler instances\n\n    Example:\n        &gt;&gt;&gt; config = LoggingConfig(\n        ...     json_file_name=\"logs/app.jsonl\",\n        ...     use_syslog=True\n        ... )\n        &gt;&gt;&gt; handlers = HandlerFactory.create_handlers(config)\n        &gt;&gt;&gt; for handler in handlers:\n        ...     logger.addHandler(handler)\n    \"\"\"\n    handlers: list[logging.Handler] = []\n\n    # JSON file handler\n    if config.json_file_name:\n        handlers.append(cls.create_json_file(config))\n\n    # Console handler (show unless json_file_only)\n    if config.show_console:\n        handlers.append(cls.create_console(config))\n    elif config.json_file_only and not config.json_file_name:\n        # JSON on console when json_file_only=True but no file specified\n        handlers.append(cls.create_json_stream())\n\n    # Syslog handler\n    if config.use_syslog:\n        handlers.append(cls.create_syslog(config))\n\n    return handlers\n</code></pre>"},{"location":"reference/arlogi/handler_factory/#arlogi.handler_factory.HandlerFactory.create_json_file","title":"create_json_file  <code>staticmethod</code>","text":"<pre><code>create_json_file(config: LoggingConfig) -&gt; JSONFileHandler\n</code></pre> <p>Create a JSON file handler.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>LoggingConfig</code> <p>Logging configuration with json_file_name set</p> required <p>Returns:</p> Type Description <code>JSONFileHandler</code> <p>A JSONFileHandler instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If json_file_name is not set in config</p> Example <p>config = LoggingConfig(json_file_name=\"logs/app.jsonl\") handler = HandlerFactory.create_json_file(config)</p> Source code in <code>src/arlogi/handler_factory.py</code> <pre><code>@staticmethod\ndef create_json_file(config: LoggingConfig) -&gt; JSONFileHandler:\n    \"\"\"Create a JSON file handler.\n\n    Args:\n        config: Logging configuration with json_file_name set\n\n    Returns:\n        A JSONFileHandler instance\n\n    Raises:\n        ValueError: If json_file_name is not set in config\n\n    Example:\n        &gt;&gt;&gt; config = LoggingConfig(json_file_name=\"logs/app.jsonl\")\n        &gt;&gt;&gt; handler = HandlerFactory.create_json_file(config)\n    \"\"\"\n    if not config.json_file_name:\n        raise ValueError(\"json_file_name must be set in config\")\n\n    return JSONFileHandler(config.json_file_name)\n</code></pre>"},{"location":"reference/arlogi/handler_factory/#arlogi.handler_factory.HandlerFactory.create_json_handler","title":"create_json_handler  <code>staticmethod</code>","text":"<pre><code>create_json_handler(config: LoggingConfig) -&gt; logging.Handler\n</code></pre> <p>Create the appropriate JSON handler based on configuration.</p> <p>Creates either a JSONFileHandler (if json_file_name is set) or a JSONHandler for stream output.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>LoggingConfig</code> <p>Logging configuration</p> required <p>Returns:</p> Type Description <code>Handler</code> <p>Either JSONFileHandler or JSONHandler based on config</p> Example Source code in <code>src/arlogi/handler_factory.py</code> <pre><code>@staticmethod\ndef create_json_handler(config: LoggingConfig) -&gt; logging.Handler:\n    \"\"\"Create the appropriate JSON handler based on configuration.\n\n    Creates either a JSONFileHandler (if json_file_name is set)\n    or a JSONHandler for stream output.\n\n    Args:\n        config: Logging configuration\n\n    Returns:\n        Either JSONFileHandler or JSONHandler based on config\n\n    Example:\n        &gt;&gt;&gt; # File handler\n        &gt;&gt;&gt; config1 = LoggingConfig(json_file_name=\"logs/app.jsonl\")\n        &gt;&gt;&gt; handler1 = HandlerFactory.create_json_handler(config1)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Stream handler\n        &gt;&gt;&gt; config2 = LoggingConfig(json_file_only=True)\n        &gt;&gt;&gt; handler2 = HandlerFactory.create_json_handler(config2)\n    \"\"\"\n    if config.json_file_name:\n        return HandlerFactory.create_json_file(config)\n    return HandlerFactory.create_json_stream()\n</code></pre>"},{"location":"reference/arlogi/handler_factory/#arlogi.handler_factory.HandlerFactory.create_json_handler--file-handler","title":"File handler","text":"<p>config1 = LoggingConfig(json_file_name=\"logs/app.jsonl\") handler1 = HandlerFactory.create_json_handler(config1)</p>"},{"location":"reference/arlogi/handler_factory/#arlogi.handler_factory.HandlerFactory.create_json_handler--stream-handler","title":"Stream handler","text":"<p>config2 = LoggingConfig(json_file_only=True) handler2 = HandlerFactory.create_json_handler(config2)</p>"},{"location":"reference/arlogi/handler_factory/#arlogi.handler_factory.HandlerFactory.create_json_stream","title":"create_json_stream  <code>staticmethod</code>","text":"<pre><code>create_json_stream() -&gt; JSONHandler\n</code></pre> <p>Create a JSON stream handler (outputs to stderr).</p> <p>Returns:</p> Type Description <code>JSONHandler</code> <p>A JSONHandler instance configured for stream output</p> Example <p>handler = HandlerFactory.create_json_stream()</p> Source code in <code>src/arlogi/handler_factory.py</code> <pre><code>@staticmethod\ndef create_json_stream() -&gt; JSONHandler:\n    \"\"\"Create a JSON stream handler (outputs to stderr).\n\n    Returns:\n        A JSONHandler instance configured for stream output\n\n    Example:\n        &gt;&gt;&gt; handler = HandlerFactory.create_json_stream()\n    \"\"\"\n    return JSONHandler()\n</code></pre>"},{"location":"reference/arlogi/handler_factory/#arlogi.handler_factory.HandlerFactory.create_syslog","title":"create_syslog  <code>staticmethod</code>","text":"<pre><code>create_syslog(config: LoggingConfig) -&gt; ArlogiSyslogHandler\n</code></pre> <p>Create a syslog handler.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>LoggingConfig</code> <p>Logging configuration with syslog settings</p> required <p>Returns:</p> Type Description <code>ArlogiSyslogHandler</code> <p>An ArlogiSyslogHandler instance</p> Example <p>config = LoggingConfig( ...     use_syslog=True, ...     syslog_address=\"/dev/log\" ... ) handler = HandlerFactory.create_syslog(config)</p> Source code in <code>src/arlogi/handler_factory.py</code> <pre><code>@staticmethod\ndef create_syslog(config: LoggingConfig) -&gt; ArlogiSyslogHandler:\n    \"\"\"Create a syslog handler.\n\n    Args:\n        config: Logging configuration with syslog settings\n\n    Returns:\n        An ArlogiSyslogHandler instance\n\n    Example:\n        &gt;&gt;&gt; config = LoggingConfig(\n        ...     use_syslog=True,\n        ...     syslog_address=\"/dev/log\"\n        ... )\n        &gt;&gt;&gt; handler = HandlerFactory.create_syslog(config)\n    \"\"\"\n    return ArlogiSyslogHandler(address=config.syslog_address)\n</code></pre>"},{"location":"reference/arlogi/handlers/","title":"Handlers","text":"<p>Logging handlers for arlogi.</p> <p>This module provides custom logging handlers including: - ColoredConsoleHandler: Rich-based colored console output - JSONHandler/JSONFileHandler: Structured JSON logging - ArlogiSyslogHandler: Syslog integration with fallback support</p>"},{"location":"reference/arlogi/handlers/#arlogi.handlers.ArlogiSyslogHandler","title":"ArlogiSyslogHandler","text":"<pre><code>ArlogiSyslogHandler(\n    address: str | tuple[str, int] = \"/dev/log\",\n    facility: int | str = logging.handlers.SysLogHandler.LOG_USER,\n    socktype: int | None = None,\n)\n</code></pre> <p>               Bases: <code>SysLogHandler</code></p> <pre><code>\n              flowchart TD\n              arlogi.handlers.ArlogiSyslogHandler[ArlogiSyslogHandler]\n\n              \n\n              click arlogi.handlers.ArlogiSyslogHandler href \"\" \"arlogi.handlers.ArlogiSyslogHandler\"\n            </code></pre> <p>A robust syslog handler with standard formatting and automatic fallback.</p> <p>Features: - Standard arlogi formatting for consistent syslog messages - Automatic fallback to UDP on localhost:514 if /dev/log fails - Graceful degradation - won't crash the application if syslog is unavailable</p> <p>Initialize the syslog handler.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str | tuple[str, int]</code> <p>Syslog server address (default: \"/dev/log\" for Unix socket)</p> <code>'/dev/log'</code> <code>facility</code> <code>int | str</code> <p>Syslog facility (default: LOG_USER)</p> <code>LOG_USER</code> <code>socktype</code> <code>int | None</code> <p>Socket type (SOCK_STREAM or SOCK_DGRAM)</p> <code>None</code> Source code in <code>src/arlogi/handlers.py</code> <pre><code>def __init__(\n    self,\n    address: str | tuple[str, int] = \"/dev/log\",\n    facility: int | str = logging.handlers.SysLogHandler.LOG_USER,\n    socktype: int | None = None,\n):\n    \"\"\"Initialize the syslog handler.\n\n    Args:\n        address: Syslog server address (default: \"/dev/log\" for Unix socket)\n        facility: Syslog facility (default: LOG_USER)\n        socktype: Socket type (SOCK_STREAM or SOCK_DGRAM)\n    \"\"\"\n    try:\n        super().__init__(address=address, facility=facility, socktype=socktype)\n        self.setFormatter(\n            logging.Formatter(\"%(name)s[%(process)d]: %(levelname)s: %(message)s\")\n        )\n    except Exception as e:\n        # Fallback for systems without /dev/log (e.g., macOS or some containers)\n        if address == \"/dev/log\":\n            # Try UDP on localhost as a last resort\n            try:\n                super().__init__(\n                    address=(\"localhost\", 514),\n                    facility=facility,\n                    socktype=socktype\n                )\n            except Exception:\n                # If everything fails, silently continue - don't crash\n                # the application just because logging setup failed\n                pass\n        else:\n            raise e\n</code></pre>"},{"location":"reference/arlogi/handlers/#arlogi.handlers.ColoredConsoleHandler","title":"ColoredConsoleHandler","text":"<pre><code>ColoredConsoleHandler(\n    show_time: bool = False,\n    show_level: bool = True,\n    show_path: bool = True,\n    level_styles: dict[str, str] | None = None,\n    project_root: str | None = None,\n    *args: Any,\n    **kwargs: Any,\n)\n</code></pre> <p>               Bases: <code>RichHandler</code></p> <pre><code>\n              flowchart TD\n              arlogi.handlers.ColoredConsoleHandler[ColoredConsoleHandler]\n\n              \n\n              click arlogi.handlers.ColoredConsoleHandler href \"\" \"arlogi.handlers.ColoredConsoleHandler\"\n            </code></pre> <p>A logging handler that uses rich for colored console output.</p> <p>Features: - Automatic project root detection for relative file paths - Customizable color schemes per log level - Rich traceback support - Compact single-character level indicators (T, D, I, W, E, C)</p> <p>Initialize the colored console handler.</p> <p>Parameters:</p> Name Type Description Default <code>show_time</code> <code>bool</code> <p>Whether to show timestamps in output</p> <code>False</code> <code>show_level</code> <code>bool</code> <p>Whether to show log levels</p> <code>True</code> <code>show_path</code> <code>bool</code> <p>Whether to show file paths</p> <code>True</code> <code>level_styles</code> <code>dict[str, str] | None</code> <p>Custom color styles per level (e.g., {\"info\": \"blue\"})</p> <code>None</code> <code>project_root</code> <code>str | None</code> <p>Project root for relative path calculation</p> <code>None</code> <code>*args</code> <code>Any</code> <p>Additional positional arguments for RichHandler</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for RichHandler</p> <code>{}</code> Source code in <code>src/arlogi/handlers.py</code> <pre><code>def __init__(\n    self,\n    show_time: bool = False,\n    show_level: bool = True,\n    show_path: bool = True,\n    level_styles: dict[str, str] | None = None,\n    project_root: str | None = None,\n    *args: Any,\n    **kwargs: Any,\n):\n    \"\"\"Initialize the colored console handler.\n\n    Args:\n        show_time: Whether to show timestamps in output\n        show_level: Whether to show log levels\n        show_path: Whether to show file paths\n        level_styles: Custom color styles per level (e.g., {\"info\": \"blue\"})\n        project_root: Project root for relative path calculation\n        *args: Additional positional arguments for RichHandler\n        **kwargs: Additional keyword arguments for RichHandler\n    \"\"\"\n    # Default level styles: INFO is lighter (grey75) than DEBUG/TRACE (grey37)\n    default_styles = {\n        \"trace\": \"grey37\",\n        \"debug\": \"grey37\",\n        \"info\": \"grey75\",\n        \"warning\": \"yellow\",\n        \"error\": \"red\",\n        \"critical\": \"bold red\",\n    }\n    if level_styles:\n        default_styles.update(level_styles)\n\n    # Default to a console that supports colors and directed to stdout\n    if \"console\" not in kwargs:\n        kwargs[\"console\"] = Console(force_terminal=True, file=sys.stdout)\n\n    # Enable rich tracebacks by default for enhanced error display\n    kwargs.setdefault(\"rich_tracebacks\", True)\n    kwargs.setdefault(\"markup\", True)\n\n    super().__init__(\n        *args,\n        show_time=show_time,\n        show_level=show_level,\n        show_path=show_path,\n        **kwargs,\n    )\n\n    # Set level styles after initialization (for compatibility with older rich versions)\n    self.level_styles = default_styles\n\n    # Store project root for relative path calculation\n    self.project_root = project_root or self._find_project_root()\n</code></pre>"},{"location":"reference/arlogi/handlers/#arlogi.handlers.ColoredConsoleHandler.get_level_text","title":"get_level_text","text":"<pre><code>get_level_text(record: LogRecord) -&gt; Any\n</code></pre> <p>Get level text as a single character with styling.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>LogRecord</code> <p>The log record</p> required <p>Returns:</p> Type Description <code>Any</code> <p>A Rich Text object with the level character</p> Source code in <code>src/arlogi/handlers.py</code> <pre><code>def get_level_text(self, record: logging.LogRecord) -&gt; Any:\n    \"\"\"Get level text as a single character with styling.\n\n    Args:\n        record: The log record\n\n    Returns:\n        A Rich Text object with the level character\n    \"\"\"\n    from rich.text import Text\n\n    level_name = record.levelname\n    # Map TRACE to T, DEBUG to D, etc.\n    char = level_name[0]\n\n    style = self.level_styles.get(level_name.lower(), \"default\")\n    # Compact single character indicator\n    return Text(f\"{char} \", style=style)\n</code></pre>"},{"location":"reference/arlogi/handlers/#arlogi.handlers.ColoredConsoleHandler.render","title":"render","text":"<pre><code>render(*, record: LogRecord, traceback: Any, message_renderable: Any) -&gt; Any\n</code></pre> <p>Override render method to show relative paths from project root.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>LogRecord</code> <p>The log record to render</p> required <code>traceback</code> <code>Any</code> <p>Optional traceback information</p> required <code>message_renderable</code> <code>Any</code> <p>The formatted message</p> required <p>Returns:</p> Type Description <code>Any</code> <p>A renderable object for Rich to display</p> Source code in <code>src/arlogi/handlers.py</code> <pre><code>def render(\n    self,\n    *,\n    record: logging.LogRecord,\n    traceback: Any,\n    message_renderable: Any,\n) -&gt; Any:\n    \"\"\"Override render method to show relative paths from project root.\n\n    Args:\n        record: The log record to render\n        traceback: Optional traceback information\n        message_renderable: The formatted message\n\n    Returns:\n        A renderable object for Rich to display\n    \"\"\"\n    from pathlib import Path\n\n    # Calculate relative path instead of just filename\n    try:\n        relpath = os.path.relpath(record.pathname, self.project_root)\n        path = relpath\n    except (ValueError, OSError):\n        # Fallback to filename if relative path calculation fails\n        path = Path(record.pathname).name\n\n    level = self.get_level_text(record)\n    time_format = None if self.formatter is None else self.formatter.datefmt\n    from datetime import datetime\n    log_time = datetime.fromtimestamp(record.created)\n\n    log_renderable = self._log_render(\n        self.console,\n        [message_renderable] if not traceback else [message_renderable, traceback],\n        log_time=log_time,\n        time_format=time_format,\n        level=level,\n        path=path,\n        line_no=record.lineno,\n        link_path=None,  # Disable links to avoid file:// URLs\n    )\n    return log_renderable\n</code></pre>"},{"location":"reference/arlogi/handlers/#arlogi.handlers.ColoredConsoleHandler.render_message","title":"render_message","text":"<pre><code>render_message(record: LogRecord, message: str) -&gt; Any\n</code></pre> <p>Render message text with level-specific styling.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>LogRecord</code> <p>The log record</p> required <code>message</code> <code>str</code> <p>The message to render</p> required <p>Returns:</p> Type Description <code>Any</code> <p>A Rich Text object with the styled message</p> Source code in <code>src/arlogi/handlers.py</code> <pre><code>def render_message(self, record: logging.LogRecord, message: str) -&gt; Any:\n    \"\"\"Render message text with level-specific styling.\n\n    Args:\n        record: The log record\n        message: The message to render\n\n    Returns:\n        A Rich Text object with the styled message\n    \"\"\"\n    message_text = super().render_message(record, message)\n\n    # Apply style to the entire message text\n    level_name = record.levelname.lower()\n    style = self.level_styles.get(level_name, \"default\")\n\n    message_text.style = style\n    return message_text\n</code></pre>"},{"location":"reference/arlogi/handlers/#arlogi.handlers.JSONFileHandler","title":"JSONFileHandler","text":"<pre><code>JSONFileHandler(\n    filename: str,\n    mode: str = \"a\",\n    encoding: str | None = None,\n    delay: bool = False,\n)\n</code></pre> <p>               Bases: <code>FileHandler</code></p> <pre><code>\n              flowchart TD\n              arlogi.handlers.JSONFileHandler[JSONFileHandler]\n\n              \n\n              click arlogi.handlers.JSONFileHandler href \"\" \"arlogi.handlers.JSONFileHandler\"\n            </code></pre> <p>A logging handler that outputs log records as JSON to a file.</p> <p>Automatically creates parent directories if they don't exist.</p> <p>Initialize the JSON file handler.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the log file</p> required <code>mode</code> <code>str</code> <p>File open mode (default: \"a\" for append)</p> <code>'a'</code> <code>encoding</code> <code>str | None</code> <p>File encoding (default: None for system default)</p> <code>None</code> <code>delay</code> <code>bool</code> <p>Whether to delay file opening until first emit</p> <code>False</code> Source code in <code>src/arlogi/handlers.py</code> <pre><code>def __init__(\n    self,\n    filename: str,\n    mode: str = \"a\",\n    encoding: str | None = None,\n    delay: bool = False\n):\n    \"\"\"Initialize the JSON file handler.\n\n    Args:\n        filename: Path to the log file\n        mode: File open mode (default: \"a\" for append)\n        encoding: File encoding (default: None for system default)\n        delay: Whether to delay file opening until first emit\n    \"\"\"\n    # Ensure parent directory exists\n    parent_dir = os.path.dirname(os.path.abspath(filename))\n    if parent_dir and not os.path.exists(parent_dir):\n        os.makedirs(parent_dir, exist_ok=True)\n\n    super().__init__(filename, mode, encoding, delay)\n    self.setFormatter(JSONFormatter())\n</code></pre>"},{"location":"reference/arlogi/handlers/#arlogi.handlers.JSONFormatter","title":"JSONFormatter","text":"<p>               Bases: <code>Formatter</code></p> <pre><code>\n              flowchart TD\n              arlogi.handlers.JSONFormatter[JSONFormatter]\n\n              \n\n              click arlogi.handlers.JSONFormatter href \"\" \"arlogi.handlers.JSONFormatter\"\n            </code></pre> <p>JSON formatter for structured log output.</p> <p>Outputs log records as JSON with standard fields plus any extra fields added via the <code>extra</code> parameter.</p>"},{"location":"reference/arlogi/handlers/#arlogi.handlers.JSONFormatter.format","title":"format","text":"<pre><code>format(record: LogRecord) -&gt; str\n</code></pre> <p>Format log record as JSON.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>LogRecord</code> <p>The log record to format</p> required <p>Returns:</p> Type Description <code>str</code> <p>JSON string representation of the log record</p> Source code in <code>src/arlogi/handlers.py</code> <pre><code>def format(self, record: logging.LogRecord) -&gt; str:\n    \"\"\"Format log record as JSON.\n\n    Args:\n        record: The log record to format\n\n    Returns:\n        JSON string representation of the log record\n    \"\"\"\n    log_data = {\n        \"timestamp\": datetime.fromtimestamp(record.created).isoformat(),\n        \"level\": record.levelname,\n        \"logger_name\": record.name,\n        \"message\": record.getMessage(),\n        \"module\": record.module,\n        \"function\": record.funcName,\n        \"line_number\": record.lineno,\n    }\n\n    # Add exception info if present\n    if record.exc_info:\n        log_data[\"exception\"] = self.formatException(record.exc_info)\n\n    # Add extra fields from the record (excluding standard logging attributes)\n    standard_attrs = {\n        \"name\", \"msg\", \"args\", \"levelname\", \"levelno\", \"pathname\", \"filename\",\n        \"module\", \"exc_info\", \"exc_text\", \"stack_info\", \"lineno\", \"funcName\",\n        \"created\", \"msecs\", \"relativeCreated\", \"thread\", \"threadName\",\n        \"processName\", \"process\", \"message\"\n    }\n\n    for key, value in record.__dict__.items():\n        if key not in standard_attrs and not key.startswith(\"_\"):\n            log_data[key] = value\n\n    return json.dumps(log_data, default=str)\n</code></pre>"},{"location":"reference/arlogi/handlers/#arlogi.handlers.JSONHandler","title":"JSONHandler","text":"<pre><code>JSONHandler(stream: Any = None)\n</code></pre> <p>               Bases: <code>StreamHandler</code></p> <pre><code>\n              flowchart TD\n              arlogi.handlers.JSONHandler[JSONHandler]\n\n              \n\n              click arlogi.handlers.JSONHandler href \"\" \"arlogi.handlers.JSONHandler\"\n            </code></pre> <p>A logging handler that outputs log records as JSON to a stream.</p> <p>Defaults to stderr for compatibility with log aggregation tools.</p> <p>Initialize the JSON stream handler.</p> <p>Parameters:</p> Name Type Description Default <code>stream</code> <code>Any</code> <p>The stream to write to (defaults to sys.stderr if None)</p> <code>None</code> Source code in <code>src/arlogi/handlers.py</code> <pre><code>def __init__(self, stream: Any = None):\n    \"\"\"Initialize the JSON stream handler.\n\n    Args:\n        stream: The stream to write to (defaults to sys.stderr if None)\n    \"\"\"\n    super().__init__(stream)\n    self.setFormatter(JSONFormatter())\n</code></pre>"},{"location":"reference/arlogi/levels/","title":"Levels","text":""},{"location":"reference/arlogi/levels/#arlogi.levels.register_trace_level","title":"register_trace_level","text":"<pre><code>register_trace_level() -&gt; None\n</code></pre> <p>Register the TRACE level with the standard logging module.</p> Source code in <code>src/arlogi/levels.py</code> <pre><code>def register_trace_level() -&gt; None:\n    \"\"\"Register the TRACE level with the standard logging module.\"\"\"\n    if hasattr(logging, TRACE_LEVEL_NAME):\n        return\n\n    logging.addLevelName(TRACE_LEVEL_NUM, TRACE_LEVEL_NAME)\n    setattr(logging, TRACE_LEVEL_NAME, TRACE_LEVEL_NUM)\n\n    def trace(self: logging.Logger, message: str, *args: Any, **kws: Any) -&gt; None:\n        \"\"\"Log a message with TRACE level.\"\"\"\n        if self.isEnabledFor(TRACE_LEVEL_NUM):\n            self._log(TRACE_LEVEL_NUM, message, args, **kws)\n\n    logging.Logger.trace = trace  # type: ignore\n</code></pre>"},{"location":"reference/arlogi/types/","title":"Types","text":""},{"location":"reference/arlogi/types/#arlogi.types.LoggerProtocol","title":"LoggerProtocol","text":"<p>               Bases: <code>Protocol</code></p> <pre><code>\n              flowchart TD\n              arlogi.types.LoggerProtocol[LoggerProtocol]\n\n              \n\n              click arlogi.types.LoggerProtocol href \"\" \"arlogi.types.LoggerProtocol\"\n            </code></pre> <p>Protocol defining the interface for the arlogi logger.</p>"}]}